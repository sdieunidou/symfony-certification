{
  "source_file": "08-validation-donnees/logic.md",
  "title": "Validation Logique et Conditionnelle",
  "questions": [
    {
      "id": 1,
      "question": "Quelle contrainte permet d'arrêter la validation d'une propriété dès la première erreur rencontrée (pour éviter d'afficher 3 erreurs pour le même champ) ?",
      "type": "single_choice",
      "options": [
        "`StopOnError`",
        "`Sequentially`",
        "`GroupSequence`",
        "`Chain`"
      ],
      "correct_answers": [
        "`Sequentially`"
      ],
      "explanation": "`#[Assert\\Sequentially([...])]` exécute les contraintes dans l'ordre et s'arrête au premier échec."
    },
    {
      "id": 2,
      "question": "Quelle contrainte permet d'appliquer des règles de validation uniquement si une condition (expression) est vraie ?",
      "type": "single_choice",
      "options": [
        "`If`",
        "`When`",
        "`Condition`",
        "`Case`"
      ],
      "correct_answers": [
        "`When`"
      ],
      "explanation": "`#[Assert\\When(expression: 'this.isShipped', constraints: [...])]`."
    },
    {
      "id": 3,
      "question": "Quelle contrainte permet de valider qu'au moins une contrainte parmi une liste est respectée (ex: soit un email, soit un téléphone) ?",
      "type": "single_choice",
      "options": [
        "`OneOf`",
        "`AtLeastOneOf`",
        "`Any`",
        "`Either`"
      ],
      "correct_answers": [
        "`AtLeastOneOf`"
      ],
      "explanation": "Elle réussit si au moins une des validations internes passe."
    },
    {
      "id": 4,
      "question": "La contrainte `Expression` utilise-t-elle le moteur PHP natif ou un composant spécifique ?",
      "type": "single_choice",
      "options": [
        "PHP natif (eval).",
        "Le composant `ExpressionLanguage` de Symfony.",
        "Twig.",
        "SQL."
      ],
      "correct_answers": [
        "Le composant `ExpressionLanguage` de Symfony."
      ],
      "explanation": "Cela permet d'écrire des règles logiques (`this.amount > 10`) de manière sécurisée et compilée."
    },
    {
      "id": 5,
      "question": "Dans une contrainte `Expression`, comment accéder à une propriété privée de l'objet courant ?",
      "type": "single_choice",
      "options": [
        "Directement via `this.propertyName` (si un getter existe, il sera utilisé).",
        "Via `this.getPropertyName()` obligatoirement.",
        "Via `reflection.propertyName`.",
        "C'est impossible."
      ],
      "correct_answers": [
        "Directement via `this.propertyName` (si un getter existe, il sera utilisé)."
      ],
      "explanation": "L'ExpressionLanguage utilise le `PropertyAccessor` en coulisses."
    },
    {
      "id": 6,
      "question": "Quelle est la différence principale entre `Expression` et `When` ?",
      "type": "single_choice",
      "options": [
        "`Expression` valide une valeur, `When` active conditionnellement d'autres contraintes.",
        "Ils sont identiques.",
        "`When` est déprécié en faveur de `Expression`.",
        "`Expression` ne fonctionne que sur les classes."
      ],
      "correct_answers": [
        "`Expression` valide une valeur, `When` active conditionnellement d'autres contraintes."
      ],
      "explanation": "`Expression` retourne vrai/faux pour valider directement. `When` active un ensemble de contraintes seulement si l'expression est vraie."
    },
    {
      "id": 7,
      "question": "Dans une contrainte `Expression`, quelles variables sont disponibles dans le contexte d'évaluation ?",
      "type": "single_choice",
      "options": [
        "Uniquement `this` (l'objet courant).",
        "`this` (l'objet courant) et `value` (la valeur de la propriété si appliquée sur une propriété).",
        "`this`, `value`, et `form`.",
        "Aucune variable n'est disponible."
      ],
      "correct_answers": [
        "`this` (l'objet courant) et `value` (la valeur de la propriété si appliquée sur une propriété)."
      ],
      "explanation": "`this` représente l'objet validé, `value` représente la valeur de la propriété si la contrainte est appliquée sur une propriété."
    },
    {
      "id": 8,
      "question": "Quel est l'avantage principal de `Sequentially` par rapport à une liste de contraintes normales ?",
      "type": "single_choice",
      "options": [
        "Cela valide plus rapidement.",
        "Cela améliore l'UX en affichant une seule erreur à la fois et évite d'exécuter des validations lourdes (regex) sur des données déjà invalides.",
        "Cela permet de valider plusieurs propriétés.",
        "Cela réduit le nombre de contraintes nécessaires."
      ],
      "correct_answers": [
        "Cela améliore l'UX en affichant une seule erreur à la fois et évite d'exécuter des validations lourdes (regex) sur des données déjà invalides."
      ],
      "explanation": "L'arrêt au premier échec évite de bombarder l'utilisateur avec plusieurs erreurs pour le même champ et optimise les performances."
    },
    {
      "id": 9,
      "question": "Peut-on utiliser `When` avec une expression qui fait référence à plusieurs propriétés de l'objet ?",
      "type": "single_choice",
      "options": [
        "Non, `When` ne peut référencer que la propriété courante.",
        "Oui, l'expression peut accéder à toutes les propriétés de l'objet via `this.propertyName`.",
        "Seulement si les propriétés sont publiques.",
        "Uniquement avec des getters explicites."
      ],
      "correct_answers": [
        "Oui, l'expression peut accéder à toutes les propriétés de l'objet via `this.propertyName`."
      ],
      "explanation": "L'ExpressionLanguage permet d'accéder à toutes les propriétés de l'objet, même privées (via getters)."
    },
    {
      "id": 10,
      "question": "Quelle contrainte est préférable pour des conditions simples basées sur l'état de l'objet : `When` ou des Groupes de validation dynamiques ?",
      "type": "single_choice",
      "options": [
        "Les groupes sont toujours préférables.",
        "`When` est généralement plus lisible pour des conditions simples basées sur l'état de l'objet.",
        "Cela dépend de la version de Symfony.",
        "Les deux sont équivalents."
      ],
      "correct_answers": [
        "`When` est généralement plus lisible pour des conditions simples basées sur l'état de l'objet."
      ],
      "explanation": "`When` garde la logique conditionnelle près de la contrainte, tandis que les groupes dynamiques nécessitent une closure dans le formulaire."
    }
  ]
}