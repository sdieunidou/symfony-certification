{
  "source_file": "08-validation-donnees/groupes.md",
  "title": "Groupes de Validation",
  "questions": [
    {
      "id": 1,
      "question": "Si aucune option `groups` n'est spécifiée sur une contrainte, à quel groupe appartient-elle ?",
      "type": "single_choice",
      "options": [
        "`Global`",
        "`Default`",
        "`All`",
        "`Main`"
      ],
      "correct_answers": [
        "`Default`"
      ],
      "explanation": "C'est le groupe standard validé par défaut."
    },
    {
      "id": 2,
      "question": "À quoi correspond le groupe de validation portant le nom de la classe (ex: `App\\Entity\\User` ou juste `User`) ?",
      "type": "single_choice",
      "options": [
        "À un groupe personnalisé qu'il faut créer.",
        "C'est un alias du groupe `Default` pour cette classe.",
        "C'est un groupe réservé aux callbacks.",
        "C'est le groupe pour la validation de base de données."
      ],
      "correct_answers": [
        "C'est un alias du groupe `Default` pour cette classe."
      ],
      "explanation": "Cela permet d'inclure les contraintes par défaut de la classe User lorsqu'on valide une séquence de groupes."
    },
    {
      "id": 3,
      "question": "Si vous validez le groupe `['registration']`, les contraintes du groupe `Default` sont-elles validées ?",
      "type": "single_choice",
      "options": [
        "Oui, toujours.",
        "Non, seuls les groupes explicitement demandés sont validés.",
        "Oui, si `registration` étend `Default`.",
        "Seulement si elles sont critiques."
      ],
      "correct_answers": [
        "Non, seuls les groupes explicitement demandés sont validés."
      ],
      "explanation": "Si vous voulez aussi les contraintes par défaut, il faut passer `['Default', 'registration']`."
    },
    {
      "id": 4,
      "question": "Dans un formulaire, comment définir dynamiquement les groupes de validation (ex: selon les données saisies) ?",
      "type": "single_choice",
      "options": [
        "En utilisant un Listener `PRE_SUBMIT`.",
        "En passant une Closure (fonction anonyme) à l'option `validation_groups` dans `configureOptions`.",
        "C'est impossible.",
        "En modifiant l'entité."
      ],
      "correct_answers": [
        "En passant une Closure (fonction anonyme) à l'option `validation_groups` dans `configureOptions`."
      ],
      "explanation": "La closure reçoit le formulaire en argument et peut retourner un tableau de groupes basé sur les données (`$form->getData()`)."
    },
    {
      "id": 5,
      "question": "Est-il possible d'hériter les groupes de validation entre classes parent/enfant ?",
      "type": "single_choice",
      "options": [
        "Non, les groupes sont isolés par classe.",
        "Oui, les contraintes de la classe parente sont automatiquement prises en compte si le groupe `Default` est validé.",
        "Seulement si on utilise l'attribut `#[InheritConstraints]`.",
        "Oui, mais il faut copier-coller les contraintes."
      ],
      "correct_answers": [
        "Oui, les contraintes de la classe parente sont automatiquement prises en compte si le groupe `Default` est validé."
      ],
      "explanation": "L'héritage des métadonnées de validation fonctionne nativement avec l'héritage PHP."
    },
    {
      "id": 6,
      "question": "Si une contrainte appartient à plusieurs groupes (ex: `groups: ['registration', 'profile']`), quand sera-t-elle validée ?",
      "type": "single_choice",
      "options": [
        "Elle sera validée uniquement si TOUS les groupes sont demandés.",
        "Elle sera validée si AU MOINS UN des groupes est demandé (intersection).",
        "Elle sera validée deux fois (une fois par groupe).",
        "Cela dépend de la configuration."
      ],
      "correct_answers": [
        "Elle sera validée si AU MOINS UN des groupes est demandé (intersection)."
      ],
      "explanation": "Une contrainte est validée si au moins un de ses groupes correspond aux groupes demandés lors de la validation."
    },
    {
      "id": 7,
      "question": "Dans un formulaire, quelle est la valeur par défaut de l'option `validation_groups` si elle n'est pas spécifiée ?",
      "type": "single_choice",
      "options": [
        "`['Default']`",
        "`null` (tous les groupes).",
        "Le nom de la classe de l'entité.",
        "Aucun groupe n'est validé."
      ],
      "correct_answers": [
        "`['Default']`"
      ],
      "explanation": "Par défaut, le formulaire valide le groupe `Default`, qui correspond aux contraintes sans groupe explicite."
    },
    {
      "id": 8,
      "question": "Peut-on utiliser une chaîne de caractères simple au lieu d'un tableau pour `validation_groups` dans un formulaire ?",
      "type": "single_choice",
      "options": [
        "Non, il faut toujours un tableau.",
        "Oui, `validation_groups: 'registration'` est équivalent à `['registration']`.",
        "Seulement pour le groupe `Default`.",
        "Uniquement avec une closure."
      ],
      "correct_answers": [
        "Oui, `validation_groups: 'registration'` est équivalent à `['registration']`."
      ],
      "explanation": "Symfony accepte une chaîne simple qui sera convertie en tableau à un seul élément."
    },
    {
      "id": 9,
      "question": "Quelle est la meilleure pratique concernant l'utilisation de nombreux groupes de validation sur une même entité ?",
      "type": "single_choice",
      "options": [
        "C'est toujours la meilleure approche, peu importe le nombre de groupes.",
        "Parfois, créer deux DTOs distincts (`RegistrationDto`, `ProfileDto`) est plus propre que de bourrer l'entité User de groupes conditionnels.",
        "Il faut toujours utiliser des groupes plutôt que des DTOs séparés.",
        "Les groupes sont dépréciés en faveur des DTOs."
      ],
      "correct_answers": [
        "Parfois, créer deux DTOs distincts (`RegistrationDto`, `ProfileDto`) est plus propre que de bourrer l'entité User de groupes conditionnels."
      ],
      "explanation": "Trop de groupes rendent le code difficile à lire et maintenir. Les DTOs séparés peuvent être plus clairs pour des contextes très différents."
    },
    {
      "id": 10,
      "question": "Si vous validez un objet avec `$validator->validate($user, null, ['registration'])`, que signifie le deuxième paramètre `null` ?",
      "type": "single_choice",
      "options": [
        "Il indique qu'aucune contrainte ne doit être appliquée.",
        "Il signifie 'utiliser les contraintes définies sur l'objet' (métadonnées de la classe).",
        "C'est une erreur, il faut passer un tableau vide.",
        "Il désactive la validation."
      ],
      "correct_answers": [
        "Il signifie 'utiliser les contraintes définies sur l'objet' (métadonnées de la classe)."
      ],
      "explanation": "Le deuxième paramètre permet de passer des contraintes ad-hoc. `null` signifie utiliser les contraintes définies via attributs/YAML sur la classe."
    }
  ]
}