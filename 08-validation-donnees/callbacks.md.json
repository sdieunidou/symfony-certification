{
  "source_file": "08-validation-donnees/callbacks.md",
  "title": "Validateurs Callback",
  "questions": [
    {
      "id": 1,
      "question": "Quel est l'intérêt d'utiliser une contrainte Callback (`#[Assert\\Callback]`) ?",
      "type": "single_choice",
      "options": [
        "Valider un email.",
        "Implémenter une règle de validation métier spécifique et complexe directement dans l'entité, sans créer de classe de contrainte séparée.",
        "Appeler une API externe.",
        "Créer un service."
      ],
      "correct_answers": [
        "Implémenter une règle de validation métier spécifique et complexe directement dans l'entité, sans créer de classe de contrainte séparée."
      ],
      "explanation": "C'est idéal pour les règles 'one-shot' qui ne seront pas réutilisées ailleurs."
    },
    {
      "id": 2,
      "question": "Quel objet est passé en premier argument de la méthode de callback ?",
      "type": "single_choice",
      "options": [
        "`Request`",
        "`ConstraintViolationList`",
        "`ExecutionContextInterface`",
        "`FormInterface`"
      ],
      "correct_answers": [
        "`ExecutionContextInterface`"
      ],
      "explanation": "L'ExecutionContext permet d'ajouter des violations (`buildViolation(...)->addViolation()`)."
    },
    {
      "id": 3,
      "question": "Peut-on injecter des services (ex: Repository) dans un callback de validation défini dans une entité ?",
      "type": "single_choice",
      "options": [
        "Oui, via le constructeur de l'entité.",
        "Non, l'entité n'est pas un service. Pour utiliser des services, il faut créer une Contrainte Personnalisée (Custom Constraint).",
        "Oui, en ajoutant des arguments à la méthode de callback.",
        "Oui, via l'autowiring."
      ],
      "correct_answers": [
        "Non, l'entité n'est pas un service. Pour utiliser des services, il faut créer une Contrainte Personnalisée (Custom Constraint)."
      ],
      "explanation": "Le callback est limité aux données internes de l'objet validé."
    },
    {
      "id": 4,
      "question": "Comment attacher une erreur de validation à un champ spécifique depuis un callback ?",
      "type": "single_choice",
      "options": [
        "`$context->addError('message', 'field_name')`",
        "`$context->buildViolation('message')->atPath('field_name')->addViolation()`",
        "`throw new ValidationException('message', 'field_name')`",
        "Ce n'est pas possible, l'erreur est toujours globale."
      ],
      "correct_answers": [
        "`$context->buildViolation('message')->atPath('field_name')->addViolation()`"
      ],
      "explanation": "`atPath` permet de cibler une propriété pour que l'erreur s'affiche à côté du champ dans le formulaire."
    },
    {
      "id": 5,
      "question": "Peut-on utiliser une méthode statique comme callback de validation ?",
      "type": "single_choice",
      "options": [
        "Non, uniquement des méthodes d'instance.",
        "Oui, en passant un array `[Classe::class, 'methodName']` à l'attribut `#[Assert\\Callback]`.",
        "Uniquement si l'entité est statique.",
        "Seulement dans les DTOs."
      ],
      "correct_answers": [
        "Oui, en passant un array `[Classe::class, 'methodName']` à l'attribut `#[Assert\\Callback]`."
      ],
      "explanation": "C'est utile pour externaliser la logique de validation et ne pas polluer la classe de l'entité."
    },
    {
      "id": 6,
      "question": "Quelle est la visibilité recommandée pour une méthode de callback de validation ?",
      "type": "single_choice",
      "options": [
        "`private` uniquement.",
        "`public` (recommandé), bien que `private` ou `protected` fonctionnent si l'attribut est sur la méthode elle-même.",
        "`protected` uniquement.",
        "Cela dépend de l'environnement."
      ],
      "correct_answers": [
        "`public` (recommandé), bien que `private` ou `protected` fonctionnent si l'attribut est sur la méthode elle-même."
      ],
      "explanation": "La méthode doit être accessible au validateur. `public` est la pratique recommandée pour la clarté."
    },
    {
      "id": 7,
      "question": "À quel moment le callback de validation est-il exécuté par rapport aux autres contraintes ?",
      "type": "single_choice",
      "options": [
        "Avant toutes les autres contraintes.",
        "Après les validations de champs simples (NotBlank, Length), sauf si des groupes ou séquences changent l'ordre.",
        "En même temps que toutes les autres contraintes.",
        "Uniquement si toutes les autres contraintes passent."
      ],
      "correct_answers": [
        "Après les validations de champs simples (NotBlank, Length), sauf si des groupes ou séquences changent l'ordre."
      ],
      "explanation": "Le callback est généralement exécuté après les validations basiques, permettant de valider des règles métier complexes basées sur plusieurs propriétés."
    },
    {
      "id": 8,
      "question": "Si vous avez besoin d'accéder à la base de données dans un callback de validation, quelle est la meilleure approche ?",
      "type": "single_choice",
      "options": [
        "Injecter l'EntityManager dans le constructeur de l'entité.",
        "Créer une Contrainte Personnalisée (Custom Constraint) avec un Validator qui peut injecter des services.",
        "Utiliser une variable globale.",
        "C'est impossible."
      ],
      "correct_answers": [
        "Créer une Contrainte Personnalisée (Custom Constraint) avec un Validator qui peut injecter des services."
      ],
      "explanation": "Les entités ne sont pas des services, donc pas d'injection de dépendances. Les validateurs personnalisés sont des services et peuvent recevoir l'EntityManager."
    },
    {
      "id": 9,
      "question": "Quel est le deuxième paramètre de la méthode de callback (après `ExecutionContextInterface`) ?",
      "type": "single_choice",
      "options": [
        "L'objet validé.",
        "Le `payload` (données arbitraires) défini dans la contrainte.",
        "Le groupe de validation actif.",
        "La liste des violations existantes."
      ],
      "correct_answers": [
        "Le `payload` (données arbitraires) défini dans la contrainte."
      ],
      "explanation": "Le payload permet de passer des données contextuelles à la méthode de callback pour personnaliser le comportement."
    },
    {
      "id": 10,
      "question": "Peut-on utiliser un callback pour valider une propriété spécifique plutôt que la classe entière ?",
      "type": "single_choice",
      "options": [
        "Non, les callbacks s'appliquent toujours à la classe entière.",
        "Oui, en plaçant l'attribut `#[Assert\\Callback]` directement sur la propriété concernée.",
        "Oui, mais uniquement avec une méthode statique.",
        "Oui, en utilisant `atPath` dans le callback."
      ],
      "correct_answers": [
        "Oui, en plaçant l'attribut `#[Assert\\Callback]` directement sur la propriété concernée."
      ],
      "explanation": "L'attribut peut être placé sur une propriété pour valider spécifiquement ce champ, ou sur la classe pour une validation globale."
    }
  ]
}