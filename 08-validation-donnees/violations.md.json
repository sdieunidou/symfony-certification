{
  "source_file": "08-validation-donnees/violations.md",
  "title": "Violations et Contraintes Personnalisées",
  "questions": [
    {
      "id": 1,
      "question": "Quels sont les deux composants principaux nécessaires pour créer une contrainte de validation personnalisée classique (non composée) ?",
      "type": "single_choice",
      "options": [
        "Une classe de Contrainte (DTO) et une classe de Validateur (Logique).",
        "Une Interface et un Trait.",
        "Un Service et un EventListener.",
        "Une Entité et un Repository."
      ],
      "correct_answers": [
        "Une classe de Contrainte (DTO) et une classe de Validateur (Logique)."
      ],
      "explanation": "La classe de contrainte définit la configuration (message, options) et le validateur contient la logique de validation (`validate()`)."
    },
    {
      "id": 2,
      "question": "Quel est le rôle de l'attribut `#[HasNamedArguments]` sur le constructeur d'une contrainte personnalisée ?",
      "type": "single_choice",
      "options": [
        "Il indique que la contrainte ne peut pas avoir d'arguments.",
        "Il permet de mapper directement les arguments nommés de l'attribut PHP aux paramètres du constructeur.",
        "Il force l'utilisation d'un tableau `$options` unique.",
        "Il est obsolète depuis PHP 8."
      ],
      "correct_answers": [
        "Il permet de mapper directement les arguments nommés de l'attribut PHP aux paramètres du constructeur."
      ],
      "explanation": "Sans cet attribut, Symfony pourrait tenter de passer les options comme un tableau unique. Il améliore la lisibilité et le typage strict."
    },
    {
      "id": 3,
      "question": "Comment définir une option 'par défaut' pour une contrainte (celle utilisée si aucun nom d'argument n'est fourni, ex: `#[MyConstraint('valeur')]`) ?",
      "type": "single_choice",
      "options": [
        "En la nommant `value` dans le constructeur.",
        "En surchargeant la méthode `getDefaultOption()` pour retourner le nom de la propriété.",
        "Ce n'est pas possible, il faut toujours nommer les arguments.",
        "En utilisant l'annotation `@Default`."
      ],
      "correct_answers": [
        "En surchargeant la méthode `getDefaultOption()` pour retourner le nom de la propriété."
      ],
      "explanation": "La méthode `getDefaultOption()` retourne le nom de l'option qui recevra la valeur passée sans nom d'argument."
    },
    {
      "id": 4,
      "question": "Dans un `ConstraintValidator`, quel objet est utilisé pour ajouter une violation ?",
      "type": "single_choice",
      "options": [
        "`$this->violations`",
        "`$this->context` (`ExecutionContextInterface`)",
        "`$this->errors`",
        "`$this->validator`"
      ],
      "correct_answers": [
        "`$this->context` (`ExecutionContextInterface`)"
      ],
      "explanation": "On utilise `$this->context->buildViolation(...)->addViolation()`."
    },
    {
      "id": 5,
      "question": "Quelle est la bonne pratique concernant les valeurs `null` ou vides dans une contrainte personnalisée ?",
      "type": "single_choice",
      "options": [
        "Il faut toujours retourner une erreur si la valeur est vide.",
        "Il faut les ignorer (`return` immédiat) et laisser `NotNull` ou `NotBlank` gérer cela.",
        "Il faut lancer une exception.",
        "Il faut les convertir en chaîne vide."
      ],
      "correct_answers": [
        "Il faut les ignorer (`return` immédiat) et laisser `NotNull` ou `NotBlank` gérer cela."
      ],
      "explanation": "Cela permet de composer les contraintes. Si un champ est optionnel, votre contrainte ne doit pas échouer s'il est vide."
    },
    {
      "id": 6,
      "question": "Si votre classe de contrainte contient des propriétés privées, quelle méthode magique devez-vous implémenter pour qu'elles soient mises en cache correctement ?",
      "type": "single_choice",
      "options": [
        "`__wakeup()`",
        "`__sleep()`",
        "`__toString()`",
        "`__serialize()`"
      ],
      "correct_answers": [
        "`__sleep()`"
      ],
      "explanation": "La classe parente `Constraint` utilise `get_object_vars` qui ne voit pas les propriétés privées des enfants. Il faut les retourner explicitement dans `__sleep`."
    },
    {
      "id": 7,
      "question": "Comment injecter des dépendances (services) dans un validateur personnalisé ?",
      "type": "single_choice",
      "options": [
        "Ce n'est pas possible, les validateurs sont instanciés manuellement.",
        "Il faut les passer via le constructeur de la Contrainte.",
        "Le validateur est un service (autowired), on utilise donc l'injection via son constructeur.",
        "Il faut utiliser le conteneur global."
      ],
      "correct_answers": [
        "Le validateur est un service (autowired), on utilise donc l'injection via son constructeur."
      ],
      "explanation": "Avec la configuration par défaut (`autowire: true`), les validateurs sont automatiquement enregistrés comme services."
    },
    {
      "id": 8,
      "question": "Qu'est-ce qu'une 'Compound Constraint' (Contrainte Composée) ?",
      "type": "single_choice",
      "options": [
        "Une contrainte qui s'applique à plusieurs classes.",
        "Une contrainte définie par une collection d'autres contraintes existantes, sans validateur spécifique.",
        "Une contrainte qui lance une exception au lieu d'une violation.",
        "Une contrainte qui nécessite une base de données."
      ],
      "correct_answers": [
        "Une contrainte définie par une collection d'autres contraintes existantes, sans validateur spécifique."
      ],
      "explanation": "Elle étend `Compound` et définit `getConstraints()`. Elle permet de regrouper des règles réutilisables."
    },
    {
      "id": 9,
      "question": "Quelle classe de test utiliser pour tester un validateur personnalisé ?",
      "type": "single_choice",
      "options": [
        "`KernelTestCase`",
        "`WebTestCase`",
        "`ConstraintValidatorTestCase`",
        "`PHPUnit\\Framework\\TestCase`"
      ],
      "correct_answers": [
        "`ConstraintValidatorTestCase`"
      ],
      "explanation": "C'est une classe utilitaire fournie par Symfony pour tester un validateur de manière isolée."
    },
    {
      "id": 10,
      "question": "Comment faire en sorte qu'une contrainte s'applique à la classe entière (et non à une propriété) ?",
      "type": "single_choice",
      "options": [
        "En surchargeant la méthode `getTargets()` pour retourner `self::CLASS_CONSTRAINT`.",
        "En mettant l'attribut sur une méthode `__construct`.",
        "En utilisant l'option `global: true`.",
        "Ce n'est pas possible."
      ],
      "correct_answers": [
        "En surchargeant la méthode `getTargets()` pour retourner `self::CLASS_CONSTRAINT`."
      ],
      "explanation": "Le validateur recevra alors l'instance de l'objet complet dans `$value`."
    }
  ]
}