{
  "source_file": "07-formulaires/creation.md",
  "title": "Création de Formulaires",
  "questions": [
    {
      "id": 1,
      "question": "Quelle classe de base doit-on étendre pour créer un formulaire réutilisable ?",
      "type": "single_choice",
      "options": [
        "`Symfony\\Component\\Form\\FormType`",
        "`Symfony\\Component\\Form\\AbstractType`",
        "`Symfony\\Component\\Form\\BaseType`",
        "`App\\Form\\Type`"
      ],
      "correct_answers": [
        "`Symfony\\Component\\Form\\AbstractType`"
      ],
      "explanation": "C'est la classe standard pour définir la structure (`buildForm`) et la configuration (`configureOptions`) d'un formulaire."
    },
    {
      "id": 2,
      "question": "Quelle option permet de lier le formulaire à une classe d'entité (Mapping automatique) ?",
      "type": "single_choice",
      "options": [
        "`entity_class`",
        "`class`",
        "`data_class`",
        "`model`"
      ],
      "correct_answers": [
        "`data_class`"
      ],
      "explanation": "L'option `data_class` indique à Symfony quel type d'objet créer et hydrater."
    },
    {
      "id": 3,
      "question": "Comment créer un formulaire directement dans le contrôleur sans créer de classe dédiée ?",
      "type": "single_choice",
      "options": [
        "Via `$this->createFormBuilder(...)`.",
        "Via `new Form()`.",
        "Via `$this->createForm(...)`.",
        "Ce n'est pas possible."
      ],
      "correct_answers": [
        "Via `$this->createFormBuilder(...)`."
      ],
      "explanation": "Le FormBuilder permet de définir les champs à la volée. C'est utile pour les formulaires très simples ou uniques (ex: delete button)."
    },
    {
      "id": 4,
      "question": "Si vous ne spécifiez pas le type de champ (ex: `->add('name')`), que fait Symfony ?",
      "type": "single_choice",
      "options": [
        "Il utilise `TextType` par défaut.",
        "Il essaie de deviner le type (Type Guessing) en analysant les métadonnées de validation et de l'ORM.",
        "Il lance une erreur.",
        "Il ignore le champ."
      ],
      "correct_answers": [
        "Il essaie de deviner le type (Type Guessing) en analysant les métadonnées de validation et de l'ORM."
      ],
      "explanation": "Si la propriété est un `bool` ou a une annotation `@ORM\\Column(type='boolean')`, Symfony utilisera `CheckboxType`."
    },
    {
      "id": 5,
      "question": "Dans quelle méthode de `AbstractType` définit-on les options par défaut du formulaire (comme `data_class`) ?",
      "type": "single_choice",
      "options": [
        "`buildForm`",
        "`configureOptions`",
        "`getDefaults`",
        "`init`"
      ],
      "correct_answers": [
        "`configureOptions`"
      ],
      "explanation": "On utilise l'objet `OptionsResolver` passé en argument pour définir les valeurs par défaut."
    },
    {
      "id": 6,
      "question": "Pourquoi est-il souvent recommandé d'utiliser un DTO (Data Transfer Object) plutôt que l'entité Doctrine directement dans un formulaire ?",
      "type": "single_choice",
      "options": [
        "Pour des raisons de performance SQL.",
        "Pour découpler la structure de la base de données de l'interface utilisateur (ex: mot de passe en clair vs hashé, champs combinés).",
        "Parce que Doctrine est incompatible avec les formulaires.",
        "C'est obligatoire en Symfony 7."
      ],
      "correct_answers": [
        "Pour découpler la structure de la base de données de l'interface utilisateur (ex: mot de passe en clair vs hashé, champs combinés)."
      ],
      "explanation": "Cela permet de valider les données du formulaire indépendamment des contraintes de persistance."
    }
  ]
}