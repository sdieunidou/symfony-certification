{
  "source_file": "02-http/client-serveur.md",
  "title": "Interaction Client / Serveur & Cycle de Vie",
  "questions": [
    {
      "id": 1,
      "question": "Quelle architecture fondamentale définit le fonctionnement du Web HTTP ?",
      "type": "single_choice",
      "options": [
        "Peer-to-Peer",
        "Client-Serveur (Request-Response)",
        "Publish-Subscribe",
        "Master-Slave"
      ],
      "correct_answers": [
        "Client-Serveur (Request-Response)"
      ],
      "explanation": "Le client initie une requête, le serveur la traite et renvoie une réponse. Le protocole est sans état (Stateless)."
    },
    {
      "id": 2,
      "question": "Dans le modèle classique PHP-FPM, que se passe-t-il au niveau de la mémoire à la fin d'une requête ?",
      "type": "single_choice",
      "options": [
        "La mémoire est conservée pour la requête suivante.",
        "La mémoire est partagée entre les requêtes.",
        "Le processus meurt et la mémoire est libérée (Shared-Nothing architecture).",
        "Seules les variables statiques sont conservées."
      ],
      "correct_answers": [
        "Le processus meurt et la mémoire est libérée (Shared-Nothing architecture)."
      ],
      "explanation": "C'est ce qui rend PHP très robuste aux fuites de mémoire, contrairement aux serveurs d'application Java ou Node.js."
    },
    {
      "id": 3,
      "question": "Quel objet est retourné par la méthode `handle()` du `HttpKernel` ?",
      "type": "single_choice",
      "options": [
        "Un string (HTML).",
        "Un objet `Request`.",
        "Un objet `Response`.",
        "Un tableau de données."
      ],
      "correct_answers": [
        "Un objet `Response`."
      ],
      "explanation": "La mission fondamentale du Kernel est de transformer une `Request` en `Response`."
    },
    {
      "id": 4,
      "question": "Dans le cycle de vie Symfony, quel événement permet d'intercepter la requête très tôt (ex: pour gérer la sécurité ou la locale) avant même de déterminer le contrôleur ?",
      "type": "single_choice",
      "options": [
        "kernel.response",
        "kernel.controller",
        "kernel.request",
        "kernel.view"
      ],
      "correct_answers": [
        "kernel.request"
      ],
      "explanation": "C'est le premier événement déclenché par `HttpKernel::handle()`. S'il renvoie une réponse, le reste du cycle est court-circuité."
    },
    {
      "id": 5,
      "question": "À quel moment l'événement `kernel.view` est-il déclenché ?",
      "type": "single_choice",
      "options": [
        "Systématiquement après chaque contrôleur.",
        "Uniquement si le contrôleur ne retourne PAS un objet `Response` (ex: null, array, objet métier).",
        "Juste avant l'envoi de la réponse au client.",
        "En cas d'exception."
      ],
      "correct_answers": [
        "Uniquement si le contrôleur ne retourne PAS un objet `Response` (ex: null, array, objet métier)."
      ],
      "explanation": "Il sert à transformer la valeur de retour brute du contrôleur en `Response` (ex: sérialisation JSON automatique)."
    },
    {
      "id": 6,
      "question": "Pourquoi ne faut-il jamais utiliser `die()` ou `exit()` dans une application Symfony ?",
      "type": "single_choice",
      "options": [
        "Parce que c'est une fonction dépréciée en PHP 8.",
        "Parce que cela coupe brutalement l'exécution, empêchant l'envoi correct des headers et l'exécution des événements de terminaison (`kernel.terminate`).",
        "Parce que cela affiche une page blanche.",
        "C'est autorisé pour le débogage uniquement."
      ],
      "correct_answers": [
        "Parce que cela coupe brutalement l'exécution, empêchant l'envoi correct des headers et l'exécution des événements de terminaison (`kernel.terminate`)."
      ],
      "explanation": "Il faut toujours retourner une `Response` pour respecter le cycle de vie du framework."
    },
    {
      "id": 7,
      "question": "Quel pattern architectural utilise Symfony pour centraliser l'entrée de toutes les requêtes via `index.php` ?",
      "type": "single_choice",
      "options": [
        "MVC Pattern",
        "Front Controller Pattern",
        "Singleton Pattern",
        "Observer Pattern"
      ],
      "correct_answers": [
        "Front Controller Pattern"
      ],
      "explanation": "Le Front Controller centralise la gestion des requêtes, la configuration et la sécurité, évitant la duplication de code d'initialisation."
    },
    {
      "id": 8,
      "question": "Quelle est la particularité des 'Sous-requêtes' (Sub-requests) dans Symfony ?",
      "type": "single_choice",
      "options": [
        "Elles sont effectuées via une requête HTTP curl externe.",
        "Elles relancent un cycle Kernel complet en interne sans faire d'appel réseau.",
        "Elles ne déclenchent aucun événement.",
        "Elles sont interdites pour des raisons de performance."
      ],
      "correct_answers": [
        "Elles relancent un cycle Kernel complet en interne sans faire d'appel réseau."
      ],
      "explanation": "C'est utilisé par exemple pour le rendu de fragments de page (`{{ render(controller(...)) }}`). Elles sont identifiées par le type `HttpKernelInterface::SUB_REQUEST`."
    },
    {
      "id": 9,
      "question": "Quel est le but de l'événement `kernel.response` ?",
      "type": "single_choice",
      "options": [
        "Créer l'objet Response.",
        "Modifier l'objet Response juste avant qu'il soit envoyé au client (ex: ajout de headers, cookies).",
        "Envoyer la réponse au client.",
        "Gérer les exceptions."
      ],
      "correct_answers": [
        "Modifier l'objet Response juste avant qu'il soit envoyé au client (ex: ajout de headers, cookies)."
      ],
      "explanation": "C'est la dernière chance d'altérer la réponse. La WebDebugToolbar s'injecte ici."
    },
    {
      "id": 10,
      "question": "Quel est le risque majeur d'utiliser des services 'Stateful' (avec état) dans un environnement Worker (ex: FrankenPHP, RoadRunner) ?",
      "type": "single_choice",
      "options": [
        "Aucun risque.",
        "Les données d'un utilisateur précédent peuvent persister en mémoire et être exposées à l'utilisateur suivant (fuite de données).",
        "L'application sera plus lente.",
        "Cela provoque des erreurs 500 aléatoires."
      ],
      "correct_answers": [
        "Les données d'un utilisateur précédent peuvent persister en mémoire et être exposées à l'utilisateur suivant (fuite de données)."
      ],
      "explanation": "Comme l'application ne redémarre pas entre les requêtes, tout ce qui est stocké dans une propriété privée d'un service persiste. Les services doivent être strictement Stateless."
    }
  ]
}