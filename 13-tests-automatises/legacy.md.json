{
  "source_file": "13-tests-automatises/legacy.md",
  "title": "Gestion du Code Déprécié (Legacy Tests)",
  "questions": [
    {
      "id": 1,
      "question": "Quel composant Symfony détecte et rapporte les dépréciations lors de l'exécution des tests ?",
      "type": "single_choice",
      "options": [
        "Le composant Deprecation.",
        "Le PHPUnit Bridge.",
        "Le composant ErrorHandler.",
        "PHPUnit nativement."
      ],
      "correct_answers": [
        "Le PHPUnit Bridge."
      ],
      "explanation": "Il intercepte `trigger_deprecation()` et les erreurs `E_USER_DEPRECATED`."
    },
    {
      "id": 2,
      "question": "Comment configurer la tolérance aux dépréciations pour échouer si VOTRE code génère une dépréciation, mais ignorer celles des vendors ?",
      "type": "single_choice",
      "options": [
        "`SYMFONY_DEPRECATIONS_HELPER=disabled`",
        "`SYMFONY_DEPRECATIONS_HELPER=max[total]=0`",
        "`SYMFONY_DEPRECATIONS_HELPER=max[self]=0`",
        "`SYMFONY_DEPRECATIONS_HELPER=strict`"
      ],
      "correct_answers": [
        "`SYMFONY_DEPRECATIONS_HELPER=max[self]=0`"
      ],
      "explanation": "C'est la configuration recommandée pour maintenir un code propre tout en permettant d'utiliser des dépendances pas encore à jour."
    },
    {
      "id": 3,
      "question": "Quelle méthode permet de tester qu'un appel de fonction déclenche bien une dépréciation attendue ?",
      "type": "single_choice",
      "options": [
        "`$this->expectException(DeprecationException::class)`",
        "`$this->expectDeprecation('Message...')`",
        "`$this->assertDeprecated()`",
        "`$this->expectError()`"
      ],
      "correct_answers": [
        "`$this->expectDeprecation('Message...')`"
      ],
      "explanation": "Cette méthode est fournie par le trait `ExpectDeprecationTrait` du bridge."
    },
    {
      "id": 4,
      "question": "Quelle annotation permet de marquer un test entier comme 'Legacy' (les dépréciations y seront ignorées) ?",
      "type": "single_choice",
      "options": [
        "`@legacy`",
        "`@group legacy`",
        "`@deprecated`",
        "`@ignoreDeprecations`"
      ],
      "correct_answers": [
        "`@group legacy`"
      ],
      "explanation": "Le bridge PHPUnit traite les tests du groupe `legacy` différemment."
    },
    {
      "id": 5,
      "question": "Quel réglage SYMFONY_DEPRECATIONS_HELPER pour échouer sur vos dépréciations mais ignorer les vendors ?",
      "type": "single_choice",
      "options": [
        "`max[self]=0`",
        "`max[total]=0`",
        "`disabled`",
        "`weak_vendors`"
      ],
      "correct_answers": [
        "`max[self]=0`"
      ],
      "explanation": "max[self]=0 tolère 0 dépréciation provenant de votre code uniquement."
    },
    {
      "id": 6,
      "question": "Comment tester qu'une dépréciation précise est déclenchée ?",
      "type": "single_choice",
      "options": [
        "`$this->expectDeprecation('Message...');`",
        "`$this->expectException(Deprecation::class);`",
        "`$this->assertDeprecated();`",
        "`$this->expectError();`"
      ],
      "correct_answers": [
        "`$this->expectDeprecation('Message...');`"
      ],
      "explanation": "Fournie par ExpectDeprecationTrait du Bridge."
    },
    {
      "id": 7,
      "question": "Que fait le groupe `legacy` sur un test ?",
      "type": "single_choice",
      "options": [
        "Les dépréciations n'échouent pas ce test mais sont comptabilisées comme legacy",
        "Il ignore les assertions",
        "Il désactive PHPUnit",
        "Il exécute deux fois le test"
      ],
      "correct_answers": [
        "Les dépréciations n'échouent pas ce test mais sont comptabilisées comme legacy"
      ],
      "explanation": "Utile pour isoler du code en transition."
    },
    {
      "id": 8,
      "question": "Pourquoi viser un objectif 'Deprecation-Free' avant une montée de version Symfony ?",
      "type": "single_choice",
      "options": [
        "Les dépréciations d'une version deviennent des suppressions dans la suivante",
        "Pour accélérer Twig",
        "Pour réduire la taille du vendor",
        "Pour éviter Xdebug"
      ],
      "correct_answers": [
        "Les dépréciations d'une version deviennent des suppressions dans la suivante"
      ],
      "explanation": "Corriger les dépréciations facilite la migration majeure."
    },
    {
      "id": 9,
      "question": "Quelle variable d'env permet de voir le détail des dépréciations pendant les tests ?",
      "type": "single_choice",
      "options": [
        "`SYMFONY_DEPRECATIONS_HELPER=verbose`",
        "`APP_DEBUG=1`",
        "`DEBUG_DEPRECATIONS=1`",
        "`PHPUNIT_DEBUG=1`"
      ],
      "correct_answers": [
        "`SYMFONY_DEPRECATIONS_HELPER=verbose`"
      ],
      "explanation": "Le mode verbose affiche les messages complets."
    },
    {
      "id": 10,
      "question": "Comment isoler des tests legacy pour qu'ils ne polluent pas les métriques principales ?",
      "type": "single_choice",
      "options": [
        "En les marquant `@group legacy` et en configurant SYMFONY_DEPRECATIONS_HELPER pour autoriser ce groupe",
        "En les plaçant dans un autre dossier",
        "En désactivant PHPUnit",
        "En supprimant les assertions"
      ],
      "correct_answers": [
        "En les marquant `@group legacy` et en configurant SYMFONY_DEPRECATIONS_HELPER pour autoriser ce groupe"
      ],
      "explanation": "Le bridge distingue les dépréciations legacy de celles à corriger."
    }
  ]
}