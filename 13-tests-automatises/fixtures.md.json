{
  "source_file": "13-tests-automatises/fixtures.md",
  "title": "Fixtures & Base de Données",
  "questions": [
    {
      "id": 1,
      "question": "Pourquoi utiliser `DAMADoctrineTestBundle` dans les tests fonctionnels Symfony ?",
      "type": "single_choice",
      "options": [
        "Pour accélérer l'installation de Doctrine.",
        "Pour isoler chaque test en enveloppant son exécution dans une transaction base de données qui est annulée (rollback) à la fin.",
        "Pour créer des fixtures aléatoires.",
        "Pour tester Doctrine sans base de données."
      ],
      "correct_answers": [
        "Pour isoler chaque test en enveloppant son exécution dans une transaction base de données qui est annulée (rollback) à la fin."
      ],
      "explanation": "Cela garantit que l'état de la base de données est propre pour chaque test, évitant les effets de bord."
    },
    {
      "id": 2,
      "question": "Quelle commande permet de charger les fixtures dans la base de test ?",
      "type": "single_choice",
      "options": [
        "`php bin/console doctrine:fixtures:load`",
        "`php bin/console doctrine:fixtures:load --env=test`",
        "`php bin/console make:fixtures`",
        "`php bin/console test:fixtures`"
      ],
      "correct_answers": [
        "`php bin/console doctrine:fixtures:load --env=test`"
      ],
      "explanation": "Il est crucial de spécifier `--env=test` pour ne pas écraser la base de développement."
    },
    {
      "id": 3,
      "question": "Comment définir une base de données spécifique pour les tests ?",
      "type": "single_choice",
      "options": [
        "Dans le fichier `.env`.",
        "Dans le fichier `.env.test` ou `.env.test.local` en surchargeant `DATABASE_URL`.",
        "Dans le contrôleur.",
        "C'est automatique."
      ],
      "correct_answers": [
        "Dans le fichier `.env.test` ou `.env.test.local` en surchargeant `DATABASE_URL`."
      ],
      "explanation": "Les tests chargent automatiquement l'environnement `test` qui lit `.env.test`."
    },
    {
      "id": 4,
      "question": "Quelle classe abstraite faut-il étendre pour créer une fixture Doctrine ?",
      "type": "single_choice",
      "options": [
        "`DoctrineFixture`",
        "`Fixture` (du namespace `Doctrine\\Bundle\\FixturesBundle\\Fixture`)",
        "`BaseFixture`",
        "`DataFixture`"
      ],
      "correct_answers": [
        "`Fixture` (du namespace `Doctrine\\Bundle\\FixturesBundle\\Fixture`)"
      ],
      "explanation": "Cette classe impose d'implémenter la méthode `load(ObjectManager $manager)`."
    },
    {
      "id": 5,
      "question": "Si une fixture doit être chargée après une autre (dépendance), quelle interface doit-elle implémenter ?",
      "type": "single_choice",
      "options": [
        "`OrderedFixtureInterface`",
        "`DependentFixtureInterface`",
        "`SequenceFixtureInterface`",
        "`ChainedFixtureInterface`"
      ],
      "correct_answers": [
        "`DependentFixtureInterface`"
      ],
      "explanation": "Cette interface impose la méthode `getDependencies()` qui retourne la liste des classes de fixtures requises au préalable."
    },
    {
      "id": 6,
      "question": "Pourquoi exécuter `doctrine:fixtures:load --env=test` est-il plus sûr ?",
      "type": "single_choice",
      "options": [
        "Évite d'écraser la base de dev/prod en chargeant les fixtures uniquement dans la base de test",
        "C'est plus rapide",
        "Cela nettoie les logs",
        "Obligatoire pour Symfony 7"
      ],
      "correct_answers": [
        "Évite d'écraser la base de dev/prod en chargeant les fixtures uniquement dans la base de test"
      ],
      "explanation": "On cible l'URL de BDD de test définie dans `.env.test`."
    },
    {
      "id": 7,
      "question": "Quel est l'effet de DAMADoctrineTestBundle sur l'EntityManager pendant les tests ?",
      "type": "single_choice",
      "options": [
        "Chaque test s'exécute dans une transaction rollbackée, détachant les entités à la fin",
        "Il supprime les entités",
        "Il désactive Doctrine",
        "Aucun impact"
      ],
      "correct_answers": [
        "Chaque test s'exécute dans une transaction rollbackée, détachant les entités à la fin"
      ],
      "explanation": "Isolation + rapidité, mais attention aux entités détachées."
    },
    {
      "id": 8,
      "question": "Comment partager une entité créée dans une fixture avec d'autres fixtures ?",
      "type": "single_choice",
      "options": [
        "Utiliser `addReference('admin', $user)` puis `getReference('admin')`",
        "Mettre en variable globale",
        "Stocker en session",
        "Impossible"
      ],
      "correct_answers": [
        "Utiliser `addReference('admin', $user)` puis `getReference('admin')`"
      ],
      "explanation": "Les références permettent de réutiliser des entités entre fixtures."
    },
    {
      "id": 9,
      "question": "Pourquoi préférer les transactions rollback (DAMA) au drop/create schema entre tests ?",
      "type": "single_choice",
      "options": [
        "Beaucoup plus rapide qu'un drop/create à chaque test",
        "Obligatoire en CI",
        "Cela supprime les migrations",
        "Parce que sqlite l'impose"
      ],
      "correct_answers": [
        "Beaucoup plus rapide qu'un drop/create à chaque test"
      ],
      "explanation": "Le rollback transactionnel garde l'état propre avec un coût minime."
    },
    {
      "id": 10,
      "question": "Où définir `DATABASE_URL` pour les tests ?",
      "type": "single_choice",
      "options": [
        "Dans `.env.test` ou `.env.test.local`",
        "Dans `.env.local`",
        "Dans le contrôleur",
        "Dans php.ini"
      ],
      "correct_answers": [
        "Dans `.env.test` ou `.env.test.local`"
      ],
      "explanation": "L'environnement test surcharge DATABASE_URL pour isoler la base."
    }
  ]
}