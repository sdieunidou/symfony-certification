{
  "source_file": "13-tests-automatises/introspection.md",
  "title": "Introspection Request et Response",
  "questions": [
    {
      "id": 1,
      "question": "Comment accéder à l'objet `Response` de la dernière requête effectuée par le client ?",
      "type": "single_choice",
      "options": [
        "`$client->getLastResponse()`",
        "`$client->getResponse()`",
        "`$client->response()`",
        "`$crawler->getResponse()`"
      ],
      "correct_answers": [
        "`$client->getResponse()`"
      ],
      "explanation": "Cela retourne une instance de `Symfony\\Component\\HttpFoundation\\Response`."
    },
    {
      "id": 2,
      "question": "Si le client suit les redirections (`followRedirects(true)`), que contient `$client->getResponse()` après une requête qui a redirigé ?",
      "type": "single_choice",
      "options": [
        "La réponse de la première page (302 Redirect).",
        "La réponse de la page finale (200 OK).",
        "Un tableau de toutes les réponses.",
        "Null."
      ],
      "correct_answers": [
        "La réponse de la page finale (200 OK)."
      ],
      "explanation": "Pour tester la redirection elle-même (vérifier le header Location), il faut désactiver le suivi automatique (`followRedirects(false)`)."
    },
    {
      "id": 3,
      "question": "Comment vérifier le contenu JSON d'une réponse API ?",
      "type": "single_choice",
      "options": [
        "En utilisant `$response->getContent()` et `json_decode()`.",
        "En utilisant le Crawler.",
        "En utilisant `$response->getJson()`.",
        "En utilisant `$client->json()`."
      ],
      "correct_answers": [
        "En utilisant `$response->getContent()` et `json_decode()`."
      ],
      "explanation": "Le Crawler est fait pour le HTML/XML. Pour le JSON, on inspecte la chaîne brute retournée par `getContent()`."
    },
    {
      "id": 4,
      "question": "Comment vérifier que la réponse contient un header spécifique ?",
      "type": "single_choice",
      "options": [
        "`$this->assertTrue($client->getResponse()->headers->has('Content-Type'))`",
        "`$this->assertHeader('Content-Type')`",
        "`$client->hasHeader('Content-Type')`",
        "`$crawler->header('Content-Type')`"
      ],
      "correct_answers": [
        "`$this->assertTrue($client->getResponse()->headers->has('Content-Type'))`"
      ],
      "explanation": "On accède au sac de headers via la propriété publique `headers` de l'objet Response."
    },
    {
      "id": 5,
      "question": "Quelle est la différence entre `$client->getResponse()` et `$client->getInternalResponse()` ?",
      "type": "single_choice",
      "options": [
        "Aucune.",
        "`getResponse()` retourne la réponse HTTP Symfony (HttpFoundation), tandis que `getInternalResponse()` retourne l'objet BrowserKit utilisé par le moteur de test.",
        "`getInternalResponse()` est déprécié.",
        "`getResponse()` est pour la production."
      ],
      "correct_answers": [
        "`getResponse()` retourne la réponse HTTP Symfony (HttpFoundation), tandis que `getInternalResponse()` retourne l'objet BrowserKit utilisé par le moteur de test."
      ],
      "explanation": "Dans la plupart des cas, on utilise `getResponse()` pour faire des assertions sur le code statut, les headers, etc."
    },
    {
      "id": 6,
      "question": "Comment obtenir l'objet Request de la dernière requête ?",
      "type": "single_choice",
      "options": [
        "`$client->getRequest()`",
        "`$client->getInternalRequest()`",
        "`$client->request()`",
        "`$crawler->getRequest()`"
      ],
      "correct_answers": [
        "`$client->getRequest()`"
      ],
      "explanation": "getRequest retourne l'objet Request BrowserKit de la dernière requête."
    },
    {
      "id": 7,
      "question": "Comment vérifier une redirection sans la suivre ?",
      "type": "single_choice",
      "options": [
        "Ne pas activer followRedirects et inspecter `getResponse()->headers->get('Location')`",
        "Toujours suivre la redirection",
        "Utiliser le Crawler",
        "Impossible"
      ],
      "correct_answers": [
        "Ne pas activer followRedirects et inspecter `getResponse()->headers->get('Location')`"
      ],
      "explanation": "Le suivi auto écrase la réponse initiale; on le désactive pour vérifier le 3xx."
    },
    {
      "id": 8,
      "question": "Comment vérifier facilement le JSON retourné contient une clé ?",
      "type": "single_choice",
      "options": [
        "Décoder le contenu : `$data = json_decode($response->getContent(), true); $this->assertArrayHasKey('key', $data);`",
        "Utiliser le Crawler",
        "Regarder les logs",
        "Impossible"
      ],
      "correct_answers": [
        "Décoder le contenu : `$data = json_decode($response->getContent(), true); $this->assertArrayHasKey('key', $data);`"
      ],
      "explanation": "Le Crawler n'est pas adapté au JSON."
    },
    {
      "id": 9,
      "question": "Comment vérifier un header précis (ex: Cache-Control) ?",
      "type": "single_choice",
      "options": [
        "`$this->assertSame('no-cache', $client->getResponse()->headers->get('Cache-Control'));`",
        "`$client->hasHeader('Cache-Control')`",
        "`$crawler->header('Cache-Control')`",
        "Impossible"
      ],
      "correct_answers": [
        "`$this->assertSame('no-cache', $client->getResponse()->headers->get('Cache-Control'));`"
      ],
      "explanation": "Les headers sont accessibles via l'objet Response."
    },
    {
      "id": 10,
      "question": "Que retourne `$client->getResponse()` après followRedirects(true) sur une 302 ?",
      "type": "single_choice",
      "options": [
        "La réponse finale (ex: 200) après redirection",
        "La 302 uniquement",
        "Un tableau de réponses",
        "Null"
      ],
      "correct_answers": [
        "La réponse finale (ex: 200) après redirection"
      ],
      "explanation": "Le client a suivi la redirection, la réponse accessible est celle de destination."
    }
  ]
}