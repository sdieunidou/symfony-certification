{
  "source_file": "13-tests-automatises/phpunit-basics.md",
  "title": "PHPUnit - Fondamentaux",
  "questions": [
    {
      "id": 5,
      "question": "Quelle méthode remplace `@expectedException` (annotation) pour vérifier qu'une exception est levée ?",
      "type": "single_choice",
      "options": [
        "`$this->expectException(SomeException::class);`",
        "`$this->shouldThrow(SomeException::class);`",
        "`@throws`",
        "`$this->expectError();`"
      ],
      "correct_answers": [
        "`$this->expectException(SomeException::class);`"
      ],
      "explanation": "Les annotations @expectedException sont dépréciées ; on utilise les méthodes d'attente avant l'appel testé."
    },
    {
      "id": 6,
      "question": "À quoi sert `@doesNotPerformAssertions` (ou l'attribut équivalent) ?",
      "type": "single_choice",
      "options": [
        "Indiquer qu'un test sans assertion n'est pas en échec",
        "Ignorer le test",
        "Compter les assertions automatiquement",
        "Exécuter deux fois le test"
      ],
      "correct_answers": [
        "Indiquer qu'un test sans assertion n'est pas en échec"
      ],
      "explanation": "Utile pour vérifier simplement l'absence d'exception ou un contrat implicite."
    },
    {
      "id": 7,
      "question": "Quelle option CLI PHPUnit génère un rapport de couverture HTML ?",
      "type": "single_choice",
      "options": [
        "`--coverage-html coverage/`",
        "`--coverage`",
        "`--html-report`",
        "`--coverage-json`"
      ],
      "correct_answers": [
        "`--coverage-html coverage/`"
      ],
      "explanation": "La couverture nécessite Xdebug/PCOV et un dossier cible."
    },
    {
      "id": 8,
      "question": "Comment marquer un test comme 'incomplet' pendant son exécution ?",
      "type": "single_choice",
      "options": [
        "`$this->markTestIncomplete('TODO');`",
        "`@incomplete`",
        "`$this->skip()`",
        "`throw new IncompleteTest`"
      ],
      "correct_answers": [
        "`$this->markTestIncomplete('TODO');`"
      ],
      "explanation": "markTestIncomplete signale un test non fini sans l'échouer."
    },
    {
      "id": 9,
      "question": "Quel attribut remplace l'annotation `@test` pour marquer une méthode comme test ?",
      "type": "single_choice",
      "options": [
        "`#[Test]`",
        "`#[PhpUnitTest]`",
        "`#[IsTest]`",
        "`#[Run]`"
      ],
      "correct_answers": [
        "`#[Test]`"
      ],
      "explanation": "Depuis PHPUnit 10, on peut utiliser l'attribut #[Test] au lieu du préfixe test ou de l'annotation."
    },
    {
      "id": 10,
      "question": "Quelle différence entre `setUp()` et `setUpBeforeClass()` ?",
      "type": "single_choice",
      "options": [
        "setUpBeforeClass est static et exécutée une fois par classe; setUp est exécutée avant chaque test",
        "Aucune",
        "setUpBeforeClass est exécutée après chaque test",
        "setUpBeforeClass nettoie la base"
      ],
      "correct_answers": [
        "setUpBeforeClass est static et exécutée une fois par classe; setUp est exécutée avant chaque test"
      ],
      "explanation": "setUpBeforeClass sert aux initialisations coûteuses partagées."
    },
    {
      "id": 1,
      "question": "Quelle est la différence principale entre `createMock()` et `createStub()` (disponible depuis PHPUnit 10) ?",
      "type": "single_choice",
      "options": [
        "Aucune, ce sont des alias.",
        "`createStub` sert à configurer des valeurs de retour, tandis que `createMock` permet en plus de vérifier des attentes (expects).",
        "`createStub` crée une fausse base de données.",
        "`createMock` est déprécié."
      ],
      "correct_answers": [
        "`createStub` sert à configurer des valeurs de retour, tandis que `createMock` permet en plus de vérifier des attentes (expects)."
      ],
      "explanation": "Conceptuellement, un Stub fournit des données (input indirect), un Mock vérifie des interactions (output indirect). Dans PHPUnit, `createMock` fait les deux, mais `createStub` est plus léger si on ne fait que du stubbing."
    },
    {
      "id": 2,
      "question": "Comment définir un Data Provider pour une méthode de test ?",
      "type": "single_choice",
      "options": [
        "En créant une méthode publique statique qui retourne un itérable et en utilisant l'attribut `#[DataProvider]`. ",
        "En passant un tableau directement dans l'attribut `#[Test]`. ",
        "En implémentant l'interface `DataProviderInterface`.",
        "En utilisant `yield` directement dans la méthode de test."
      ],
      "correct_answers": [
        "En créant une méthode publique statique qui retourne un itérable et en utilisant l'attribut `#[DataProvider]`. "
      ],
      "explanation": "La méthode doit être `static` (exigence récente de PHPUnit pour éviter l'instanciation de la classe de test lors de la collecte des données)."
    },
    {
      "id": 3,
      "question": "Quelle assertion utiliser pour vérifier que deux variables sont strictement identiques (valeur et type) ?",
      "type": "single_choice",
      "options": [
        "`assertEquals()`",
        "`assertSame()`",
        "`assertStrict()`",
        "`assertIdentical()`"
      ],
      "correct_answers": [
        "`assertSame()`"
      ],
      "explanation": "`assertSame` utilise l'opérateur `===`, alors que `assertEquals` utilise `==`."
    },
    {
      "id": 4,
      "question": "Quand la méthode `setUp()` est-elle exécutée ?",
      "type": "single_choice",
      "options": [
        "Avant la classe de test.",
        "Avant chaque méthode de test.",
        "Après chaque méthode de test.",
        "Une seule fois au début."
      ],
      "correct_answers": [
        "Avant chaque méthode de test."
      ],
      "explanation": "C'est l'endroit idéal pour initialiser l'état commun à chaque test. Pour une initialisation unique par classe, utilisez `setUpBeforeClass()`."
    }
  ]
}