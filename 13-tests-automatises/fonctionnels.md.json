{
  "source_file": "13-tests-automatises/fonctionnels.md",
  "title": "Tests Fonctionnels (WebTestCase)",
  "questions": [
    {
      "id": 6,
      "question": "Comment suivre automatiquement toutes les redirections dans un test fonctionnel ?",
      "type": "single_choice",
      "options": [
        "`$client->followRedirects(true)`",
        "`$client->enableRedirects()`",
        "`$client->followRedirect()`",
        "`$client->autoRedirect()`"
      ],
      "correct_answers": [
        "`$client->followRedirects(true)`"
      ],
      "explanation": "Cela rend le client BrowserKit en mode suivi automatique."
    },
    {
      "id": 7,
      "question": "Comment activer le profiler pour une requête afin de vérifier les emails ou requêtes SQL ?",
      "type": "single_choice",
      "options": [
        "`$client->enableProfiler();` avant `request()`",
        "`$client->startProfiler();`",
        "`$client->useToolbar();`",
        "Impossible"
      ],
      "correct_answers": [
        "`$client->enableProfiler();` avant `request()`"
      ],
      "explanation": "Permet ensuite d'accéder à `$client->getProfile()`."
    },
    {
      "id": 8,
      "question": "Comment tester un formulaire en remplissant et soumettant via le Crawler ?",
      "type": "single_choice",
      "options": [
        "Sélectionner le bouton submit -> `$form = $crawler->selectButton('Valider')->form([...])` puis `$client->submit($form)`",
        "`$client->postForm()`",
        "`$crawler->submit()` sans form",
        "Impossible"
      ],
      "correct_answers": [
        "Sélectionner le bouton submit -> `$form = $crawler->selectButton('Valider')->form([...])` puis `$client->submit($form)`"
      ],
      "explanation": "BrowserKit/Twig interagissent via le Crawler et l'objet Form associé au bouton."
    },
    {
      "id": 9,
      "question": "Quelle assertion Symfony permet de vérifier un redirect vers une route donnée ?",
      "type": "single_choice",
      "options": [
        "`$this->assertResponseRedirects('/login')`",
        "`$this->assertRedirect('/login')`",
        "`$this->assertHeader('Location')`",
        "`$this->assertRedirectedToRoute('app_login')` seulement"
      ],
      "correct_answers": [
        "`$this->assertResponseRedirects('/login')`"
      ],
      "explanation": "assertResponseRedirects vérifie code 3xx et header Location attendu."
    },
    {
      "id": 10,
      "question": "Comment vérifier l'absence d'erreur Twig/HTTP dans la réponse ?",
      "type": "single_choice",
      "options": [
        "`$this->assertResponseIsSuccessful()`",
        "`$this->assertStatusOk()`",
        "`$this->assertNoError()`",
        "`$crawler->isValid()`"
      ],
      "correct_answers": [
        "`$this->assertResponseIsSuccessful()`"
      ],
      "explanation": "Assure un statut 2xx/3xx dans le test fonctionnel."
    },
    {
      "id": 1,
      "question": "Quelle classe de base doit-on étendre pour écrire des tests fonctionnels (qui simulent un navigateur) ?",
      "type": "single_choice",
      "options": [
        "`TestCase`",
        "`KernelTestCase`",
        "`WebTestCase`",
        "`BrowserTestCase`"
      ],
      "correct_answers": [
        "`WebTestCase`"
      ],
      "explanation": "`WebTestCase` étend `KernelTestCase` et ajoute les méthodes pour créer un Client (`createClient`)."
    },
    {
      "id": 2,
      "question": "Quelle méthode permet de faire une assertion sur le code de statut de la réponse HTTP ?",
      "type": "single_choice",
      "options": [
        "`$this->assertEquals(200, $response->getStatusCode())`",
        "`$this->assertResponseIsSuccessful()` (pour 2xx) ou `$this->assertResponseStatusCodeSame(404)`.",
        "`$client->assertStatus(200)`",
        "`$this->checkResponse(200)`"
      ],
      "correct_answers": [
        "`$this->assertResponseIsSuccessful()` (pour 2xx) ou `$this->assertResponseStatusCodeSame(404)`."
      ],
      "explanation": "Symfony fournit des assertions spécifiques (`assertResponse...`) qui sont plus lisibles et fournissent de meilleurs messages d'erreur."
    },
    {
      "id": 3,
      "question": "Comment vérifier qu'un élément HTML contient un texte spécifique ?",
      "type": "single_choice",
      "options": [
        "`$this->assertContains('text', $crawler->html())`",
        "`$this->assertSelectorTextContains('selecteur_css', 'texte attendu')`",
        "`$this->assertElementContains('selecteur', 'texte')`",
        "`$this->seeInElement('selecteur', 'texte')`"
      ],
      "correct_answers": [
        "`$this->assertSelectorTextContains('selecteur_css', 'texte attendu')`"
      ],
      "explanation": "Cette assertion utilise le Crawler en interne pour cibler l'élément et vérifier son contenu textuel."
    },
    {
      "id": 4,
      "question": "Quelle méthode permet d'envoyer une requête HTTP avec le client ?",
      "type": "single_choice",
      "options": [
        "`$client->get('/url')`",
        "`$client->request('GET', '/url')`",
        "`$client->send('GET', '/url')`",
        "`$client->call('GET', '/url')`"
      ],
      "correct_answers": [
        "`$client->request('GET', '/url')`"
      ],
      "explanation": "Elle retourne un objet `Crawler`."
    },
    {
      "id": 5,
      "question": "Quelle assertion permet de vérifier le nombre d'emails envoyés lors du test (profiling) ?",
      "type": "single_choice",
      "options": [
        "`$this->assertEmailCount(int $count)`",
        "`$this->assertMailSent(int $count)`",
        "`$client->assertEmails(int $count)`",
        "`$this->checkEmails(int $count)`"
      ],
      "correct_answers": [
        "`$this->assertEmailCount(int $count)`"
      ],
      "explanation": "Cette assertion interroge le collecteur du profiler Symfony pour compter les emails envoyés par le composant Mailer."
    }
  ]
}