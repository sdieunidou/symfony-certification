{
  "source_file": "17-doctrine/mapping.md",
  "title": "Mapping ORM (Attributs)",
  "questions": [
    {
      "id": 1,
      "question": "Quelle syntaxe est recommandée pour le mapping Doctrine en Symfony 7 ?",
      "type": "single_choice",
      "options": [
        "Attributs PHP (`#[ORM\\...]`)",
        "Annotations PHPDoc",
        "XML",
        "YAML"
      ],
      "correct_answers": [
        "Attributs PHP (`#[ORM\\...]`)"
      ],
      "explanation": "Les attributs sont natifs, modernes et préférés aux formats legacy."
    },
    {
      "id": 2,
      "question": "Si vous définissez une propriété `#[ORM\\Column] private string $name;`, la colonne en base sera-t-elle nullable ?",
      "type": "single_choice",
      "options": [
        "Oui, par défaut tout est nullable.",
        "Non, par défaut `nullable` est à `false`.",
        "Cela dépend de la base de données.",
        "Oui, si le type PHP est `?string`."
      ],
      "correct_answers": [
        "Non, par défaut `nullable` est à `false`."
      ],
      "explanation": "Pour autoriser NULL, il faut explicitement ajouter l'argument `nullable: true` dans l'attribut Column."
    },
    {
      "id": 3,
      "question": "Quel type Doctrine utiliser pour stocker un tableau PHP associatif sous forme de JSON en base ?",
      "type": "single_choice",
      "options": [
        "`array`",
        "`object`",
        "`json`",
        "`blob`"
      ],
      "correct_answers": [
        "`json`"
      ],
      "explanation": "Le type `json` gère automatiquement la sérialisation (`json_encode`) à l'écriture et la désérialisation (`json_decode`) à la lecture."
    },
    {
      "id": 4,
      "question": "Comment mapper une Enum PHP 8.1 sur une colonne de base de données ?",
      "type": "single_choice",
      "options": [
        "Ce n'est pas supporté.",
        "En utilisant l'option `enumType: MaClasseEnum::class` dans l'attribut `#[ORM\\Column]`.",
        "En créant un Type DBAL personnalisé obligatoirement.",
        "En convertissant l'enum en string dans les getters/setters."
      ],
      "correct_answers": [
        "En utilisant l'option `enumType: MaClasseEnum::class` dans l'attribut `#[ORM\\Column]`."
      ],
      "explanation": "Doctrine supporte nativement les Backed Enums via cette option simple."
    },
    {
      "id": 5,
      "question": "Quel type est recommandé pour représenter une date/heure en lecture seule ?",
      "type": "single_choice",
      "options": [
        "`datetime_immutable`",
        "`datetime`",
        "`timestamp`",
        "`time`"
      ],
      "correct_answers": [
        "`datetime_immutable`"
      ],
      "explanation": "datetime_immutable évite les mutations silencieuses d'objet DateTime."
    },
    {
      "id": 6,
      "question": "Pourquoi préférer `decimal` à `float` pour stocker de l'argent ?",
      "type": "single_choice",
      "options": [
        "decimal évite les erreurs d'arrondi binaires",
        "float est plus lent",
        "decimal chiffre les données",
        "float est interdit en SQL"
      ],
      "correct_answers": [
        "decimal évite les erreurs d'arrondi binaires"
      ],
      "explanation": "decimal/NUMERIC garde une précision exacte, adaptée aux montants."
    },
    {
      "id": 7,
      "question": "Que fait `#[ORM\\GeneratedValue(strategy: 'CUSTOM')]` avec `#[ORM\\CustomIdGenerator]` ?",
      "type": "single_choice",
      "options": [
        "Utilise un générateur d'ID personnalisé (ex: UUID/ULID)",
        "Force l'auto-increment",
        "Supprime la clé primaire",
        "Désactive le flush"
      ],
      "correct_answers": [
        "Utilise un générateur d'ID personnalisé (ex: UUID/ULID)"
      ],
      "explanation": "strategy CUSTOM + CustomIdGenerator permettent de plugger un générateur d'ID."
    },
    {
      "id": 8,
      "question": "À quoi sert `#[ORM\\HasLifecycleCallbacks]` ?",
      "type": "single_choice",
      "options": [
        "Autoriser les callbacks `PrePersist/PreUpdate/...` annotés dans l'entité",
        "Activer le cache",
        "Gérer les migrations",
        "Forcer le lazy loading"
      ],
      "correct_answers": [
        "Autoriser les callbacks `PrePersist/PreUpdate/...` annotés dans l'entité"
      ],
      "explanation": "HasLifecycleCallbacks enregistre la classe pour les événements du cycle de vie Doctrine."
    },
    {
      "id": 9,
      "question": "Pourquoi faut-il préciser `length` sur un `#[ORM\\Column(type: 'string')]` ?",
      "type": "single_choice",
      "options": [
        "Sans length, Doctrine ne peut pas générer le schéma VARCHAR correctement",
        "Sinon c'est toujours NVARCHAR",
        "Pour activer le cache",
        "Pour l'autowiring"
      ],
      "correct_answers": [
        "Sans length, Doctrine ne peut pas générer le schéma VARCHAR correctement"
      ],
      "explanation": "Le type string requiert une longueur pour générer la colonne SQL."
    },
    {
      "id": 10,
      "question": "Quel argument de `#[ORM\\Entity]` permet de lier un repository dédié ?",
      "type": "single_choice",
      "options": [
        "`repositoryClass`",
        "`table`",
        "`indexes`",
        "`listener`"
      ],
      "correct_answers": [
        "`repositoryClass`"
      ],
      "explanation": "repositoryClass pointe vers la classe de Repository à utiliser pour cette entité."
    }
  ]
}
