{
  "source_file": "19-composants/options-resolver.md",
  "title": "Composant OptionsResolver",
  "questions": [
    {
      "id": 1,
      "question": "Quelles exceptions peuvent être levées par `resolve()` ?",
      "type": "multiple_choice",
      "options": [
        "`UndefinedOptionsException` pour une option inconnue",
        "`MissingOptionsException` pour une option requise absente",
        "`InvalidOptionsException` pour type/valeur incorrects",
        "`LogicException` pour boucle circulaire"
      ],
      "correct_answers": [
        "`UndefinedOptionsException` pour une option inconnue",
        "`MissingOptionsException` pour une option requise absente",
        "`InvalidOptionsException` pour type/valeur incorrects"
      ],
      "explanation": "resolve() valide existence, obligation et type/valeur."
    },
    {
      "id": 2,
      "question": "Différence entre `setDefined`, `setDefaults` et `setRequired` ?",
      "type": "multiple_choice",
      "options": [
        "`setDefined` : déclare sans valeur par défaut ni obligation",
        "`setDefaults` : fixe une valeur par défaut (option facultative)",
        "`setRequired` : impose la présence d'une valeur fournie",
        "`setDefined` rend l'option obligatoire"
      ],
      "correct_answers": [
        "`setDefined` : déclare sans valeur par défaut ni obligation",
        "`setDefaults` : fixe une valeur par défaut (option facultative)",
        "`setRequired` : impose la présence d'une valeur fournie"
      ],
      "explanation": "Defined = connue ; Defaults = connue + valeur ; Required = doit être fournie."
    },
    {
      "id": 3,
      "question": "Comment restreindre types et valeurs autorisés ?",
      "type": "multiple_choice",
      "options": [
        "`setAllowedTypes('port', ['int','null'])`",
        "`setAllowedValues('encryption', [null,'ssl','tls'])`",
        "`setAllowedValues('age', fn($v)=>$v>=18)`",
        "`setTypes('port')`"
      ],
      "correct_answers": [
        "`setAllowedTypes('port', ['int','null'])`",
        "`setAllowedValues('encryption', [null,'ssl','tls'])`",
        "`setAllowedValues('age', fn($v)=>$v>=18)`"
      ],
      "explanation": "Types et valeurs se configurent séparément via allowedTypes/allowedValues."
    },
    {
      "id": 4,
      "question": "Dans quel ordre se fait la résolution d'une option ?",
      "type": "single_choice",
      "options": [
        "Validation type/valeur puis normalisation",
        "Normalisation puis validation",
        "Fusion puis cache",
        "Cache puis validation"
      ],
      "correct_answers": [
        "Validation type/valeur puis normalisation"
      ],
      "explanation": "Le normalizer agit après que la valeur est jugée valide."
    },
    {
      "id": 5,
      "question": "Comment définir une valeur par défaut dépendante d'une autre option ?",
      "type": "single_choice",
      "options": [
        "Avec `setDefault('port', fn(Options $o) => $o['encryption']==='ssl'?465:25)`",
        "Avec `setLinkedDefault()`",
        "Impossible",
        "Avec `setNormalizer()` uniquement"
      ],
      "correct_answers": [
        "Avec `setDefault('port', fn(Options $o) => $o['encryption']==='ssl'?465:25)`"
      ],
      "explanation": "Les closures de setDefault reçoivent Options pour créer des dépendances."
    },
    {
      "id": 6,
      "question": "À quoi sert `setNormalizer()` versus `setAllowedValues()` ?",
      "type": "single_choice",
      "options": [
        "Normalizer transforme la valeur finale après validation, AllowedValues valide la valeur",
        "Ils font la même chose",
        "AllowedValues transforme, Normalizer valide",
        "Normalizer définit une valeur par défaut"
      ],
      "correct_answers": [
        "Normalizer transforme la valeur finale après validation, AllowedValues valide la valeur"
      ],
      "explanation": "AllowedValues vérifie, Normalizer modifie."
    },
    {
      "id": 7,
      "question": "Comment valider des options imbriquées ?",
      "type": "single_choice",
      "options": [
        "Définir un `setDefault('database', function(OptionsResolver $r){ ... })` pour configurer un sous-resolver",
        "Impossible",
        "En ajoutant un `ArrayValidator`",
        "Avec `setNested()`"
      ],
      "correct_answers": [
        "Définir un `setDefault('database', function(OptionsResolver $r){ ... })` pour configurer un sous-resolver"
      ],
      "explanation": "On peut imbriquer des resolvers via un callback dans setDefault."
    },
    {
      "id": 8,
      "question": "Que fait la syntaxe fluide `define('port')->required()->default(25)->allowedTypes('int')` ?",
      "type": "single_choice",
      "options": [
        "Définit une option requise, avec défaut 25 si fournie vide, de type int",
        "Crée une option facultative sans défaut",
        "Ignore la validation de type",
        "Transforme la valeur en string"
      ],
      "correct_answers": [
        "Définit une option requise, avec défaut 25 si fournie vide, de type int"
      ],
      "explanation": "La DSL fluide enchaîne required/default/allowedTypes/info."
    },
    {
      "id": 9,
      "question": "Quel avantage du composant sur `array_replace` ?",
      "type": "multiple_choice",
      "options": [
        "Validation stricte des options et types",
        "Exceptions explicites en cas d'option inconnue",
        "Normalisation des valeurs",
        "Fusionne silencieusement les clés inconnues"
      ],
      "correct_answers": [
        "Validation stricte des options et types",
        "Exceptions explicites en cas d'option inconnue",
        "Normalisation des valeurs"
      ],
      "explanation": "OptionsResolver évite les typos et permet validation/normalisation."
    },
    {
      "id": 10,
      "question": "Quel pattern d'usage est recommandé pour des traitements massifs (boucles) ?",
      "type": "single_choice",
      "options": [
        "Réutiliser ou cloner un resolver préconfiguré plutôt que recréer les règles à chaque itération",
        "Recréer le resolver à chaque fois",
        "Désactiver la validation",
        "Utiliser array_merge"
      ],
      "correct_answers": [
        "Réutiliser ou cloner un resolver préconfiguré plutôt que recréer les règles à chaque itération"
      ],
      "explanation": "Éviter de reconstruire les règles à chaque boucle pour les perfs."
    },
    {
      "id": 11,
      "question": "Quelle méthode détecte une option inconnue mais définie comme `setDefined` ?",
      "type": "single_choice",
      "options": [
        "Aucune, `setDefined` rend l'option connue donc pas d'UndefinedOptionsException",
        "`resolveDefined()`",
        "`setAllowedValues()`",
        "`setMandatory()`"
      ],
      "correct_answers": [
        "Aucune, `setDefined` rend l'option connue donc pas d'UndefinedOptionsException"
      ],
      "explanation": "setDefined enregistre l'option même sans défaut, elle devient autorisée."
    },
    {
      "id": 12,
      "question": "Comment interdire toute option non déclarée ?",
      "type": "single_choice",
      "options": [
        "C'est le comportement par défaut de `resolve()`",
        "Appeler `forbidUnknownOptions()`",
        "Passer `strict=true` à resolve",
        "Ajouter `setAllowedOptions([])`"
      ],
      "correct_answers": [
        "C'est le comportement par défaut de `resolve()`"
      ],
      "explanation": "Toute option non définie lève UndefinedOptionsException sans config supplémentaire."
    }
  ]
}