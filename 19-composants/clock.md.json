{
  "source_file": "19-composants/clock.md",
  "title": "Composant Clock (Horloge)",
  "questions": [
    {
      "id": 1,
      "question": "Pourquoi injecter `ClockInterface` plutôt que `new DateTime()` ?",
      "type": "multiple_choice",
      "options": [
        "Testabilité (MockClock pour figer/avancer le temps)",
        "Respect PSR-20",
        "Centraliser fuseau/horloge",
        "Formatage automatique des dates"
      ],
      "correct_answers": [
        "Testabilité (MockClock pour figer/avancer le temps)",
        "Respect PSR-20",
        "Centraliser fuseau/horloge"
      ],
      "explanation": "Clock rend le temps injectable/mockable ; PSR-20 standardise."
    },
    {
      "id": 2,
      "question": "Quelle implémentation utiliser en prod ?",
      "type": "single_choice",
      "options": [
        "NativeClock",
        "MockClock",
        "SystemClock",
        "FakeClock"
      ],
      "correct_answers": [
        "NativeClock"
      ],
      "explanation": "NativeClock lit l'horloge système."
    },
    {
      "id": 3,
      "question": "Comment avancer le temps d'1h01 en test ?",
      "type": "single_choice",
      "options": [
        "`$clock->sleep(3660);` sur une MockClock",
        "`sleep(3660)` PHP",
        "`DateTime::add()`",
        "Impossible"
      ],
      "correct_answers": [
        "`$clock->sleep(3660);` sur une MockClock"
      ],
      "explanation": "MockClock avance instantanément sans attendre réellement."
    },
    {
      "id": 4,
      "question": "Que retourne `now()` ?",
      "type": "single_choice",
      "options": [
        "DateTimeImmutable",
        "Timestamp",
        "DateTime mutable",
        "String"
      ],
      "correct_answers": [
        "DateTimeImmutable"
      ],
      "explanation": "ClockInterface impose un DateTimeImmutable."
    },
    {
      "id": 5,
      "question": "PSR associée au composant Clock ?",
      "type": "single_choice",
      "options": [
        "PSR-20",
        "PSR-3",
        "PSR-7",
        "PSR-14"
      ],
      "correct_answers": [
        "PSR-20"
      ],
      "explanation": "PSR-20 définit ClockInterface."
    },
    {
      "id": 6,
      "question": "Quel risque avec `time()` direct en prod/tests ?",
      "type": "single_choice",
      "options": [
        "Difficile à tester (non mockable) et peut ralentir les tests (sleep réel)",
        "Plus rapide",
        "Toujours UTC",
        "Toujours en cache"
      ],
      "correct_answers": [
        "Difficile à tester (non mockable) et peut ralentir les tests (sleep réel)"
      ],
      "explanation": "Coupler au système rend les tests lents et fragiles."
    },
    {
      "id": 7,
      "question": "Comment changer de fuseau pour l'horloge ?",
      "type": "single_choice",
      "options": [
        "`withTimeZone()` sur l'horloge",
        "Changer php.ini",
        "Impossible",
        "Utiliser date_default_timezone_set"
      ],
      "correct_answers": [
        "`withTimeZone()` sur l'horloge"
      ],
      "explanation": "Clock peut être clonée avec un autre timezone."
    },
    {
      "id": 8,
      "question": "À quoi sert `sleep()` sur l'interface Clock ?",
      "type": "single_choice",
      "options": [
        "Dans MockClock, avance virtuellement le temps; dans NativeClock, dort réellement",
        "Toujours attendre 1s",
        "Toujours lever une exception",
        "Changer la locale"
      ],
      "correct_answers": [
        "Dans MockClock, avance virtuellement le temps; dans NativeClock, dort réellement"
      ],
      "explanation": "sleep est mocké pour éviter l'attente en test."
    },
    {
      "id": 9,
      "question": "Quelle classe Clock aide à manipuler les dates avec une API fluide (extends DateTimeImmutable) ?",
      "type": "single_choice",
      "options": [
        "DatePoint",
        "NativeClock",
        "MockClock",
        "ClockImmutable"
      ],
      "correct_answers": [
        "DatePoint"
      ],
      "explanation": "DatePoint offre une API fluide, ClockInterface reste l'entrée principale."
    },
    {
      "id": 10,
      "question": "Comment injecter l'horloge dans un service Symfony ?",
      "type": "single_choice",
      "options": [
        "Type-hinter `Psr\\Clock\\ClockInterface` dans le constructeur (autowiring)",
        "Utiliser `new NativeClock()` partout",
        "Via un paramètre de config",
        "En lisant $_SERVER['TIME']"
      ],
      "correct_answers": [
        "Type-hinter `Psr\\Clock\\ClockInterface` dans le constructeur (autowiring)"
      ],
      "explanation": "Symfony autowire ClockInterface avec NativeClock ou MockClock selon l'env/test."
    }
  ]
}
