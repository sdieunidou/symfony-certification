{
  "source_file": "19-composants/messenger.md",
  "title": "Le Composant Messenger",
  "questions": [
    {
      "id": 1,
      "question": "Quelles sont les briques principales de Messenger ?",
      "type": "multiple_choice",
      "options": [
        "Message (DTO)",
        "Bus + Middleware",
        "Handler(s)",
        "Transport (sync/async) et Envelope/Stamps"
      ],
      "correct_answers": [
        "Message (DTO)",
        "Bus + Middleware",
        "Handler(s)",
        "Transport (sync/async) et Envelope/Stamps"
      ],
      "explanation": "Messenger structure un flux unidirectionnel message→bus→middleware→handler→transport."
    },
    {
      "id": 2,
      "question": "Comment rendre un message asynchrone ?",
      "type": "single_choice",
      "options": [
        "En le routant vers un transport non `sync://` dans `messenger.yaml`",
        "En ajoutant `implements AsyncInterface`",
        "En appelant `dispatchAsync()`",
        "En ajoutant un délai dans le code"
      ],
      "correct_answers": [
        "En le routant vers un transport non `sync://` dans `messenger.yaml`"
      ],
      "explanation": "Le routing décide du transport (queue) à utiliser."
    },
    {
      "id": 3,
      "question": "Que se passe-t-il si un Handler lève une exception avec une stratégie de retry ?",
      "type": "single_choice",
      "options": [
        "Le message est perdu",
        "Il est ré-queue avec backoff jusqu'à `max_retries`, puis envoyé en failure_transport",
        "Le worker s'arrête",
        "Rien, l'exception est ignorée"
      ],
      "correct_answers": [
        "Il est ré-queue avec backoff jusqu'à `max_retries`, puis envoyé en failure_transport"
      ],
      "explanation": "Retry puis DLQ (failure transport) si échec après tous les essais."
    },
    {
      "id": 4,
      "question": "Comment consommer les messages d'un transport asynchrone ?",
      "type": "single_choice",
      "options": [
        "`php bin/console messenger:consume <transport>`",
        "`php bin/console messenger:run`",
        "`php bin/console queue:work`",
        "Automatiquement sans worker"
      ],
      "correct_answers": [
        "`php bin/console messenger:consume <transport>`"
      ],
      "explanation": "Un worker `messenger:consume` lit le transport et traite les messages."
    },
    {
      "id": 5,
      "question": "À quoi sert `HandledStamp` ?",
      "type": "single_choice",
      "options": [
        "À stocker le résultat d'un Handler pour un dispatch synchrone",
        "À gérer les retries",
        "À définir le transport",
        "À retarder l'exécution"
      ],
      "correct_answers": [
        "À stocker le résultat d'un Handler pour un dispatch synchrone"
      ],
      "explanation": "Le HandledStamp permet de récupérer la valeur de retour du Handler."
    },
    {
      "id": 6,
      "question": "Quels middlewares natifs sont cités ?",
      "type": "multiple_choice",
      "options": [
        "validation",
        "doctrine_transaction",
        "doctrine_ping_connection/doctrine_close_connection",
        "router_context"
      ],
      "correct_answers": [
        "validation",
        "doctrine_transaction",
        "doctrine_ping_connection/doctrine_close_connection",
        "router_context"
      ],
      "explanation": "Ces middlewares gèrent validation, transactions, connexions BDD, contexte routeur."
    },
    {
      "id": 7,
      "question": "Quel rôle du `failure_transport` ?",
      "type": "single_choice",
      "options": [
        "Stocker définitivement les messages ayant échoué après retries",
        "Accélérer les messages",
        "Gérer les priorités",
        "Envoyer des emails"
      ],
      "correct_answers": [
        "Stocker définitivement les messages ayant échoué après retries"
      ],
      "explanation": "Le failure transport sert de DLQ pour inspection/ré-essai manuel."
    },
    {
      "id": 8,
      "question": "Comment déboguer/relancer les messages en échec ?",
      "type": "multiple_choice",
      "options": [
        "`messenger:failed:show`",
        "`messenger:failed:retry`",
        "`messenger:failed:remove`",
        "`queue:inspect`"
      ],
      "correct_answers": [
        "`messenger:failed:show`",
        "`messenger:failed:retry`",
        "`messenger:failed:remove`"
      ],
      "explanation": "Des commandes dédiées existent pour voir, relancer ou supprimer."
    },
    {
      "id": 9,
      "question": "Pourquoi redémarrer les workers après un déploiement ?",
      "type": "single_choice",
      "options": [
        "Parce qu'ils ont chargé l'ancien code en mémoire",
        "Pour vider les logs",
        "Pour régénérer le cache HTTP",
        "Pour recharger .env"
      ],
      "correct_answers": [
        "Parce qu'ils ont chargé l'ancien code en mémoire"
      ],
      "explanation": "Workers longue durée doivent être recyclés pour prendre le nouveau code."
    },
    {
      "id": 10,
      "question": "Comment retarder l'exécution d'un message unique ?",
      "type": "single_choice",
      "options": [
        "En ajoutant un `DelayStamp` au dispatch",
        "En modifiant le DSN",
        "En changeant le bus",
        "Impossible"
      ],
      "correct_answers": [
        "En ajoutant un `DelayStamp` au dispatch"
      ],
      "explanation": "DelayStamp applique un délai sur un message donné."
    },
    {
      "id": 11,
      "question": "Quel middleware rend l'exécution idempotente ?",
      "type": "single_choice",
      "options": [
        "Aucun, c'est à l'handler d'être idempotent",
        "`idempotent` middleware",
        "retry_strategy",
        "router_context"
      ],
      "correct_answers": [
        "Aucun, c'est à l'handler d'être idempotent"
      ],
      "explanation": "Les handlers doivent supporter la relecture (retry/double délivrance)."
    },
    {
      "id": 12,
      "question": "Comment séparer commandes/queries/événements avec Messenger ?",
      "type": "single_choice",
      "options": [
        "Configurer plusieurs bus (command.bus, query.bus, event.bus) avec middlewares adaptés",
        "Utiliser un seul bus avec tags",
        "Désactiver le routage",
        "Utiliser EventDispatcher"
      ],
      "correct_answers": [
        "Configurer plusieurs bus (command.bus, query.bus, event.bus) avec middlewares adaptés"
      ],
      "explanation": "Messenger supporte plusieurs bus pour CQRS et flux distincts."
    }
  ]
}
