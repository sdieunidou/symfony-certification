{
  "source_file": "19-composants/http-client.md",
  "title": "Composant Symfony HttpClient",
  "questions": [
    {
      "id": 1,
      "question": "Quelle est la caractéristique principale du composant `HttpClient` de Symfony par rapport à `file_get_contents` ou `Guzzle` (par défaut) ?",
      "type": "single_choice",
      "options": [
        "Il est synchrone et bloquant.",
        "Il est asynchrone par défaut : la requête est envoyée mais PHP ne bloque pas tant que vous ne lisez pas la réponse.",
        "Il ne supporte pas HTTPS.",
        "Il n'a aucune dépendance."
      ],
      "correct_answers": [
        "Il est asynchrone par défaut : la requête est envoyée mais PHP ne bloque pas tant que vous ne lisez pas la réponse."
      ],
      "explanation": "Cela permet d'envoyer plusieurs requêtes en parallèle (multiplexing) sans complexité additionnelle."
    },
    {
      "id": 2,
      "question": "À quoi servent les 'Scoped Clients' dans la configuration `framework.yaml` ?",
      "type": "single_choice",
      "options": [
        "À limiter la portée des variables.",
        "À pré-configurer des options spécifiques (URL de base, headers d'auth) pour des services tiers (ex: GitHub, Stripe) et les injecter facilement.",
        "À créer des clients privés.",
        "À gérer les scopes OAuth."
      ],
      "correct_answers": [
        "À pré-configurer des options spécifiques (URL de base, headers d'auth) pour des services tiers (ex: GitHub, Stripe) et les injecter facilement."
      ],
      "explanation": "Cela évite de répéter l'URL de base ou le token à chaque appel dans le code."
    },
    {
      "id": 3,
      "question": "Si le code HTTP de la réponse est 404 ou 500, quand l'exception est-elle lancée par défaut ?",
      "type": "single_choice",
      "options": [
        "Immédiatement lors de l'appel à `$client->request()`.",
        "Jamais.",
        "Uniquement lorsque vous essayez de lire le contenu de la réponse (ex: `$response->getContent()`).",
        "Au moment du destructeur de l'objet."
      ],
      "correct_answers": [
        "Uniquement lorsque vous essayez de lire le contenu de la réponse (ex: `$response->getContent()`)."
      ],
      "explanation": "Le client est paresseux. Il ne vérifie le statut que lorsque vous consommez la réponse, sauf si vous désactivez le `throw`."
    },
    {
      "id": 4,
      "question": "Quelle classe utiliser pour tester des services qui dépendent de `HttpClientInterface` sans faire de vraies requêtes HTTP ?",
      "type": "single_choice",
      "options": [
        "`MockHttpClient`",
        "`TestHttpClient`",
        "`NullHttpClient`",
        "`VoidHttpClient`"
      ],
      "correct_answers": [
        "`MockHttpClient`"
      ],
      "explanation": "`MockHttpClient` permet de simuler des réponses (statut, body) de manière déterministe."
    }
  ]
}
