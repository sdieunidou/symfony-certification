{
  "source_file": "19-composants/uid.md",
  "title": "Composant UID",
  "questions": [
    {
      "id": 1,
      "question": "Quelles versions d'UUID sont recommandées ou déconseillées pour des PK en base selon la doc ?",
      "type": "multiple_choice",
      "options": [
        "v1 : déconseillé (MAC + ordre aléatoire peu performant)",
        "v4 : aléatoire, fragmente les index",
        "v6/v7 : ordonnables, recommandés pour les perfs d'index",
        "v8 : format libre expérimental"
      ],
      "correct_answers": [
        "v1 : déconseillé (MAC + ordre aléatoire peu performant)",
        "v4 : aléatoire, fragmente les index",
        "v6/v7 : ordonnables, recommandés pour les perfs d'index",
        "v8 : format libre expérimental"
      ],
      "explanation": "v7 est privilégié (RFC 9562) pour l'indexation ; v4 est aléatoire et fragmente."
    },
    {
      "id": 2,
      "question": "Quelles propriétés clés différencient un ULID d'un UUID v4 ?",
      "type": "multiple_choice",
      "options": [
        "ULID est triable lexicographiquement (timestamp en tête)",
        "ULID est encodé en Base32, sans tirets, case-insensitive",
        "ULID garantit l'ordre même à la même milliseconde (monotone)",
        "ULID fait 64 bits uniquement"
      ],
      "correct_answers": [
        "ULID est triable lexicographiquement (timestamp en tête)",
        "ULID est encodé en Base32, sans tirets, case-insensitive",
        "ULID garantit l'ordre même à la même milliseconde (monotone)"
      ],
      "explanation": "ULID reste 128 bits mais ordonnable et lisible."
    },
    {
      "id": 3,
      "question": "Comment générer et convertir un UUID v7 en chaîne et binaire avec le composant UID ?",
      "type": "single_choice",
      "options": [
        "`$uuid = Uuid::v7(); $uuid->toRfc4122(); $uuid->toBinary();`",
        "`Uuid::generate(7); $uuid->string(); $uuid->binary();`",
        "`new Uuid(7); $uuid->export();`",
        "`Uuid::random(); $uuid->toHex();`"
      ],
      "correct_answers": [
        "`$uuid = Uuid::v7(); $uuid->toRfc4122(); $uuid->toBinary();`"
      ],
      "explanation": "La façade `Uuid` expose v7 et les conversions RFC/binaire."
    },
    {
      "id": 4,
      "question": "Quelles commandes console couvrent génération et inspection des UID ?",
      "type": "multiple_choice",
      "options": [
        "`uuid:generate --count=5`",
        "`ulid:generate`",
        "`uuid:inspect <uuid>`",
        "`uid:dump`"
      ],
      "correct_answers": [
        "`uuid:generate --count=5`",
        "`ulid:generate`",
        "`uuid:inspect <uuid>`"
      ],
      "explanation": "La doc cite generate/inspect pour UUID et ULID."
    },
    {
      "id": 5,
      "question": "Comment mapper une PK UUID avec Doctrine dans l'exemple fourni ?",
      "type": "multiple_choice",
      "options": [
        "`#[ORM\\\\Column(type: 'uuid', unique: true)]`",
        "`#[ORM\\\\GeneratedValue(strategy: 'CUSTOM')]`",
        "`#[ORM\\\\CustomIdGenerator(class: 'doctrine.uuid_generator')]`",
        "`#[ORM\\\\Column(type: 'varchar', length: 36)]` obligatoire"
      ],
      "correct_answers": [
        "`#[ORM\\\\Column(type: 'uuid', unique: true)]`",
        "`#[ORM\\\\GeneratedValue(strategy: 'CUSTOM')]`",
        "`#[ORM\\\\CustomIdGenerator(class: 'doctrine.uuid_generator')]`"
      ],
      "explanation": "Type uuid + générateur custom ; pas besoin de varchar(36)."
    },
    {
      "id": 6,
      "question": "Quels stockages DB sont mentionnés pour UUID/ULID ?",
      "type": "multiple_choice",
      "options": [
        "PostgreSQL : type natif `UUID`",
        "MySQL/MariaDB : `BINARY(16)`",
        "SQLite : `INTEGER`",
        "MySQL : `VARCHAR(36)` obligatoire"
      ],
      "correct_answers": [
        "PostgreSQL : type natif `UUID`",
        "MySQL/MariaDB : `BINARY(16)`"
      ],
      "explanation": "Les drivers Doctrine gèrent UUID/ULID en natif ; pas de VARCHAR imposé."
    },
    {
      "id": 7,
      "question": "Quels risques de performance sont liés aux UUID v4 aléatoires ?",
      "type": "single_choice",
      "options": [
        "Fragmentation d'index (page splitting) lors d'inserts massifs",
        "Collisions fréquentes",
        "Perte d'entropie",
        "Taille supérieure à 256 bits"
      ],
      "correct_answers": [
        "Fragmentation d'index (page splitting) lors d'inserts massifs"
      ],
      "explanation": "Le désordre des v4 perturbe l'ordre des index B-Tree."
    },
    {
      "id": 8,
      "question": "Quels flags/propriétés internes de `AbstractUid` sont mis en avant ?",
      "type": "multiple_choice",
      "options": [
        "Conversion binaire <-> string",
        "Encodage Base32/Base58",
        "Gestion d'un timestamp pour ULID/UUID v7",
        "Compilation en WebAssembly"
      ],
      "correct_answers": [
        "Conversion binaire <-> string",
        "Encodage Base32/Base58",
        "Gestion d'un timestamp pour ULID/UUID v7"
      ],
      "explanation": "AbstractUid sert de base pour formats/encodages et time-based."
    },
    {
      "id": 9,
      "question": "Quel raccourci permet de convertir un ULID en format RFC 4122 ?",
      "type": "single_choice",
      "options": [
        "`$ulid->toRfc4122()`",
        "`$ulid->toUuidString()`",
        "`Uuid::fromUlid()`",
        "`$ulid->hex()`"
      ],
      "correct_answers": [
        "`$ulid->toRfc4122()`"
      ],
      "explanation": "ULID peut se convertir en représentation UUID standard via cette méthode."
    },
    {
      "id": 10,
      "question": "Pourquoi stocker un UUID en `BINARY(16)` plutôt qu'en `VARCHAR(36)` ?",
      "type": "multiple_choice",
      "options": [
        "Réduction de la taille disque",
        "Meilleure densité d'index (RAM)",
        "Moins de comparaisons lexicales coûteuses",
        "Parce que Doctrine interdit VARCHAR"
      ],
      "correct_answers": [
        "Réduction de la taille disque",
        "Meilleure densité d'index (RAM)",
        "Moins de comparaisons lexicales coûteuses"
      ],
      "explanation": "16 octets vs 36 chars ; impact direct sur index et cache."
    },
    {
      "id": 11,
      "question": "Comment générer un ULID côté PHP selon l'exemple ?",
      "type": "single_choice",
      "options": [
        "`$ulid = new Ulid();`",
        "`Ulid::v1();`",
        "`Ulid::random();`",
        "`Ulid::fromString();` uniquement"
      ],
      "correct_answers": [
        "`$ulid = new Ulid();`"
      ],
      "explanation": "Le constructeur génère un ULID monotone."
    },
    {
      "id": 12,
      "question": "Que fournit la commande `uuid:inspect` ?",
      "type": "single_choice",
      "options": [
        "Les versions PHP",
        "Les métadonnées de l'UUID (version, variant, timestamp pour v1/v6/v7...)",
        "La cartographie Doctrine",
        "Le manifest Webpack"
      ],
      "correct_answers": [
        "Les métadonnées de l'UUID (version, variant, timestamp pour v1/v6/v7...)"
      ],
      "explanation": "L'inspection affiche les infos structurelles de l'identifiant."
    }
  ]
}
