{
  "source_file": "19-composants/config.md",
  "title": "Le Composant Config",
  "questions": [
    {
      "id": 1,
      "question": "Quelles étapes clés composent le cycle Config (bundle) ?",
      "type": "multiple_choice",
      "options": [
        "Load (FileLocator + loaders YAML/XML/PHP)",
        "Define/Validate (TreeBuilder)",
        "Process (Processor fusion/validation)",
        "Cache (ConfigCache)"
      ],
      "correct_answers": [
        "Load (FileLocator + loaders YAML/XML/PHP)",
        "Define/Validate (TreeBuilder)",
        "Process (Processor fusion/validation)",
        "Cache (ConfigCache)"
      ],
      "explanation": "Les 4 étapes structurelles du composant Config."
    },
    {
      "id": 2,
      "question": "À quoi sert `TreeBuilder`/`ConfigurationInterface` ?",
      "type": "single_choice",
      "options": [
        "Définir le schéma, defaults et validation de la configuration",
        "Charger les fichiers YAML",
        "Mettre en cache la config",
        "Compiler le container"
      ],
      "correct_answers": [
        "Définir le schéma, defaults et validation de la configuration"
      ],
      "explanation": "C'est le contrat de structure/validation des clés autorisées."
    },
    {
      "id": 3,
      "question": "Quel mécanisme permet à un bundle d'injecter de la config dans un autre avant traitement ?",
      "type": "single_choice",
      "options": [
        "`PrependExtensionInterface` sur l'Extension du bundle",
        "Un CompilerPass",
        "Un service taggé",
        "Un fichier env"
      ],
      "correct_answers": [
        "`PrependExtensionInterface` sur l'Extension du bundle"
      ],
      "explanation": "Prepend permet de modifier la config d'un autre bundle en amont."
    },
    {
      "id": 4,
      "question": "Que permet `scalarPrototype()` dans un `ArrayNode` ?",
      "type": "single_choice",
      "options": [
        "Valider une liste de scalaires de taille inconnue",
        "Forcer un unique scalaire",
        "Créer des services",
        "Ajouter des routes"
      ],
      "correct_answers": [
        "Valider une liste de scalaires de taille inconnue"
      ],
      "explanation": "Prototype décrit chaque élément d'un tableau."
    },
    {
      "id": 5,
      "question": "Que fait `addDefaultsIfNotSet()` sur un `ArrayNode` ?",
      "type": "single_choice",
      "options": [
        "Crée le tableau avec defaults même si l'utilisateur n'a rien défini",
        "Lève une erreur si non défini",
        "Désactive la validation",
        "Force un null"
      ],
      "correct_answers": [
        "Crée le tableau avec defaults même si l'utilisateur n'a rien défini"
      ],
      "explanation": "Sans lui, un sous-array est absent tant que non déclaré."
    },
    {
      "id": 6,
      "question": "Comment normaliser avant validation une valeur dans TreeBuilder ?",
      "type": "single_choice",
      "options": [
        "Avec `beforeNormalization()->ifString()->then(fn($v)=>[$v])`",
        "Avec `normalizeFirst()`",
        "Impossible",
        "Via ConfigCache"
      ],
      "correct_answers": [
        "Avec `beforeNormalization()->ifString()->then(fn($v)=>[$v])`"
      ],
      "explanation": "Le hook beforeNormalization prépare les données avant validation."
    },
    {
      "id": 7,
      "question": "Comment ajouter une règle de validation custom sur un node ?",
      "type": "single_choice",
      "options": [
        "`->validate()->ifTrue(fn($v)=>...)->thenInvalid('message')`",
        "`->assert()`",
        "`->guard()`",
        "`->throw()`"
      ],
      "correct_answers": [
        "`->validate()->ifTrue(fn($v)=>...)->thenInvalid('message')`"
      ],
      "explanation": "validate/thenInvalid permet des règles spécifiques."
    },
    {
      "id": 8,
      "question": "Comment sont fusionnées plusieurs configs (`config.yaml`, `config_prod.yaml`) ?",
      "type": "single_choice",
      "options": [
        "Le dernier fichier chargé écrase les valeurs précédentes clé par clé",
        "La première valeur gagne toujours",
        "Concaténation simple",
        "Symfony refuse la surcharge"
      ],
      "correct_answers": [
        "Le dernier fichier chargé écrase les valeurs précédentes clé par clé"
      ],
      "explanation": "Fusion clé par clé, le dernier (prod) a priorité."
    },
    {
      "id": 9,
      "question": "À quoi sert `ConfigCache` et `FileResource` ?",
      "type": "multiple_choice",
      "options": [
        "Éviter de parser/revalider la config à chaque requête",
        "Invalider le cache si un fichier source change",
        "Stocker la config dans Redis",
        "Compiler le kernel"
      ],
      "correct_answers": [
        "Éviter de parser/revalider la config à chaque requête",
        "Invalider le cache si un fichier source change"
      ],
      "explanation": "ConfigCache met en cache le résultat, FileResource surveille les fichiers."
    },
    {
      "id": 10,
      "question": "Quel rôle joue le `Processor` ?",
      "type": "single_choice",
      "options": [
        "Fusionner/valider les tableaux bruts contre l'arbre de configuration",
        "Charger les fichiers YAML",
        "Compiler le conteneur de services",
        "Gérer le cache HTTP"
      ],
      "correct_answers": [
        "Fusionner/valider les tableaux bruts contre l'arbre de configuration"
      ],
      "explanation": "Processor applique l'arbre au set de configs collectées."
    },
    {
      "id": 11,
      "question": "À quoi sert `FileLocator` et le couple `LoaderResolver/DelegatingLoader` ?",
      "type": "single_choice",
      "options": [
        "Localiser les fichiers de config et déléguer au loader adapté (YAML/XML/PHP)",
        "Charger Twig",
        "Résoudre les routes",
        "Gérer la sécurité"
      ],
      "correct_answers": [
        "Localiser les fichiers de config et déléguer au loader adapté (YAML/XML/PHP)"
      ],
      "explanation": "FileLocator trouve les fichiers, LoaderResolver choisit le loader, DelegatingLoader délègue."
    }
  ]
}
