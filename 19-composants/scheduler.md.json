{
  "source_file": "19-composants/scheduler.md",
  "title": "Le Composant Scheduler",
  "questions": [
    {
      "id": 1,
      "question": "En quoi le Scheduler diffère d'un cron système classique ?",
      "type": "single_choice",
      "options": [
        "Cron démarre un nouveau process à chaque tick, le Scheduler est un worker longue durée qui dort et se réveille pour dispatcher",
        "Scheduler est plus lent car redémarre à chaque exécution",
        "Cron ne marche pas sous Linux",
        "Scheduler ne fonctionne qu'en CLI"
      ],
      "correct_answers": [
        "Cron démarre un nouveau process à chaque tick, le Scheduler est un worker longue durée qui dort et se réveille pour dispatcher"
      ],
      "explanation": "Scheduler reste chaud (daemon Messenger) et se réveille aux échéances."
    },
    {
      "id": 2,
      "question": "Sur quel composant s'appuie le Scheduler pour exécuter les tâches ?",
      "type": "single_choice",
      "options": [
        "Messenger",
        "HttpKernel",
        "Process",
        "EventDispatcher uniquement"
      ],
      "correct_answers": [
        "Messenger"
      ],
      "explanation": "Les tâches sont des messages Messenger dispatchés/consommés."
    },
    {
      "id": 3,
      "question": "Quel est le rôle de `#[AsSchedule]` sur un provider ?",
      "type": "single_choice",
      "options": [
        "Le déclarer comme ScheduleProvider détecté automatiquement",
        "Définir la fréquence directement",
        "Choisir le transport",
        "Créer un cron"
      ],
      "correct_answers": [
        "Le déclarer comme ScheduleProvider détecté automatiquement"
      ],
      "explanation": "AsSchedule marque un provider qui retourne un Schedule."
    },
    {
      "id": 4,
      "question": "Pourquoi rendre le schedule stateful avec un cache/lock ?",
      "type": "single_choice",
      "options": [
        "Éviter les doublons lors de redémarrages ou multi-workers",
        "Accélérer le worker",
        "Obligatoire pour prod",
        "Gérer le SSL"
      ],
      "correct_answers": [
        "Éviter les doublons lors de redémarrages ou multi-workers"
      ],
      "explanation": "Stateful mémorise la dernière exécution pour ne pas rejouer."
    },
    {
      "id": 5,
      "question": "Comment lancer la consommation d'un schedule nommé `default` ?",
      "type": "single_choice",
      "options": [
        "`php bin/console messenger:consume scheduler_default`",
        "`php bin/console scheduler:run default`",
        "`cron -f`",
        "`php bin/console worker:run`"
      ],
      "correct_answers": [
        "`php bin/console messenger:consume scheduler_default`"
      ],
      "explanation": "Le scheduler crée un transport virtuel consommé par messenger:consume."
    },
    {
      "id": 6,
      "question": "Comment définir une tâche quotidienne à 12h heure de Paris ?",
      "type": "single_choice",
      "options": [
        "RecurringMessage::cron('0 12 * * *', new Message(), new \\DateTimeZone('Europe/Paris'))",
        "RecurringMessage::every('12h', ...)",
        "Trigger::daily('Paris')",
        "Impossible"
      ],
      "correct_answers": [
        "RecurringMessage::cron('0 12 * * *', new Message(), new \\DateTimeZone('Europe/Paris'))"
      ],
      "explanation": "cron() accepte l'expression et la timezone."
    },
    {
      "id": 7,
      "question": "À quoi sert le jitter ?",
      "type": "single_choice",
      "options": [
        "Décaler aléatoirement l'exécution pour éviter les réveils simultanés (thundering herd)",
        "Ajouter un délai de retry",
        "Changer de fuseau",
        "Accélérer les tâches"
      ],
      "correct_answers": [
        "Décaler aléatoirement l'exécution pour éviter les réveils simultanés (thundering herd)"
      ],
      "explanation": "Le jitter lisse les déclenchements."
    },
    {
      "id": 8,
      "question": "Que fait `RecurringMessage::every('10 minutes', new Msg(), jitter:5)` ?",
      "type": "single_choice",
      "options": [
        "Planifie toutes les 10 minutes avec +/-5 minutes d'aléa",
        "Planifie toutes les 5 minutes",
        "Planifie une fois",
        "Rien"
      ],
      "correct_answers": [
        "Planifie toutes les 10 minutes avec +/-5 minutes d'aléa"
      ],
      "explanation": "Jitter ajoute une variabilité autour de la période."
    },
    {
      "id": 9,
      "question": "Comment éviter de relancer une tâche déjà en cours si le worker redémarre juste après l'avoir déclenchée ?",
      "type": "single_choice",
      "options": [
        "En rendant le schedule stateful (cache/lock) pour mémoriser la dernière exécution",
        "Impossible",
        "En doublant le cron",
        "En désactivant le cache"
      ],
      "correct_answers": [
        "En rendant le schedule stateful (cache/lock) pour mémoriser la dernière exécution"
      ],
      "explanation": "Stateful garde l'état pour éviter les doublons au redémarrage."
    },
    {
      "id": 10,
      "question": "Quelle commande aide à visualiser les prochaines exécutions prévues ?",
      "type": "single_choice",
      "options": [
        "`php bin/console debug:scheduler`",
        "`php bin/console scheduler:list`",
        "`php bin/console debug:messenger`",
        "`crontab -l`"
      ],
      "correct_answers": [
        "`php bin/console debug:scheduler`"
      ],
      "explanation": "debug:scheduler affiche le planning des tâches."
    }
  ]
}
