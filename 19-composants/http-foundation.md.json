{
  "source_file": "19-composants/http-foundation.md",
  "title": "Le Composant HttpFoundation",
  "questions": [
    {
      "id": 1,
      "question": "Qu'encapsule HttpFoundation ?",
      "type": "multiple_choice",
      "options": [
        "Les superglobales PHP via `Request` (GET/POST/FILES/COOKIE/SERVER)",
        "Les en-têtes via `HeaderBag`",
        "Les réponses HTTP via `Response` et dérivées",
        "Le routage"
      ],
      "correct_answers": [
        "Les superglobales PHP via `Request` (GET/POST/FILES/COOKIE/SERVER)",
        "Les en-têtes via `HeaderBag`",
        "Les réponses HTTP via `Response` et dérivées"
      ],
      "explanation": "HttpFoundation fournit Request/Response, pas le routing."
    },
    {
      "id": 2,
      "question": "Quelles sont les priorités de `$request->get('key')` (à éviter) ?",
      "type": "single_choice",
      "options": [
        "query puis attributes puis request",
        "request puis query",
        "attributes puis query",
        "cookies puis server"
      ],
      "correct_answers": [
        "query puis attributes puis request"
      ],
      "explanation": "D'où la recommandation d'utiliser `query/request/attributes` explicitement."
    },
    {
      "id": 3,
      "question": "Comment lire un JSON payload en tableau ?",
      "type": "single_choice",
      "options": [
        "`$request->toArray()` (Symfony >=5.2)",
        "`$request->getJson()`",
        "`json_decode($_POST)`",
        "`$request->request->all()`"
      ],
      "correct_answers": [
        "`$request->toArray()` (Symfony >=5.2)"
      ],
      "explanation": "toArray() parse le body JSON et lève en cas d'erreur."
    },
    {
      "id": 4,
      "question": "Quelles classes de réponse spécialisées existent ?",
      "type": "multiple_choice",
      "options": [
        "JsonResponse",
        "StreamedResponse",
        "BinaryFileResponse",
        "RedirectResponse"
      ],
      "correct_answers": [
        "JsonResponse",
        "StreamedResponse",
        "BinaryFileResponse",
        "RedirectResponse"
      ],
      "explanation": "Plusieurs helpers pour JSON, streaming, fichiers, redirections."
    },
    {
      "id": 5,
      "question": "Quand utiliser `BinaryFileResponse` vs `StreamedResponse` ?",
      "type": "single_choice",
      "options": [
        "BinaryFileResponse pour un fichier existant (support Range), StreamedResponse pour générer à la volée",
        "Binary pour les JSON",
        "Streamed pour les images uniquement",
        "Indifférent"
      ],
      "correct_answers": [
        "BinaryFileResponse pour un fichier existant (support Range), StreamedResponse pour générer à la volée"
      ],
      "explanation": "Binary envoie un fichier, Streamed produit du contenu live."
    },
    {
      "id": 6,
      "question": "Comment gérer le cache HTTP avec Response ?",
      "type": "multiple_choice",
      "options": [
        "`setPublic()/setMaxAge()/setSharedMaxAge()`",
        "`setEtag()` puis `isNotModified($request)`",
        "En ajoutant `Cache-Control` manuellement",
        "En désactivant les headers"
      ],
      "correct_answers": [
        "`setPublic()/setMaxAge()/setSharedMaxAge()`",
        "`setEtag()` puis `isNotModified($request)`"
      ],
      "explanation": "Helpers pour cache contrôlé et 304."
    },
    {
      "id": 7,
      "question": "Pourquoi configurer les Trusted Proxies/Hosts ?",
      "type": "single_choice",
      "options": [
        "Pour que `getClientIp()` et les URLs reflètent le client réel derrière un LB (`X-Forwarded-*`)",
        "Pour activer HTTPS",
        "Pour gérer les sessions",
        "Pour router les requêtes"
      ],
      "correct_answers": [
        "Pour que `getClientIp()` et les URLs reflètent le client réel derrière un LB (`X-Forwarded-*`)"
      ],
      "explanation": "Les proxies doivent être déclarés pour faire confiance aux headers forward."
    },
    {
      "id": 8,
      "question": "Quand la session est-elle réellement démarrée ?",
      "type": "single_choice",
      "options": [
        "À l'appel de `$request->getSession()` ou lors d'un write, pas automatiquement",
        "Toujours au début de la requête",
        "Jamais en Symfony",
        "Uniquement en CLI"
      ],
      "correct_answers": [
        "À l'appel de `$request->getSession()` ou lors d'un write, pas automatiquement"
      ],
      "explanation": "La session est lazy, démarrée seulement si utilisée."
    },
    {
      "id": 9,
      "question": "Quelles méthodes de `ParameterBag` aident à filtrer/caster ?",
      "type": "multiple_choice",
      "options": [
        "`getInt()`",
        "`getBoolean()`",
        "`getAlpha()`",
        "`getDigits()`"
      ],
      "correct_answers": [
        "`getInt()`",
        "`getBoolean()`",
        "`getAlpha()`",
        "`getDigits()`"
      ],
      "explanation": "ParameterBag fournit des helpers de filtrage simples."
    },
    {
      "id": 10,
      "question": "Comment récupérer l'IP client de façon fiable derrière un LB ?",
      "type": "single_choice",
      "options": [
        "Configurer TrustedProxies puis appeler `$request->getClientIp()`",
        "Lire `$_SERVER['REMOTE_ADDR']` directement",
        "Toujours utiliser `X-Forwarded-For` sans filtre",
        "Impossible"
      ],
      "correct_answers": [
        "Configurer TrustedProxies puis appeler `$request->getClientIp()`"
      ],
      "explanation": "TrustedProxies permet à HttpFoundation d'utiliser les headers forward."
    },
    {
      "id": 11,
      "question": "Quelle méthode statique crée une Request depuis les superglobales (entrypoint front controller) ?",
      "type": "single_choice",
      "options": [
        "`Request::createFromGlobals()`",
        "`Request::fromSuperglobals()`",
        "`Request::init()`",
        "`Request::boot()`"
      ],
      "correct_answers": [
        "`Request::createFromGlobals()`"
      ],
      "explanation": "Utilisée dans public/index.php."
    }
  ]
}
