{
  "source_file": "16-architecture/clean-architecture.md",
  "title": "Clean Architecture (Hexagonale / Onion)",
  "questions": [
    {
      "id": 1,
      "question": "Quelle est la règle de dépendance (Dependency Rule) ?",
      "type": "single_choice",
      "options": [
        "Les dépendances pointent vers l'intérieur (Domain/Application), jamais l'inverse",
        "Les dépendances pointent vers l'extérieur",
        "Elles sont cycliques",
        "Elles dépendent de la base de données"
      ],
      "correct_answers": [
        "Les dépendances pointent vers l'intérieur (Domain/Application), jamais l'inverse"
      ],
      "explanation": "Les cercles internes ignorent les détails externes (framework/DB/UI)."
    },
    {
      "id": 2,
      "question": "Dans le pattern 'Ports & Adapters', que représente un 'Output Port' ?",
      "type": "single_choice",
      "options": [
        "Une prise HDMI.",
        "Une interface définie dans la couche Application/Domaine que l'infrastructure doit implémenter (ex: `UserRepositoryInterface`).",
        "Une classe concrète d'accès aux données.",
        "Un contrôleur Symfony."
      ],
      "correct_answers": [
        "Une interface définie dans la couche Application/Domaine que l'infrastructure doit implémenter (ex: `UserRepositoryInterface`)."
      ],
      "explanation": "C'est le mécanisme d'Inversion de Dépendance : le Domaine exprime un besoin (Port) que l'Infrastructure satisfait (Adapter)."
    },
    {
      "id": 3,
      "question": "Quel objet doit traverser les frontières (Boundaries) entre le Contrôleur et le Use Case (Application) ?",
      "type": "single_choice",
      "options": [
        "L'Entité Doctrine directement (pour le Lazy Loading).",
        "La Request HTTP brute.",
        "Un DTO (Data Transfer Object) ou un Request Model.",
        "Un tableau associatif non typé."
      ],
      "correct_answers": [
        "Un DTO (Data Transfer Object) ou un Request Model."
      ],
      "explanation": "L'utilisation de DTOs simples (POPO) découple le cœur de l'application des objets spécifiques au framework (Request) ou à la persistance (Entity gérée)."
    },
    {
      "id": 4,
      "question": "Grâce à la Clean Architecture, comment peut-on tester les règles métier (Use Cases) ?",
      "type": "single_choice",
      "options": [
        "Uniquement avec des tests E2E Selenium.",
        "Avec des Tests Unitaires purs, sans démarrer le Kernel Symfony ni la Base de Données, en mockant les interfaces (Ports).",
        "En déployant sur un environnement de staging.",
        "C'est impossible sans base de données."
      ],
      "correct_answers": [
        "Avec des Tests Unitaires purs, sans démarrer le Kernel Symfony ni la Base de Données, en mockant les interfaces (Ports)."
      ],
      "explanation": "Puisque le métier ne dépend de rien d'externe, il est testable en isolation totale, ce qui est extrêmement rapide."
    },
    {
      "id": 5,
      "question": "Quelles couches composent le schéma en cercles ?",
      "type": "multiple_choice",
      "options": [
        "Domain (Enterprise Business Rules)",
        "Application (Use Cases)",
        "Interface Adapters (Controllers/Presenters/Gateways)",
        "Frameworks & Drivers (Symfony, DB, UI)"
      ],
      "correct_answers": [
        "Domain (Enterprise Business Rules)",
        "Application (Use Cases)",
        "Interface Adapters (Controllers/Presenters/Gateways)",
        "Frameworks & Drivers (Symfony, DB, UI)"
      ],
      "explanation": "Les dépendances vont de l'extérieur vers l'intérieur seulement."
    },
    {
      "id": 6,
      "question": "Quelle structure 'Screaming Architecture' est recommandée ?",
      "type": "single_choice",
      "options": [
        "src/Contexte/Domain, Application, Infrastructure (Controllers/Doctrine/Adapters)",
        "src/Controller, src/Repository uniquement",
        "Tout dans un dossier Services",
        "Un seul namespace App pour tout"
      ],
      "correct_answers": [
        "src/Contexte/Domain, Application, Infrastructure (Controllers/Doctrine/Adapters)"
      ],
      "explanation": "Le dossier crie le domaine, pas le framework."
    },
    {
      "id": 7,
      "question": "Comment appliquer l'Inversion de Dépendance pour un Repository ?",
      "type": "single_choice",
      "options": [
        "Définir l'interface dans le domaine, l'implémenter en infrastructure, et laisser DI injecter l'implémentation",
        "Appeler Doctrine directement dans le use case",
        "Mettre tout dans l'entité",
        "Utiliser un static"
      ],
      "correct_answers": [
        "Définir l'interface dans le domaine, l'implémenter en infrastructure, et laisser DI injecter l'implémentation"
      ],
      "explanation": "Le use case dépend de l'interface (port), pas de Doctrine."
    },
    {
      "id": 8,
      "question": "Quel est le flux Request/Response recommandé ?",
      "type": "multiple_choice",
      "options": [
        "Controller -> DTO Request -> Handler (Use Case) -> Repository (via interface) -> Entities -> DTO Response -> Presenter/Controller -> Response HTTP",
        "Controller -> Entity -> Twig",
        "Controller -> DB directe",
        "Kernel -> Twig"
      ],
      "correct_answers": [
        "Controller -> DTO Request -> Handler (Use Case) -> Repository (via interface) -> Entities -> DTO Response -> Presenter/Controller -> Response HTTP"
      ],
      "explanation": "Les frontières se traversent via DTOs, pas via entités gérées."
    },
    {
      "id": 9,
      "question": "Pourquoi éviter de passer une Entité Doctrine directement à la Vue ?",
      "type": "single_choice",
      "options": [
        "Risque de Lazy Loading inattendu et d'exposition de données sensibles",
        "C'est impossible",
        "Twig ne supporte pas les objets",
        "Doctrine interdit l'accès"
      ],
      "correct_answers": [
        "Risque de Lazy Loading inattendu et d'exposition de données sensibles"
      ],
      "explanation": "Utiliser des DTO/Response Models sécurise les frontières."
    },
    {
      "id": 10,
      "question": "Quels bénéfices clés sont visés ?",
      "type": "multiple_choice",
      "options": [
        "Testabilité (use cases isolés)",
        "Indépendance vis-à-vis du framework/DB/UI",
        "Flexibilité pour remplacer un adapter (Doctrine -> API externe)",
        "Dépendance forte au framework"
      ],
      "correct_answers": [
        "Testabilité (use cases isolés)",
        "Indépendance vis-à-vis du framework/DB/UI",
        "Flexibilité pour remplacer un adapter (Doctrine -> API externe)"
      ],
      "explanation": "L'isolation métier permet de remplacer les détails sans casser le cœur."
    }
  ]
}
