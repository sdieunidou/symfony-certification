{
  "source_file": "10-securite/providers.md",
  "title": "User Providers (Fournisseurs d'utilisateurs)",
  "questions": [
    {
      "id": 1,
      "question": "Quelle est la responsabilité unique d'un `UserProvider` ?",
      "type": "single_choice",
      "options": [
        "Vérifier le mot de passe.",
        "Charger un objet `User` à partir d'un identifiant (email, username).",
        "Gérer l'authentification.",
        "Stocker la session."
      ],
      "correct_answers": [
        "Charger un objet `User` à partir d'un identifiant (email, username)."
      ],
      "explanation": "Le Provider est en lecture seule. Il ne sait pas si le mot de passe est bon ou mauvais."
    },
    {
      "id": 2,
      "question": "Quelle méthode du UserProvider est appelée à chaque requête pour recharger l'utilisateur depuis la session ?",
      "type": "single_choice",
      "options": [
        "`loadUserByIdentifier()`",
        "`refreshUser()`",
        "`reloadUser()`",
        "`checkUser()`"
      ],
      "correct_answers": [
        "`refreshUser()`"
      ],
      "explanation": "Cela garantit que les données de l'utilisateur (rôles, mot de passe) sont toujours à jour. Si les données ont changé, l'utilisateur est déconnecté par sécurité."
    },
    {
      "id": 3,
      "question": "Quel type de Provider permet de chaîner plusieurs sources (ex: chercher d'abord en mémoire, puis en base de données) ?",
      "type": "single_choice",
      "options": [
        "`EntityUserProvider`",
        "`ChainUserProvider`",
        "`MemoryUserProvider`",
        "`LdapUserProvider`"
      ],
      "correct_answers": [
        "`ChainUserProvider`"
      ],
      "explanation": "Il itère sur une liste de providers et s'arrête au premier qui trouve l'utilisateur."
    },
    {
      "id": 4,
      "question": "Pour utiliser une Entité Doctrine comme utilisateur, quel type de provider configurer ?",
      "type": "single_choice",
      "options": [
        "`memory`",
        "`entity`",
        "`database`",
        "`orm`"
      ],
      "correct_answers": [
        "`entity`"
      ],
      "explanation": "On spécifie la classe de l'entité et la propriété à utiliser comme identifiant (ex: email)."
    },
    {
      "id": 5,
      "question": "Quelle méthode remplace l'ancienne `loadUserByUsername` depuis Symfony 5.3 ?",
      "type": "single_choice",
      "options": [
        "`loadUserByEmail`",
        "`loadUserByIdentifier`",
        "`loadUserByLogin`",
        "`getUser`"
      ],
      "correct_answers": [
        "`loadUserByIdentifier`"
      ],
      "explanation": "Le terme 'Identifier' est plus générique que 'Username', s'adaptant aux emails, clés API, téléphones, etc."
    },
    {
      "id": 6,
      "question": "Pourquoi `refreshUser` peut déconnecter un utilisateur ?",
      "type": "single_choice",
      "options": [
        "Si l'utilisateur n'existe plus ou si des données critiques (mot de passe) ont changé",
        "Parce que la session expire",
        "Parce que le provider est en mémoire",
        "Parce que le firewall change"
      ],
      "correct_answers": [
        "Si l'utilisateur n'existe plus ou si des données critiques (mot de passe) ont changé"
      ],
      "explanation": "RefreshUser garantit que l'utilisateur en session est toujours valide."
    },
    {
      "id": 7,
      "question": "Dans un firewall `stateless: true`, `refreshUser` est-il appelé ?",
      "type": "single_choice",
      "options": [
        "Non, car pas de session",
        "Oui, à chaque requête",
        "Uniquement sur les erreurs",
        "Uniquement en prod"
      ],
      "correct_answers": [
        "Non, car pas de session"
      ],
      "explanation": "Stateless signifie pas de stockage du token en session."
    },
    {
      "id": 8,
      "question": "Quel provider utiliser pour des identifiants stockés dans un fichier YAML ?",
      "type": "single_choice",
      "options": [
        "memory",
        "entity",
        "chain",
        "custom"
      ],
      "correct_answers": [
        "memory"
      ],
      "explanation": "Le provider memory permet de définir des utilisateurs en config."
    },
    {
      "id": 9,
      "question": "Comment combiner plusieurs sources utilisateur ?",
      "type": "single_choice",
      "options": [
        "Provider `chain` listant d'autres providers",
        "Dupliquer les users",
        "Utiliser role_hierarchy",
        "Impossible"
      ],
      "correct_answers": [
        "Provider `chain` listant d'autres providers"
      ],
      "explanation": "ChainUserProvider essaie chaque provider dans l'ordre."
    },
    {
      "id": 10,
      "question": "Quelles méthodes obligatoires expose `UserProviderInterface` ?",
      "type": "single_choice",
      "options": [
        "`loadUserByIdentifier`, `refreshUser`, `supportsClass`",
        "`find`, `save`, `delete`",
        "`authenticate`, `authorize`",
        "`hash`, `verify`"
      ],
      "correct_answers": [
        "`loadUserByIdentifier`, `refreshUser`, `supportsClass`"
      ],
      "explanation": "Ce trio couvre chargement initial, rechargement et compatibilité de classe."
    }
  ]
}