{
  "source_file": "10-securite/authentication.md",
  "title": "Authentification (AuthN)",
  "questions": [
    {
      "id": 1,
      "question": "Qu'est-ce que l'authentification (AuthN) ?",
      "type": "single_choice",
      "options": [
        "Vérifier si l'utilisateur a le droit d'accéder à une ressource.",
        "Vérifier l'identité de l'utilisateur (Qui est-ce ?).",
        "Chiffrer le mot de passe.",
        "Créer un compte."
      ],
      "correct_answers": [
        "Vérifier l'identité de l'utilisateur (Qui est-ce ?)."
      ],
      "explanation": "Ne pas confondre avec l'autorisation (AuthZ) qui gère les permissions."
    },
    {
      "id": 2,
      "question": "Comment connecter un utilisateur manuellement (programmatically) dans un contrôleur ?",
      "type": "single_choice",
      "options": [
        "En mettant l'utilisateur en session.",
        "En utilisant `$security->login($user)` (Service `Security` helper).",
        "En créant un token manuellement.",
        "Ce n'est pas possible."
      ],
      "correct_answers": [
        "En utilisant `$security->login($user)` (Service `Security` helper)."
      ],
      "explanation": "Le helper `Security` (Symfony 6.2+) simplifie grandement cette tâche qui nécessitait avant de manipuler le TokenStorage."
    },
    {
      "id": 3,
      "question": "Quel composant natif Symfony permet de limiter les tentatives de login (Brute Force) ?",
      "type": "single_choice",
      "options": [
        "`LoginThrottler`",
        "`RateLimiter` (config `login_throttling`)",
        "`Firewall`",
        "`AntiSpam`"
      ],
      "correct_answers": [
        "`RateLimiter` (config `login_throttling`)"
      ],
      "explanation": "Il se configure directement dans le firewall (`login_throttling: { max_attempts: 3 }`)."
    },
    {
      "id": 4,
      "question": "Qu'est-ce qu'un Entry Point dans le contexte de la sécurité ?",
      "type": "single_choice",
      "options": [
        "La page d'accueil.",
        "Le mécanisme qui décide quoi faire (commencer l'auth) quand un utilisateur anonyme essaie d'accéder à une ressource protégée (ex: Redirection Login).",
        "Le formulaire de connexion.",
        "Le premier firewall."
      ],
      "correct_answers": [
        "Le mécanisme qui décide quoi faire (commencer l'auth) quand un utilisateur anonyme essaie d'accéder à une ressource protégée (ex: Redirection Login)."
      ],
      "explanation": "Chaque firewall a un point d'entrée par défaut (souvent `form_login` -> redirect login)."
    },
    {
      "id": 5,
      "question": "Si vous déconnectez un utilisateur manuellement avec `$security->logout(false)`, que signifie le paramètre `false` ?",
      "type": "single_choice",
      "options": [
        "Ne pas rediriger.",
        "Désactiver la vérification CSRF pour cet appel.",
        "Ne pas invalider la session.",
        "Ne pas effacer le cookie RememberMe."
      ],
      "correct_answers": [
        "Désactiver la vérification CSRF pour cet appel."
      ],
      "explanation": "Par défaut, `logout()` exige un token CSRF valide pour la sécurité."
    },
    {
      "id": 6,
      "question": "Quelle configuration active le throttling natif des tentatives de login ?",
      "type": "single_choice",
      "options": [
        "Dans le firewall: `login_throttling: { max_attempts: 3, interval: '15 minutes' }`",
        "Dans php.ini",
        "Dans le provider",
        "Dans les voters"
      ],
      "correct_answers": [
        "Dans le firewall: `login_throttling: { max_attempts: 3, interval: '15 minutes' }`"
      ],
      "explanation": "S'appuie sur RateLimiter pour limiter par IP/username."
    },
    {
      "id": 7,
      "question": "Quel événement est déclenché lors d'un login interactif réussi ?",
      "type": "single_choice",
      "options": [
        "`SecurityEvents::INTERACTIVE_LOGIN`",
        "`AuthenticationSuccessEvent` uniquement",
        "`LoginEvent`",
        "`TokenCreatedEvent`"
      ],
      "correct_answers": [
        "`SecurityEvents::INTERACTIVE_LOGIN`"
      ],
      "explanation": "Spécifique aux connexions explicites (pas remember-me)."
    },
    {
      "id": 8,
      "question": "Comment déclencher un point d'entrée différent selon le firewall ?",
      "type": "single_choice",
      "options": [
        "Configurer `entry_point` dans le firewall",
        "Impossible, global uniquement",
        "Via access_control",
        "Via role_hierarchy"
      ],
      "correct_answers": [
        "Configurer `entry_point` dans le firewall"
      ],
      "explanation": "Chaque firewall peut définir son AuthenticationEntryPoint."
    },
    {
      "id": 9,
      "question": "En mode stateless, où est stocké le token d'authentification ?",
      "type": "single_choice",
      "options": [
        "Nulle part côté serveur, il doit être envoyé à chaque requête (ex: Bearer/JWT)",
        "En session",
        "En cache système",
        "Dans une cookie CSRF"
      ],
      "correct_answers": [
        "Nulle part côté serveur, il doit être envoyé à chaque requête (ex: Bearer/JWT)"
      ],
      "explanation": "Stateless signifie pas de session ni stockage côté serveur."
    },
    {
      "id": 10,
      "question": "Pourquoi le firewall est souvent configuré `lazy: true` en mode stateful ?",
      "type": "single_choice",
      "options": [
        "Pour ne démarrer la session que si besoin (is_granted/getUser), améliorant perf et cache",
        "Pour retarder l'auth jusqu'après le contrôleur",
        "Pour forcer HTTPS",
        "Pour éviter le CSRF"
      ],
      "correct_answers": [
        "Pour ne démarrer la session que si besoin (is_granted/getUser), améliorant perf et cache"
      ],
      "explanation": "Lazy évite d'ouvrir la session sur les pages publiques."
    }
  ]
}