{
  "source_file": "10-securite/csrf.md",
  "title": "Protection CSRF (Cross-Site Request Forgery)",
  "questions": [
    {
      "id": 1,
      "question": "Comment le mécanisme CSRF de Symfony protège-t-il contre les attaques ?",
      "type": "single_choice",
      "options": [
        "En vérifiant l'adresse IP.",
        "En utilisant un jeton (token) secret unique généré côté serveur, stocké en session, et vérifié lors de la soumission du formulaire.",
        "En chiffrant le formulaire.",
        "En bloquant les requêtes POST."
      ],
      "correct_answers": [
        "En utilisant un jeton (token) secret unique généré côté serveur, stocké en session, et vérifié lors de la soumission du formulaire."
      ],
      "explanation": "L'attaquant ne peut pas connaître ce token, donc sa fausse requête sera rejetée."
    },
    {
      "id": 2,
      "question": "Si vous créez un formulaire HTML manuellement (sans `form_end`), comment inclure le token CSRF ?",
      "type": "single_choice",
      "options": [
        "C'est automatique.",
        "En utilisant la fonction Twig `csrf_token('id_du_token')` dans un champ hidden.",
        "En utilisant `{{ token }}`.",
        "Ce n'est pas nécessaire."
      ],
      "correct_answers": [
        "En utilisant la fonction Twig `csrf_token('id_du_token')` dans un champ hidden."
      ],
      "explanation": "Il faut s'assurer que l'ID du token correspond à celui attendu par le contrôleur (`isCsrfTokenValid`)."
    },
    {
      "id": 3,
      "question": "Quel attribut PHP (Symfony 7.1+) permet de valider automatiquement le token CSRF d'une action de contrôleur ?",
      "type": "single_choice",
      "options": [
        "`#[CsrfCheck]`",
        "`#[IsCsrfTokenValid('id_du_token')]`",
        "`#[Secure]`",
        "`#[ValidateToken]`"
      ],
      "correct_answers": [
        "`#[IsCsrfTokenValid('id_du_token')]`"
      ],
      "explanation": "Cela simplifie le code en retirant la logique de vérification du corps de la méthode."
    },
    {
      "id": 4,
      "question": "Quelle nouveauté de Symfony 7.2 permet d'utiliser la protection CSRF dans des applications Stateless (sans session) ?",
      "type": "single_choice",
      "options": [
        "Le Stateless CSRF (basé sur les headers Origin/Referer et des cookies signés).",
        "Le JWT CSRF.",
        "La désactivation du CSRF.",
        "Le token IP."
      ],
      "correct_answers": [
        "Le Stateless CSRF (basé sur les headers Origin/Referer et des cookies signés)."
      ],
      "explanation": "Cela résout le problème de compatibilité entre la sécurité CSRF et les architectures purement stateless ou le cache HTTP public."
    },
    {
      "id": 5,
      "question": "Comment configurer Symfony pour qu'il utilise des tokens CSRF stateless pour certains formulaires spécifiques (compatible avec le cache HTTP) ?",
      "type": "single_choice",
      "options": [
        "Ce n'est pas possible.",
        "En ajoutant l'ID du token dans la liste `stateless_token_ids` de `framework.yaml`.",
        "En utilisant `csrf_protection: false`.",
        "En utilisant `session: false`."
      ],
      "correct_answers": [
        "En ajoutant l'ID du token dans la liste `stateless_token_ids` de `framework.yaml`."
      ],
      "explanation": "Cela permet de générer des tokens signés qui n'ont pas besoin d'être stockés en session, permettant la mise en cache de la page."
    },
    {
      "id": 6,
      "question": "Pourquoi un formulaire CSRF stateful ne doit pas être placé sur une page cacheable publiquement ?",
      "type": "single_choice",
      "options": [
        "Le token du premier utilisateur serait mis en cache et réutilisé par tous → erreurs CSRF",
        "Parce que le HTML serait chiffré",
        "Parce que le cache invalide la session",
        "Parce que Twig ne permet pas les tokens en cache"
      ],
      "correct_answers": [
        "Le token du premier utilisateur serait mis en cache et réutilisé par tous → erreurs CSRF"
      ],
      "explanation": "Solution : ESI/AJAX ou CSRF stateless."
    },
    {
      "id": 7,
      "question": "Quel champ génère automatiquement un Form Symfony pour le CSRF ?",
      "type": "single_choice",
      "options": [
        "`_token`",
        "`csrf`",
        "`_csrf`",
        "`token_csrf`"
      ],
      "correct_answers": [
        "`_token`"
      ],
      "explanation": "Nom configurable via `csrf_field_name`."
    },
    {
      "id": 8,
      "question": "Quelle fonction Twig génère un token CSRF ?",
      "type": "single_choice",
      "options": [
        "`csrf_token('id')`",
        "`token_csrf()`",
        "`csrf()`",
        "`form_csrf('id')`"
      ],
      "correct_answers": [
        "`csrf_token('id')`"
      ],
      "explanation": "Elle doit matcher l'ID utilisé côté contrôleur."
    },
    {
      "id": 9,
      "question": "Quel attribut PHP valide automatiquement un token CSRF avant d'exécuter l'action ?",
      "type": "single_choice",
      "options": [
        "`#[IsCsrfTokenValid('id', tokenKey: 'token')]`",
        "`#[CsrfCheck]`",
        "`#[ValidateCsrf]`",
        "`#[CheckToken]`"
      ],
      "correct_answers": [
        "`#[IsCsrfTokenValid('id', tokenKey: 'token')]`"
      ],
      "explanation": "Introduit en Symfony 7.1."
    },
    {
      "id": 10,
      "question": "Quelle différence entre CSRF et XSS ?",
      "type": "single_choice",
      "options": [
        "CSRF force une requête authentifiée; XSS injecte du script dans la page pour voler des infos",
        "Aucune",
        "CSRF est côté serveur uniquement",
        "XSS est protégé par CSRF"
      ],
      "correct_answers": [
        "CSRF force une requête authentifiée; XSS injecte du script dans la page pour voler des infos"
      ],
      "explanation": "Les protections et impacts diffèrent."
    }
  ]
}