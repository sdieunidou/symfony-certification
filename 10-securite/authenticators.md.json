{
  "source_file": "10-securite/authenticators.md",
  "title": "Authenticators, Passports et Badges",
  "questions": [
    {
      "id": 1,
      "question": "Quel est le rôle principal d'un `Passport` dans Symfony Security ?",
      "type": "single_choice",
      "options": [
        "Vérifier le mot de passe directement.",
        "Transporter les données d'authentification (User, Credentials, Badges) entre l'Authenticator et l'AuthenticationManager.",
        "Stocker la session utilisateur.",
        "Gérer les rôles."
      ],
      "correct_answers": [
        "Transporter les données d'authentification (User, Credentials, Badges) entre l'Authenticator et l'AuthenticationManager."
      ],
      "explanation": "C'est un DTO (Data Transfer Object) qui contient des Badges."
    },
    {
      "id": 2,
      "question": "Quelle est la différence entre `Passport` et `SelfValidatingPassport` ?",
      "type": "single_choice",
      "options": [
        "Aucune.",
        "`Passport` nécessite un badge de type Credentials (ex: Password), alors que `SelfValidatingPassport` n'en a pas besoin.",
        "`SelfValidatingPassport` valide automatiquement les formulaires.",
        "`Passport` est déprécié."
      ],
      "correct_answers": [
        "`Passport` nécessite un badge de type Credentials (ex: Password), alors que `SelfValidatingPassport` n'en a pas besoin."
      ],
      "explanation": "Utilisez SelfValidatingPassport pour les API Tokens ou OAuth où la simple présence du token valide suffit."
    },
    {
      "id": 3,
      "question": "À quoi servent les 'Attributes' d'un Passport (`setAttribute`) ?",
      "type": "single_choice",
      "options": [
        "À définir des attributs HTML.",
        "À stocker des données arbitraires (ex: scopes, ip) dans le Passport pour les transmettre à la méthode `createToken` ou aux listeners.",
        "À configurer les attributs de session.",
        "À rien."
      ],
      "correct_answers": [
        "À stocker des données arbitraires (ex: scopes, ip) dans le Passport pour les transmettre à la méthode `createToken` ou aux listeners."
      ],
      "explanation": "C'est un moyen de passer de l'information contextuelle de la phase d'authentification à la phase de création du token."
    },
    {
      "id": 4,
      "question": "Quel Badge est **obligatoire** dans tous les Passports ?",
      "type": "single_choice",
      "options": [
        "`PasswordCredentials`",
        "`UserBadge`",
        "`CsrfTokenBadge`",
        "`RememberMeBadge`"
      ],
      "correct_answers": [
        "`UserBadge`"
      ],
      "explanation": "Il faut toujours identifier *qui* essaie de se connecter."
    },
    {
      "id": 5,
      "question": "Quel interface un Authenticator doit-il implémenter pour gérer la redirection des utilisateurs non authentifiés (le démarrage de l'auth) ?",
      "type": "single_choice",
      "options": [
        "`AuthenticationEntryPointInterface`",
        "`StartableInterface`",
        "`RedirectInterface`",
        "`LoginInterface`"
      ],
      "correct_answers": [
        "`AuthenticationEntryPointInterface`"
      ],
      "explanation": "La méthode `start()` de cette interface est appelée par le `ExceptionListener` quand un utilisateur anonyme accède à une ressource protégée."
    },
    {
      "id": 6,
      "question": "Si vous voulez afficher un message d'erreur spécifique à l'utilisateur lors de l'échec de l'authentification, quelle exception lever ?",
      "type": "single_choice",
      "options": [
        "`AuthenticationException`",
        "`CustomUserMessageAuthenticationException`",
        "`AccessDeniedException`",
        "`UserNotFoundException`"
      ],
      "correct_answers": [
        "`CustomUserMessageAuthenticationException`"
      ],
      "explanation": "Cette exception permet de définir un message sûr ('safe') qui sera affiché à l'utilisateur (via `Security::AUTHENTICATION_ERROR`)."
    }
  ]
}