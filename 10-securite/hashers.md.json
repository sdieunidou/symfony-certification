{
  "source_file": "10-securite/hashers.md",
  "title": "Hacheurs de Mots de Passe (Password Hashers)",
  "questions": [
    {
      "id": 1,
      "question": "Quel algorithme Symfony choisit-il par défaut avec la configuration `algorithm: auto` ?",
      "type": "single_choice",
      "options": [
        "MD5",
        "SHA-256",
        "Le meilleur disponible sur le système (Sodium/Argon2id ou Bcrypt).",
        "Plaintext"
      ],
      "correct_answers": [
        "Le meilleur disponible sur le système (Sodium/Argon2id ou Bcrypt)."
      ],
      "explanation": "Cela garantit l'utilisation des standards de sécurité les plus récents sans changer la config."
    },
    {
      "id": 2,
      "question": "Faut-il gérer le sel (salt) manuellement avec les algorithmes modernes (Bcrypt, Sodium) ?",
      "type": "single_choice",
      "options": [
        "Oui, il faut une colonne `salt` en base de données.",
        "Non, le sel est généré aléatoirement et inclus dans le hash résultant. La méthode `getSalt()` est inutile.",
        "Oui, mais seulement pour les admins.",
        "Ça dépend de la version de PHP."
      ],
      "correct_answers": [
        "Non, le sel est généré aléatoirement et inclus dans le hash résultant. La méthode `getSalt()` est inutile."
      ],
      "explanation": "Les algos modernes sont 'auto-salted'."
    },
    {
      "id": 3,
      "question": "Quelle interface permet de mettre à jour automatiquement le hash d'un utilisateur si l'algorithme change (Password Migration) ?",
      "type": "single_choice",
      "options": [
        "`PasswordAuthenticatedUserInterface`",
        "`PasswordUpgraderInterface` (implémentée par le UserProvider/Repository).",
        "`UserInterface`",
        "`HasherInterface`"
      ],
      "correct_answers": [
        "`PasswordUpgraderInterface` (implémentée par le UserProvider/Repository)."
      ],
      "explanation": "Lorsqu'un utilisateur se connecte avec un vieux hash (ex: md5), Symfony détecte qu'il peut être amélioré, re-hache le mot de passe (qu'il a en clair à ce moment précis) et appelle `upgradePassword`."
    },
    {
      "id": 4,
      "question": "Quelle interface de service utiliser pour hacher un mot de passe dans un contrôleur ?",
      "type": "single_choice",
      "options": [
        "`UserPasswordHasherInterface`",
        "`EncoderInterface` (Déprécié)",
        "`HashInterface`",
        "`Security`"
      ],
      "correct_answers": [
        "`UserPasswordHasherInterface`"
      ],
      "explanation": "La méthode `hashPassword($user, $plainPassword)` gère tout."
    },
    {
      "id": 5,
      "question": "Si vous devez utiliser des algorithmes de hachage différents selon l'utilisateur (ex: Argon2 pour Admin, Bcrypt pour User), quelle interface l'entité User doit-elle implémenter ?",
      "type": "single_choice",
      "options": [
        "`PasswordHasherAwareInterface`",
        "`NamedHasherInterface`",
        "`DynamicHasherInterface`",
        "`MultiHashInterface`"
      ],
      "correct_answers": [
        "`PasswordHasherAwareInterface`"
      ],
      "explanation": "Cette interface oblige à implémenter `getPasswordHasherName()` qui retourne le nom du hasher configuré dans `security.yaml`."
    },
    {
      "id": 6,
      "question": "Comment configurer une migration de hash depuis md5 vers un algo moderne ?",
      "type": "single_choice",
      "options": [
        "Avec `migrate_from` dans `password_hashers` (md5 -> auto)",
        "En supprimant les anciens mots de passe",
        "En stockant en clair",
        "Impossible"
      ],
      "correct_answers": [
        "Avec `migrate_from` dans `password_hashers` (md5 -> auto)"
      ],
      "explanation": "Associé à `PasswordUpgraderInterface`, cela met à jour au login."
    },
    {
      "id": 7,
      "question": "Pourquoi réduire le coût des hashers en environnement de test ?",
      "type": "single_choice",
      "options": [
        "Pour accélérer la suite de tests",
        "Pour plus de sécurité",
        "Pour empêcher le login",
        "Pour chiffrer les logs"
      ],
      "correct_answers": [
        "Pour accélérer la suite de tests"
      ],
      "explanation": "On baisse cost/time_cost/memory_cost dans `config/packages/test/security.yaml`."
    },
    {
      "id": 8,
      "question": "Quelle interface doit implémenter une entité User qui a un mot de passe stocké ?",
      "type": "single_choice",
      "options": [
        "`PasswordAuthenticatedUserInterface`",
        "`HasherInterface`",
        "`Encryptable`",
        "`AuthUser`"
      ],
      "correct_answers": [
        "`PasswordAuthenticatedUserInterface`"
      ],
      "explanation": "Elle expose getPassword pour le hasher."
    },
    {
      "id": 9,
      "question": "Pourquoi ne jamais utiliser md5/sha1 pour les mots de passe ?",
      "type": "single_choice",
      "options": [
        "Algorithmes rapides vulnérables au brute-force, non salés",
        "Incompatibles PHP 8",
        "Parce qu'ils génèrent des collisions sur les emails",
        "Parce qu'ils ne sont pas disponibles sur Windows"
      ],
      "correct_answers": [
        "Algorithmes rapides vulnérables au brute-force, non salés"
      ],
      "explanation": "Toujours utiliser des algos lents adaptés à la résistance GPU/ASIC."
    },
    {
      "id": 10,
      "question": "Quel attribut permet d'injecter un hasher nommé dans un service (Symfony 7.4+) ?",
      "type": "single_choice",
      "options": [
        "`#[Target('my_hasher_name')] PasswordHasherInterface $hasher`",
        "`#[Hasher('my_hasher_name')]`",
        "`#[Named('hasher')]`",
        "Impossible"
      ],
      "correct_answers": [
        "`#[Target('my_hasher_name')] PasswordHasherInterface $hasher`"
      ],
      "explanation": "L'attribut Target permet de sélectionner le hasher nommé."
    }
  ]
}