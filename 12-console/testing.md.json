{
  "source_file": "12-console/testing.md",
  "title": "Tester les Commandes",
  "questions": [
    {
      "id": 1,
      "question": "Quelle classe utilitaire Symfony fournit-il pour tester une commande de manière isolée (Test Unitaire/Intégration) ?",
      "type": "single_choice",
      "options": [
        "`CommandTester`",
        "`ApplicationTester`",
        "`ConsoleTester`",
        "`ProcessTester`"
      ],
      "correct_answers": [
        "`CommandTester`"
      ],
      "explanation": "`CommandTester` est conçu pour wrapper une instance de `Command`, exécuter sa méthode `execute` et capturer l'entrée/sortie."
    },
    {
      "id": 2,
      "question": "Pourquoi faut-il souvent utiliser `$application->find('nom:commande')` dans un test plutôt que d'instancier `new MaCommande()` directement ?",
      "type": "single_choice",
      "options": [
        "Parce que c'est plus court.",
        "Pour que la commande soit correctement initialisée avec ses dépendances injectées par le conteneur de services.",
        "Parce que le constructeur est privé.",
        "Pour vérifier que le nom de la commande est correct."
      ],
      "correct_answers": [
        "Pour que la commande soit correctement initialisée avec ses dépendances injectées par le conteneur de services."
      ],
      "explanation": "Si vous faites `new MaCommande()`, vous devez passer les dépendances manuellement. Passer par `$application->find()` (après un bootKernel) récupère la version configurée dans le conteneur."
    },
    {
      "id": 3,
      "question": "Quelle assertion permet de vérifier que la commande s'est terminée sans erreur (code de sortie 0) ?",
      "type": "single_choice",
      "options": [
        "`$this->assertTrue($tester->isSuccessful())`",
        "`$commandTester->assertCommandIsSuccessful()`",
        "`$this->assertEquals(0, $tester->getStatusCode())`",
        "Toutes les réponses ci-dessus."
      ],
      "correct_answers": [
        "`$commandTester->assertCommandIsSuccessful()`"
      ],
      "explanation": "`assertCommandIsSuccessful()` est la méthode d'assertion dédiée fournie par `CommandTester` (depuis Symfony 4/5)."
    },
    {
      "id": 4,
      "question": "Comment passer une option booléenne (ex: `--admin`) à la méthode `execute` du `CommandTester` ?",
      "type": "single_choice",
      "options": [
        "`['--admin']`",
        "`['--admin' => true]`",
        "`['--admin' => 'yes']`",
        "`['admin' => true]`"
      ],
      "correct_answers": [
        "`['--admin' => true]`"
      ],
      "explanation": "Le tableau d'input de `execute` attend les noms des options comme clés et `true` comme valeur pour les options booléennes (`VALUE_NONE`)."
    },
    {
      "id": 5,
      "question": "Quelle est la différence d'usage entre `CommandTester` et `ApplicationTester` ?",
      "type": "single_choice",
      "options": [
        "C'est la même chose.",
        "`CommandTester` teste une commande isolée, `ApplicationTester` teste toute l'application console (utile pour tester l'enchaînement ou les listeners globaux).",
        "`ApplicationTester` est déprécié.",
        "`CommandTester` ne fonctionne qu'avec PHPUnit."
      ],
      "correct_answers": [
        "`CommandTester` teste une commande isolée, `ApplicationTester` teste toute l'application console (utile pour tester l'enchaînement ou les listeners globaux)."
      ],
      "explanation": "Utilisez `CommandTester` dans 99% des cas."
    },
    {
      "id": 6,
      "question": "Que faut-il faire avec `Application` quand on utilise `ApplicationTester` pour éviter un `exit()` ?",
      "type": "single_choice",
      "options": [
        "Appeler `$application->setAutoExit(false);`",
        "Appeler `$application->disableExit();`",
        "Mettre APP_DEBUG=1",
        "Rien, il n'y a pas d'exit"
      ],
      "correct_answers": [
        "Appeler `$application->setAutoExit(false);`"
      ],
      "explanation": "Sinon l'exécution de tests serait interrompue par un exit."
    },
    {
      "id": 7,
      "question": "Pourquoi préférer récupérer la commande via `$application->find()` dans un test KernelTestCase ?",
      "type": "single_choice",
      "options": [
        "Pour obtenir l'instance initialisée par le conteneur (dépendances injectées)",
        "Pour aller plus vite",
        "Parce que new est interdit",
        "Parce que CommandTester l'exige"
      ],
      "correct_answers": [
        "Pour obtenir l'instance initialisée par le conteneur (dépendances injectées)"
      ],
      "explanation": "find() retourne la commande service déjà autowirée."
    },
    {
      "id": 8,
      "question": "Comment tester un input interactif avec CommandTester ?",
      "type": "single_choice",
      "options": [
        "Passer `inputs: ['yes', '42']` au constructeur CommandTester",
        "Impossible",
        "En utilisant `$io->ask()`",
        "En mockant STDIN"
      ],
      "correct_answers": [
        "Passer `inputs: ['yes', '42']` au constructeur CommandTester"
      ],
      "explanation": "CommandTester accepte un tableau d'entrées simulées."
    },
    {
      "id": 9,
      "question": "Comment tester facilement le display généré par une commande ?",
      "type": "single_choice",
      "options": [
        "Avec `$commandTester->getDisplay()` et des assertions sur le texte",
        "En lisant STDOUT réel",
        "Impossible",
        "En utilisant var_dump"
      ],
      "correct_answers": [
        "Avec `$commandTester->getDisplay()` et des assertions sur le texte"
      ],
      "explanation": "getDisplay capture la sortie de la commande pour assertions."
    },
    {
      "id": 10,
      "question": "Comment tester qu'une commande échoue avec un code de sortie particulier ?",
      "type": "single_choice",
      "options": [
        "Vérifier `$commandTester->getStatusCode()` ou `assertSame(Command::FAILURE, ...)`",
        "Impossible",
        "En lisant un fichier log",
        "En lançant une exception"
      ],
      "correct_answers": [
        "Vérifier `$commandTester->getStatusCode()` ou `assertSame(Command::FAILURE, ...)`"
      ],
      "explanation": "Le status code est accessible après execute()."
    }
  ]
}