{
  "source_file": "11-cache/http-sessions.md",
  "title": "Cache HTTP et Sessions Utilisateur",
  "questions": [
    {
      "id": 1,
      "question": "Pourquoi le cache HTTP public et les sessions utilisateur sont-ils généralement incompatibles ?",
      "type": "single_choice",
      "options": [
        "Car les sessions utilisent trop de mémoire.",
        "Car le cache public sert le même contenu à tout le monde, alors que la session personnalise le contenu pour un utilisateur unique.",
        "Car le protocole HTTP interdit les deux simultanément.",
        "Car Symfony ne supporte pas les sessions en mode production."
      ],
      "correct_answers": [
        "Car le cache public sert le même contenu à tout le monde, alors que la session personnalise le contenu pour un utilisateur unique."
      ],
      "explanation": "Si une page personnalisée (ex: 'Bonjour Seb') est mise en cache public, tous les visiteurs verront 'Bonjour Seb', ce qui est une faille de sécurité."
    },
    {
      "id": 2,
      "question": "Que fait Symfony par défaut lorsqu'une session est démarrée pendant le traitement d'une requête ?",
      "type": "single_choice",
      "options": [
        "Il désactive la session.",
        "Il rend la réponse `private` et non-cacheable (`must-revalidate`, `max-age=0`) pour éviter les fuites d'informations.",
        "Il force la réponse en `public`.",
        "Il supprime tous les cookies."
      ],
      "correct_answers": [
        "Il rend la réponse `private` et non-cacheable (`must-revalidate`, `max-age=0`) pour éviter les fuites d'informations."
      ],
      "explanation": "C'est une sécurité par défaut pour empêcher qu'une réponse contenant des données de session ne finisse dans un cache partagé."
    },
    {
      "id": 3,
      "question": "Quelle technique permet d'avoir une page majoritairement en cache public tout en affichant des données utilisateur (comme le nom du connecté) ?",
      "type": "multiple_choice",
      "options": [
        "Utiliser les ESI (Edge Side Includes) pour charger le bloc utilisateur dynamiquement.",
        "Utiliser AJAX (Hinclude) pour charger les données utilisateur après le chargement de la page.",
        "Désactiver la sécurité des sessions.",
        "Mettre toute la page en cache public et espérer que les utilisateurs ont le même nom."
      ],
      "correct_answers": [
        "Utiliser les ESI (Edge Side Includes) pour charger le bloc utilisateur dynamiquement.",
        "Utiliser AJAX (Hinclude) pour charger les données utilisateur après le chargement de la page."
      ],
      "explanation": "Ces deux techniques (ESI et AJAX) permettent de séparer le contenu statique (cacheable publiquement) du contenu dynamique (privé)."
    },
    {
      "id": 4,
      "question": "Si vous voulez forcer Symfony à ne PAS modifier les headers de cache même si une session est active, que devez-vous faire ?",
      "type": "single_choice",
      "options": [
        "Utiliser `session_destroy()`.",
        "Définir le header `AbstractSessionListener::NO_AUTO_CACHE_CONTROL_HEADER` à `true`.",
        "Configurer `framework.session.enabled: false`.",
        "Ce n'est pas possible, Symfony a toujours raison."
      ],
      "correct_answers": [
        "Définir le header `AbstractSessionListener::NO_AUTO_CACHE_CONTROL_HEADER` à `true`."
      ],
      "explanation": "Ce header spécial instruit le Listener de session de Symfony de ne pas écraser vos directives de cache, vous laissant l'entière responsabilité de la sécurité."
    },
    {
      "id": 5,
      "question": "Pourquoi l'utilisation de `Vary: Cookie` sur une réponse publique est-elle une mauvaise pratique ?",
      "type": "single_choice",
      "options": [
        "Cela provoque des erreurs 500.",
        "Cela rend le cache inefficace car les cookies changent souvent (session, tracking), créant une version de cache par utilisateur au lieu d'une version partagée.",
        "Cela désactive les cookies.",
        "Cela force le navigateur à ne pas stocker la page."
      ],
      "correct_answers": [
        "Cela rend le cache inefficace car les cookies changent souvent (session, tracking), créant une version de cache par utilisateur au lieu d'une version partagée."
      ],
      "explanation": "Le but du cache public est de partager le contenu. `Vary: Cookie` fragmente le cache à l'extrême."
    },
    {
      "id": 6,
      "question": "Que fait Symfony si vous appelez `setPublic()` alors qu'une session est active ?",
      "type": "single_choice",
      "options": [
        "Il respecte `public`, vous êtes responsable d'éviter les données perso",
        "Il force quand même private",
        "Il détruit la session",
        "Il lève une exception"
      ],
      "correct_answers": [
        "Il respecte `public`, vous êtes responsable d'éviter les données perso"
      ],
      "explanation": "SetPublic() écrase le comportement par défaut ; attention aux fuites."
    },
    {
      "id": 7,
      "question": "Quel header spécial désactive l'auto-forçage en private quand une session est utilisée ?",
      "type": "single_choice",
      "options": [
        "`AbstractSessionListener::NO_AUTO_CACHE_CONTROL_HEADER` à true",
        "`X-No-Session`",
        "`Cache-Control: public`",
        "`Vary: Session`"
      ],
      "correct_answers": [
        "`AbstractSessionListener::NO_AUTO_CACHE_CONTROL_HEADER` à true"
      ],
      "explanation": "À utiliser seulement si vous maîtrisez la sécurité de vos headers."
    },
    {
      "id": 8,
      "question": "Quelles techniques permettent d'afficher des données utilisateur sur une page publique cachée ?",
      "type": "multiple_choice",
      "options": [
        "ESI pour isoler le fragment user en privé/non caché",
        "AJAX/Hinclude pour charger après coup",
        "Mettre toute la page en public avec Vary: Cookie",
        "Mettre no-store"
      ],
      "correct_answers": [
        "ESI pour isoler le fragment user en privé/non caché",
        "AJAX/Hinclude pour charger après coup"
      ],
      "explanation": "On sépare le contenu partagé et le contenu spécifique user."
    },
    {
      "id": 9,
      "question": "Pourquoi `private, must-revalidate` est appliqué par défaut dès qu'une session est touchée ?",
      "type": "single_choice",
      "options": [
        "Pour éviter qu'un cache partagé serve des données de session à d'autres utilisateurs",
        "Pour accélérer le site",
        "Pour compatibilité HTTP/1.0",
        "Pour forcer HTTPS"
      ],
      "correct_answers": [
        "Pour éviter qu'un cache partagé serve des données de session à d'autres utilisateurs"
      ],
      "explanation": "Sécurité par défaut contre les leaks via proxy/CDN."
    },
    {
      "id": 10,
      "question": "Quel risque majeur si une page publique met en cache un message 'Bonjour Alice' issu de la session ?",
      "type": "single_choice",
      "options": [
        "Tous les utilisateurs verront 'Bonjour Alice' (fuite de données)",
        "Aucun, les cookies protègent",
        "La page devient private automatiquement",
        "Le cache est vidé"
      ],
      "correct_answers": [
        "Tous les utilisateurs verront 'Bonjour Alice' (fuite de données)"
      ],
      "explanation": "Ne jamais mélanger session et cache public sans isoler le contenu user."
    }
  ]
}