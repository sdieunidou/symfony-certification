{
  "source_file": "11-cache/component-pools.md",
  "title": "Pools de Cache Personnalisés",
  "questions": [
    {
      "id": 1,
      "question": "Quel est l'avantage principal de définir des 'Pools' de cache personnalisés plutôt que d'utiliser le pool global ?",
      "type": "single_choice",
      "options": [
        "Cela permet d'augmenter la taille maximale du cache.",
        "Cela permet d'isoler les données (namespace) et d'utiliser des configurations différentes (ex: Redis pour l'un, Fichier pour l'autre).",
        "Cela permet de contourner le composant Cache de Symfony.",
        "Cela améliore automatiquement le référencement (SEO)."
      ],
      "correct_answers": [
        "Cela permet d'isoler les données (namespace) et d'utiliser des configurations différentes (ex: Redis pour l'un, Fichier pour l'autre)."
      ],
      "explanation": "Les pools personnalisés offrent une isolation (clés préfixées) et une flexibilité de configuration (adapters différents) pour différentes parties de l'application."
    },
    {
      "id": 2,
      "question": "Comment configure-t-on un pool de cache qui utilise l'adaptateur Filesystem dans `framework.yaml` ?",
      "type": "single_choice",
      "options": [
        "En définissant `adapter: cache.adapter.filesystem` sous la clé du pool.",
        "En mettant `type: file`.",
        "En créant un nouveau fichier services.yaml.",
        "Ce n'est pas possible, le Filesystem est réservé au cache système."
      ],
      "correct_answers": [
        "En définissant `adapter: cache.adapter.filesystem` sous la clé du pool."
      ],
      "explanation": "L'option `adapter` permet de spécifier le service d'adaptateur à utiliser, ici `cache.adapter.filesystem`."
    },
    {
      "id": 3,
      "question": "Si vous nommez votre pool `custom_thing.cache` dans la configuration, comment pouvez-vous l'injecter dans un service ?",
      "type": "single_choice",
      "options": [
        "En utilisant le type `CustomThingCache`.",
        "En utilisant l'autowiring avec le nom de variable correspondant en camelCase (ex: `CacheInterface $customThingCache`).",
        "Uniquement via la configuration YAML des services (pas d'autowiring).",
        "En injectant le service global `cache.app`."
      ],
      "correct_answers": [
        "En utilisant l'autowiring avec le nom de variable correspondant en camelCase (ex: `CacheInterface $customThingCache`)."
      ],
      "explanation": "Symfony crée automatiquement un alias autowirable basé sur le nom du pool converti en camelCase."
    },
    {
      "id": 4,
      "question": "Comment Symfony assure-t-il que les clés d'un pool `pool_a` n'écrasent pas celles d'un `pool_b` utilisant le même backend (ex: Redis) ?",
      "type": "single_choice",
      "options": [
        "Il utilise des bases de données Redis différentes (DB 0, DB 1...).",
        "Il préfixe automatiquement les clés avec un Hash du nom du pool (Namespacing).",
        "Il ne l'assure pas, c'est au développeur de gérer les préfixes.",
        "Il vide le cache à chaque changement de pool."
      ],
      "correct_answers": [
        "Il préfixe automatiquement les clés avec un Hash du nom du pool (Namespacing)."
      ],
      "explanation": "Le composant Cache gère le 'namespacing' de manière transparente en préfixant les clés, garantissant l'isolation."
    },
    {
      "id": 5,
      "question": "À quoi sert l'option `default_redis_provider` dans `framework.yaml` ?",
      "type": "single_choice",
      "options": [
        "À installer Redis.",
        "À définir le DSN (connexion) par défaut pour tous les pools qui utilisent l'adapter Redis, évitant de répéter l'URL.",
        "À définir la base de données par défaut.",
        "À définir le mot de passe administrateur."
      ],
      "correct_answers": [
        "À définir le DSN (connexion) par défaut pour tous les pools qui utilisent l'adapter Redis, évitant de répéter l'URL."
      ],
      "explanation": "Si un pool utilise `cache.adapter.redis` sans spécifier de provider, il utilisera celui-ci."
    },
    {
      "id": 6,
      "question": "Comment définir un provider Redis avec options (timeout, retry) pour un pool ?",
      "type": "single_choice",
      "options": [
        "Créer un service provider (factory RedisAdapter::createConnection) et l'indiquer dans `provider:` du pool",
        "Mettre les options dans `default_redis_provider`",
        "Impossible",
        "Les options vont dans services.yaml global"
      ],
      "correct_answers": [
        "Créer un service provider (factory RedisAdapter::createConnection) et l'indiquer dans `provider:` du pool"
      ],
      "explanation": "Permet de passer des options avancées via un service dédié."
    },
    {
      "id": 7,
      "question": "Quel alias autowirable est généré pour un pool nommé `foo.bar.cache` ?",
      "type": "single_choice",
      "options": [
        "`$fooBarCache` (CacheInterface)`",
        "`$foo_bar_cache`",
        "`$foobar`",
        "Aucun alias"
      ],
      "correct_answers": [
        "`$fooBarCache` (CacheInterface)`"
      ],
      "explanation": "Le nom du pool est transformé en camelCase pour l'autowiring."
    },
    {
      "id": 8,
      "question": "Pourquoi créer plusieurs pools plutôt que partager `cache.app` ?",
      "type": "multiple_choice",
      "options": [
        "Isolation des clés et vidage ciblé",
        "Choisir des backends/TTL différents par domaine",
        "Limiter l'impact d'un flush sur d'autres domaines",
        "Augmenter le nombre de commandes cache:clear"
      ],
      "correct_answers": [
        "Isolation des clés et vidage ciblé",
        "Choisir des backends/TTL différents par domaine",
        "Limiter l'impact d'un flush sur d'autres domaines"
      ],
      "explanation": "Pools séparés = isolation fonctionnelle et technique."
    },
    {
      "id": 9,
      "question": "Comment partager un même backend Redis entre plusieurs pools sans collision de clés ?",
      "type": "single_choice",
      "options": [
        "L'isolation est assurée par le préfixe (namespace) généré automatiquement pour chaque pool",
        "Impossible",
        "Utiliser des bases Redis distinctes",
        "Mettre des TTL différents"
      ],
      "correct_answers": [
        "L'isolation est assurée par le préfixe (namespace) généré automatiquement pour chaque pool"
      ],
      "explanation": "Le composant ajoute un hash du nom du pool en préfixe."
    },
    {
      "id": 10,
      "question": "Comment stocker les tags d'un pool tagué dans un autre backend ?",
      "type": "single_choice",
      "options": [
        "En configurant `tags: <nom_du_pool_tags>` dans la définition du pool",
        "Impossible",
        "En ajoutant `tag_provider:` dans .env",
        "En chiffrant les clés"
      ],
      "correct_answers": [
        "En configurant `tags: <nom_du_pool_tags>` dans la définition du pool"
      ],
      "explanation": "Séparer data/tags peut optimiser ou isoler les métadonnées."
    }
  ]
}