{
  "source_file": "11-cache/component-overview.md",
  "title": "Composant Cache : Vue d'ensemble",
  "questions": [
    {
      "id": 1,
      "question": "Quel est le standard (Interface) recommandé par Symfony pour interagir avec le cache ?",
      "type": "single_choice",
      "options": [
        "PSR-6 (CacheItemPoolInterface)",
        "PSR-16 (SimpleCache)",
        "Cache Contracts (`Symfony\\Contracts\\Cache\\CacheInterface` / `ItemInterface`)",
        "Doctrine Cache"
      ],
      "correct_answers": [
        "Cache Contracts (`Symfony\\Contracts\\Cache\\CacheInterface` / `ItemInterface`)"
      ],
      "explanation": "Les Cache Contracts simplifient l'usage (callback pour le recalcul) et intègrent la protection contre le Stampede."
    },
    {
      "id": 2,
      "question": "Quels sont les deux pools de cache configurés par défaut dans `cache.yaml` ?",
      "type": "single_choice",
      "options": [
        "`cache.default` et `cache.user`",
        "`cache.app` (données applicatives) et `cache.system` (fichiers internes framework).",
        "`redis` et `memcached`",
        "`public` et `private`"
      ],
      "correct_answers": [
        "`cache.app` (données applicatives) et `cache.system` (fichiers internes framework)."
      ],
      "explanation": "`cache.system` est optimisé pour la performance (OPcache) et stocke les métadonnées (annotations, etc.)."
    },
    {
      "id": 3,
      "question": "Quel adapter est recommandé pour `cache.system` en production ?",
      "type": "single_choice",
      "options": [
        "`cache.adapter.redis`",
        "`cache.adapter.system` (qui utilise APCu ou PHP Files + OPcache)",
        "`cache.adapter.array`",
        "`cache.adapter.filesystem`"
      ],
      "correct_answers": [
        "`cache.adapter.system` (qui utilise APCu ou PHP Files + OPcache)"
      ],
      "explanation": "Cet adapter est optimisé pour stocker des structures PHP compilées qui ne changent qu'au déploiement."
    },
    {
      "id": 4,
      "question": "Comment utiliser le cache dans un service ?",
      "type": "single_choice",
      "options": [
        "Injecter `CacheInterface` (autowire `cache.app`).",
        "Utiliser `new Redis()`.",
        "Utiliser `$_SESSION`.",
        "Injecter `ContainerInterface`."
      ],
      "correct_answers": [
        "Injecter `CacheInterface` (autowire `cache.app`)."
      ],
      "explanation": "L'autowiring injecte par défaut le pool principal de l'application."
    },
    {
      "id": 5,
      "question": "Quelle est la particularité de l'adapter `cache.adapter.array` ?",
      "type": "single_choice",
      "options": [
        "Il stocke les données en base de données.",
        "Il stocke les données dans la mémoire du processus PHP courant, elles sont perdues à la fin de la requête (utile pour les tests).",
        "Il est très lent.",
        "Il utilise un tableau JSON sur le disque."
      ],
      "correct_answers": [
        "Il stocke les données dans la mémoire du processus PHP courant, elles sont perdues à la fin de la requête (utile pour les tests)."
      ],
      "explanation": "C'est l'adapter idéal pour l'environnement de test (`APP_ENV=test`) pour garantir l'isolation entre les tests."
    },
    {
      "id": 6,
      "question": "Pourquoi est-il déconseillé de remplacer `cache.adapter.system` par Redis ?",
      "type": "single_choice",
      "options": [
        "Parce que system est optimisé pour des fichiers PHP précompilés/OPcache et un accès ultra rapide local",
        "Parce que Redis ne supporte pas PSR-6",
        "Parce que Redis est non persistant",
        "Parce que Symfony l'interdit"
      ],
      "correct_answers": [
        "Parce que system est optimisé pour des fichiers PHP précompilés/OPcache et un accès ultra rapide local"
      ],
      "explanation": "Mettre Redis peut rallonger le boot (I/O réseau) pour les métadonnées internes."
    },
    {
      "id": 7,
      "question": "Quel bénéfice apporte `$cache->get('key', callback)` des Cache Contracts ?",
      "type": "single_choice",
      "options": [
        "Gestion automatique du 'get or compute' avec protection contre le Stampede",
        "Pas de sérialisation",
        "Obligation d'utiliser PSR-6",
        "Suppression des TTL"
      ],
      "correct_answers": [
        "Gestion automatique du 'get or compute' avec protection contre le Stampede"
      ],
      "explanation": "Le callback est exécuté au besoin, avec verrou pour éviter les recalculs concurrents."
    },
    {
      "id": 8,
      "question": "Depuis Symfony 7.1, quel adapter supporte un DSN comme provider supplémentaire ?",
      "type": "single_choice",
      "options": [
        "PDO/DBAL adapter",
        "Array",
        "APCu",
        "Memcached"
      ],
      "correct_answers": [
        "PDO/DBAL adapter"
      ],
      "explanation": "Le provider peut être un DSN pour le cache SQL."
    },
    {
      "id": 9,
      "question": "Quel service est autowiré par défaut quand on tape-hint `CacheInterface` ?",
      "type": "single_choice",
      "options": [
        "`cache.app`",
        "`cache.system`",
        "`cache.default`",
        "Aucun, il faut configurer"
      ],
      "correct_answers": [
        "`cache.app`"
      ],
      "explanation": "CacheInterface mappe au pool applicatif principal."
    },
    {
      "id": 10,
      "question": "Que permet `TagAwareAdapter` au-dessus d'un adapter classique ?",
      "type": "single_choice",
      "options": [
        "Associer des tags à des items pour invalider en masse",
        "Chiffrer les valeurs",
        "Désactiver la sérialisation",
        "Faire du preloading"
      ],
      "correct_answers": [
        "Associer des tags à des items pour invalider en masse"
      ],
      "explanation": "L'invalidation par tags est clé pour les caches de données relationnelles."
    }
  ]
}