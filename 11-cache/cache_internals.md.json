{
  "source_file": "11-cache/cache_internals.md",
  "title": "Cache : Fonctionnement Interne",
  "questions": [
    {
      "id": 1,
      "question": "Quel standard PHP (PSR) définit l'interface `CacheItemPoolInterface` et le concept d'items de cache ?",
      "type": "single_choice",
      "options": [
        "PSR-4",
        "PSR-6",
        "PSR-16",
        "PSR-7"
      ],
      "correct_answers": [
        "PSR-6"
      ],
      "explanation": "PSR-6 est le 'Caching Interface' complet. PSR-16 est le 'Simple Cache' (plus direct)."
    },
    {
      "id": 2,
      "question": "Dans le modèle PSR-6, comment savoir si une donnée a été trouvée dans le cache ?",
      "type": "single_choice",
      "options": [
        "En vérifiant si `$item->get()` retourne null.",
        "En appelant `$item->isHit()`.",
        "Le cache lance une exception si la donnée manque.",
        "En vérifiant `$pool->hasItem($key)` avant."
      ],
      "correct_answers": [
        "En appelant `$item->isHit()`."
      ],
      "explanation": "`isHit()` est la seule méthode fiable, car la valeur stockée pourrait être `null` ou `false` légitimement."
    },
    {
      "id": 3,
      "question": "Quelle fonctionnalité permet de supprimer un groupe d'items de cache en une seule fois sans connaître leurs clés ?",
      "type": "single_choice",
      "options": [
        "Le Versioning.",
        "Les Tags (TagAwareAdapter).",
        "L'expiration.",
        "Le Namespace."
      ],
      "correct_answers": [
        "Les Tags (TagAwareAdapter)."
      ],
      "explanation": "On associe des tags aux items lors de la sauvegarde, puis on appelle `invalidateTags(['mon_tag'])`."
    },
    {
      "id": 4,
      "question": "Quel est l'avantage d'utiliser la méthode `$cache->get()` des Cache Contracts (Symfony) plutôt que le flux PSR-6 standard ?",
      "type": "single_choice",
      "options": [
        "Elle est plus rapide.",
        "Elle gère automatiquement le 'Stampede Protection' (verrouillage) et la logique 'Get or Compute' via un callback.",
        "Elle ne nécessite pas d'adapter.",
        "Elle crypte les données."
      ],
      "correct_answers": [
        "Elle gère automatiquement le 'Stampede Protection' (verrouillage) et la logique 'Get or Compute' via un callback."
      ],
      "explanation": "C'est une abstraction plus robuste pour les environnements à fort trafic."
    },
    {
      "id": 5,
      "question": "Quelle méthode de `CacheItemInterface` définit la durée de validité d'un item ?",
      "type": "single_choice",
      "options": [
        "`$item->ttl(3600)`",
        "`$item->expiresAfter(3600)` (secondes ou DateInterval)",
        "`$item->setExpiration(3600)`",
        "`$item->validFor(3600)`"
      ],
      "correct_answers": [
        "`$item->expiresAfter(3600)` (secondes ou DateInterval)"
      ],
      "explanation": "Il existe aussi `expiresAt(\\DateTimeInterface)` pour une date précise."
    },
    {
      "id": 6,
      "question": "Quel est le rôle du 'Marshaller' dans le composant Cache ?",
      "type": "single_choice",
      "options": [
        "Gérer la connexion Redis.",
        "Sérialiser et désérialiser les valeurs PHP pour qu'elles puissent être stockées.",
        "Vérifier les droits d'accès.",
        "Nettoyer le cache expiré."
      ],
      "correct_answers": [
        "Sérialiser et désérialiser les valeurs PHP pour qu'elles puissent être stockées."
      ],
      "explanation": "Par défaut, le `DefaultMarshaller` utilise `serialize()` de PHP, mais on peut le remplacer (ex: JSON, Encryption)."
    },
    {
      "id": 7,
      "question": "Quelle différence clé entre PSR-6 et PSR-16 dans Symfony ?",
      "type": "single_choice",
      "options": [
        "PSR-6 est orienté objets (Item/Pool), PSR-16 fournit une API simple `get/set` (SimpleCache).",
        "PSR-16 supporte le tagging, PSR-6 non.",
        "PSR-6 est déprécié.",
        "PSR-16 interdit Redis."
      ],
      "correct_answers": [
        "PSR-6 est orienté objets (Item/Pool), PSR-16 fournit une API simple `get/set` (SimpleCache)."
      ],
      "explanation": "Symfony expose les deux, mais recommande les Cache Contracts plus ergonomiques."
    },
    {
      "id": 8,
      "question": "À quoi sert `ChainAdapter` ?",
      "type": "single_choice",
      "options": [
        "À chaîner plusieurs backends (L1/L2) en lecture/écriture",
        "À chiffrer les valeurs",
        "À gérer les tags",
        "À invalider tout le cache"
      ],
      "correct_answers": [
        "À chaîner plusieurs backends (L1/L2) en lecture/écriture"
      ],
      "explanation": "Il permet un cache multi-niveaux : ex Array (RAM) puis Redis (distribué)."
    },
    {
      "id": 9,
      "question": "Que garantit le namespacing des pools ?",
      "type": "single_choice",
      "options": [
        "Qu'une clé d'un pool ne peut écraser celle d'un autre même backend",
        "Le chiffrement",
        "L'absence de sérialisation",
        "La suppression automatique des clés expirées"
      ],
      "correct_answers": [
        "Qu'une clé d'un pool ne peut écraser celle d'un autre même backend"
      ],
      "explanation": "Chaque pool préfixe ses clés (hash) assurant isolation logique."
    },
    {
      "id": 10,
      "question": "Quel risque si vous mettez en cache un objet contenant une ressource non sérialisable (ex: connexion DB) ?",
      "type": "single_choice",
      "options": [
        "Serialization failure et item non stocké",
        "L'objet est tronqué proprement",
        "Symfony convertit en JSON automatiquement",
        "Aucun risque"
      ],
      "correct_answers": [
        "Serialization failure et item non stocké"
      ],
      "explanation": "Les ressources/closures ne sont pas sérialisables : le marshaller échoue, l'item n'est pas écrit."
    }
  ]
}