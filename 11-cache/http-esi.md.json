{
  "source_file": "11-cache/http-esi.md",
  "title": "Edge Side Includes (ESI)",
  "questions": [
    {
      "id": 1,
      "question": "Quel problème principal les ESI (Edge Side Includes) résolvent-ils ?",
      "type": "single_choice",
      "options": [
        "La compression des assets CSS/JS.",
        "Le problème des pages 'mixtes' contenant à la fois du contenu public (cacheable) et privé/dynamique (non cacheable).",
        "L'authentification des utilisateurs via API.",
        "Le routage des requêtes HTTP."
      ],
      "correct_answers": [
        "Le problème des pages 'mixtes' contenant à la fois du contenu public (cacheable) et privé/dynamique (non cacheable)."
      ],
      "explanation": "ESI permet de mettre en cache la structure globale d'une page (ex: layout) tout en insérant dynamiquement des fragments non cachés (ex: panier utilisateur)."
    },
    {
      "id": 2,
      "question": "Quelle fonction Twig utilise-t-on pour intégrer un fragment ESI ?",
      "type": "single_choice",
      "options": [
        "`include()`",
        "`render()`",
        "`render_esi()`",
        "`controller()`"
      ],
      "correct_answers": [
        "`render_esi()`"
      ],
      "explanation": "`render_esi()` génère la balise `<esi:include ... />` si un proxy compatible est détecté, sinon il se comporte comme `render()`."
    },
    {
      "id": 3,
      "question": "Si aucun Reverse Proxy (Gateway Cache) n'est présent ou détecté, que fait `render_esi()` ?",
      "type": "single_choice",
      "options": [
        "Il lance une exception critique.",
        "Il affiche une erreur 404.",
        "Il fonctionne comme un `render()` classique (inclusion synchrone par PHP), assurant le fonctionnement de l'application.",
        "Il laisse la balise `<esi:include>` dans le HTML final."
      ],
      "correct_answers": [
        "Il fonctionne comme un `render()` classique (inclusion synchrone par PHP), assurant le fonctionnement de l'application."
      ],
      "explanation": "C'est le mécanisme de 'Fallback'. L'application continue de fonctionner correctement, simplement sans le bénéfice du cache partiel."
    },
    {
      "id": 4,
      "question": "Pourquoi est-il nécessaire de configurer les `trusted_proxies` pour que ESI fonctionne avec Varnish ?",
      "type": "single_choice",
      "options": [
        "Pour des raisons de sécurité uniquement.",
        "Parce que Symfony supprime par défaut le header `Surrogate-Capability` envoyé par le proxy s'il ne provient pas d'une IP de confiance.",
        "Pour permettre à Varnish de lire les cookies.",
        "Ce n'est pas nécessaire."
      ],
      "correct_answers": [
        "Parce que Symfony supprime par défaut le header `Surrogate-Capability` envoyé par le proxy s'il ne provient pas d'une IP de confiance."
      ],
      "explanation": "Symfony a besoin de voir le header `Surrogate-Capability` pour savoir qu'il peut émettre des tags ESI. Ce header est filtré si l'IP du proxy n'est pas de confiance."
    },
    {
      "id": 5,
      "question": "Quel en-tête HTTP le Reverse Proxy envoie-t-il à Symfony pour annoncer qu'il supporte les ESI ?",
      "type": "single_choice",
      "options": [
        "`ESI-Enabled`",
        "`Surrogate-Capability`",
        "`X-Reverse-Proxy`",
        "`Accept-ESI`"
      ],
      "correct_answers": [
        "`Surrogate-Capability`"
      ],
      "explanation": "C'est ce header (défini par le W3C) qui permet la négociation de contenu pour les surrogates."
    },
    {
      "id": 6,
      "question": "Que devient `render_esi()` si aucun proxy compatible n'est détecté ?",
      "type": "single_choice",
      "options": [
        "Il tombe en fallback et agit comme `render()` côté PHP",
        "Il jette une exception",
        "Il laisse la balise ESI brute",
        "Il retourne 404"
      ],
      "correct_answers": [
        "Il tombe en fallback et agit comme `render()` côté PHP"
      ],
      "explanation": "Le comportement dégradé garantit le fonctionnement sans proxy ESI."
    },
    {
      "id": 7,
      "question": "Pourquoi trop de fragments ESI peuvent-ils dégrader les performances ?",
      "type": "single_choice",
      "options": [
        "Chaque fragment peut déclencher une sous-requête backend si non caché",
        "ESI compresse les réponses",
        "ESI désactive HTTP/2",
        "ESI force le no-cache"
      ],
      "correct_answers": [
        "Chaque fragment peut déclencher une sous-requête backend si non caché"
      ],
      "explanation": "1 requête client peut devenir N sous-requêtes si les fragments ne sont pas en cache."
    },
    {
      "id": 8,
      "question": "Quelle configuration framework active le support ESI côté Symfony ?",
      "type": "single_choice",
      "options": [
        "`framework: esi: { enabled: true }`",
        "`framework: http_cache: esi: true`",
        "`framework: esi: false`",
        "Aucune, c'est par défaut"
      ],
      "correct_answers": [
        "`framework: esi: { enabled: true }`"
      ],
      "explanation": "Il faut activer ESI pour que Symfony génère les balises et gère le surrogate."
    },
    {
      "id": 9,
      "question": "Comment éviter les fuites de données utilisateur dans un fragment ESI ?",
      "type": "single_choice",
      "options": [
        "Mettre le fragment en `private` ou non caché et s'assurer qu'il ne soit pas partagé",
        "Mettre la page principale en private",
        "Désactiver la session",
        "Utiliser no-store sur la page"
      ],
      "correct_answers": [
        "Mettre le fragment en `private` ou non caché et s'assurer qu'il ne soit pas partagé"
      ],
      "explanation": "Le fragment a sa propre politique de cache (setPrivate/headers)."
    },
    {
      "id": 10,
      "question": "Quel prérequis réseau pour que Symfony voit le header `Surrogate-Capability` ?",
      "type": "single_choice",
      "options": [
        "Configurer le proxy dans `trusted_proxies`",
        "Activer Xdebug",
        "Désactiver HTTPS",
        "Utiliser HTTP/3"
      ],
      "correct_answers": [
        "Configurer le proxy dans `trusted_proxies`"
      ],
      "explanation": "Sinon le header est filtré et ESI ne sera pas activé."
    }
  ]
}