{
  "source_file": "11-cache/http-server-side.md",
  "title": "Symfony Reverse Proxy (HttpCache)",
  "questions": [
    {
      "id": 1,
      "question": "Qu'est-ce que le composant `HttpCache` de Symfony ?",
      "type": "single_choice",
      "options": [
        "Un système de cache de base de données.",
        "Un Reverse Proxy écrit en PHP qui se comporte comme un Gateway Cache (ex: Varnish).",
        "Un outil pour minifier les fichiers CSS et JS.",
        "Un client HTTP pour faire des requêtes externes."
      ],
      "correct_answers": [
        "Un Reverse Proxy écrit en PHP qui se comporte comme un Gateway Cache (ex: Varnish)."
      ],
      "explanation": "`HttpCache` est un reverse proxy intégré à Symfony, écrit en PHP, capable de gérer le cache HTTP et les ESI sans infrastructure tierce."
    },
    {
      "id": 2,
      "question": "Comment active-t-on le Reverse Proxy de Symfony en production (Symfony Flex / moderne) ?",
      "type": "single_choice",
      "options": [
        "En installant le bundle `sensio/framework-extra-bundle`.",
        "En configurant `framework.http_cache: true` dans `config/packages/framework.yaml`.",
        "En décommentant une ligne dans le fichier `.env`.",
        "Il est activé par défaut et ne peut pas être désactivé."
      ],
      "correct_answers": [
        "En configurant `framework.http_cache: true` dans `config/packages/framework.yaml`."
      ],
      "explanation": "C'est la méthode de configuration standard depuis les versions récentes de Symfony."
    },
    {
      "id": 3,
      "question": "Quel en-tête HTTP permet de déboguer l'état du cache Symfony (HIT, MISS, STALE) ?",
      "type": "single_choice",
      "options": [
        "`X-Cache-Debug`",
        "`X-Symfony-Cache`",
        "`Server-Timing`",
        "`Cache-Status`"
      ],
      "correct_answers": [
        "`X-Symfony-Cache`"
      ],
      "explanation": "Le header `X-Symfony-Cache` fournit des informations précieuses sur le traitement de la requête par le reverse proxy interne."
    },
    {
      "id": 4,
      "question": "Quelle est la principale différence de performance entre Symfony HttpCache et Varnish ?",
      "type": "single_choice",
      "options": [
        "Symfony HttpCache est plus rapide car il est intégré.",
        "Varnish est beaucoup plus performant car écrit en C et gérant le cache en RAM, alors que Symfony HttpCache instancie PHP à chaque requête.",
        "Ils ont des performances identiques.",
        "Symfony HttpCache ne supporte pas la charge."
      ],
      "correct_answers": [
        "Varnish est beaucoup plus performant car écrit en C et gérant le cache en RAM, alors que Symfony HttpCache instancie PHP à chaque requête."
      ],
      "explanation": "Bien que Symfony HttpCache soit efficace (x10 vs app), Varnish reste la référence pour les très forts trafics."
    },
    {
      "id": 5,
      "question": "Pourquoi est-il critique de configurer `trusted_proxies` lorsqu'on utilise un Reverse Proxy ?",
      "type": "single_choice",
      "options": [
        "Pour que Symfony puisse authentifier le proxy.",
        "Pour que Symfony fasse confiance aux en-têtes comme `X-Forwarded-For` et restaure la véritable IP du client au lieu de celle du proxy.",
        "Pour activer la compression GZIP.",
        "Pour permettre l'utilisation du protocole HTTPS."
      ],
      "correct_answers": [
        "Pour que Symfony fasse confiance aux en-têtes comme `X-Forwarded-For` et restaure la véritable IP du client au lieu de celle du proxy."
      ],
      "explanation": "Sans cela, l'application verra l'IP du proxy comme IP cliente, ce qui fausse les logs, la sécurité et les fonctionnalités géo-dépendantes."
    },
    {
      "id": 6,
      "question": "Que contrôle l'option `trace_level` dans la configuration de `http_cache` ?",
      "type": "single_choice",
      "options": [
        "La quantité de logs écrits sur le disque.",
        "La verbosité du header `X-Symfony-Cache` (none, short, full).",
        "Le niveau de compression.",
        "Le temps de trace des requêtes."
      ],
      "correct_answers": [
        "La verbosité du header `X-Symfony-Cache` (none, short, full)."
      ],
      "explanation": "`full` ajoute des détails sur le corps de la réponse, `short` donne juste HIT/MISS."
    },
    {
      "id": 7,
      "question": "Où le reverse proxy Symfony stocke-t-il son cache par défaut ?",
      "type": "single_choice",
      "options": [
        "`var/cache/<env>/http_cache`",
        "En mémoire partagée",
        "Dans Redis",
        "Dans /tmp/http"
      ],
      "correct_answers": [
        "`var/cache/<env>/http_cache`"
      ],
      "explanation": "Le store par défaut est un filesystem store sous var/cache."
    },
    {
      "id": 8,
      "question": "Comment purger le cache du reverse proxy Symfony côté HTTP ?",
      "type": "single_choice",
      "options": [
        "En envoyant une requête PURGE (configurée) vers le proxy",
        "En exécutant cache:clear",
        "Impossible",
        "En supprimant var/log"
      ],
      "correct_answers": [
        "En envoyant une requête PURGE (configurée) vers le proxy"
      ],
      "explanation": "HttpCache supporte les PURGE pour invalider une ressource."
    },
    {
      "id": 9,
      "question": "Quel header d'annonce du proxy active le support ESI côté Symfony ?",
      "type": "single_choice",
      "options": [
        "`Surrogate-Capability`",
        "`X-Proxy`",
        "`Accept-Encoding`",
        "`Cache-Status`"
      ],
      "correct_answers": [
        "`Surrogate-Capability`"
      ],
      "explanation": "Sans ce header (et trusted_proxies), Symfony ne génère pas de balises ESI."
    },
    {
      "id": 10,
      "question": "Pourquoi HttpCache reste moins performant que Varnish pour du très haut trafic ?",
      "type": "single_choice",
      "options": [
        "HttpCache instancie PHP à chaque requête, Varnish est en C et garde tout en RAM",
        "HttpCache ne supporte pas les ESI",
        "HttpCache ne gère pas les 304",
        "Varnish chiffre les réponses"
      ],
      "correct_answers": [
        "HttpCache instancie PHP à chaque requête, Varnish est en C et garde tout en RAM"
      ],
      "explanation": "D'où la préférence pour Varnish/CDN en haute charge."
    }
  ]
}