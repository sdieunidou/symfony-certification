{
  "source_file": "11-cache/component-features.md",
  "title": "Fonctionnalités Avancées du Cache",
  "questions": [
    {
      "id": 1,
      "question": "Qu'est-ce que le Chain Cache (Chaînage) ?",
      "type": "single_choice",
      "options": [
        "Un cache qui crypte les données.",
        "Une combinaison de plusieurs adapters (ex: Array + Redis) où la lecture se fait en cascade (L1 -> L2) et l'écriture partout.",
        "Un cache blockchain.",
        "Un cache qui ne stocke que des chaînes de caractères."
      ],
      "correct_answers": [
        "Une combinaison de plusieurs adapters (ex: Array + Redis) où la lecture se fait en cascade (L1 -> L2) et l'écriture partout."
      ],
      "explanation": "Cela permet d'avoir la vitesse de la mémoire locale (L1) et la persistance/partage de Redis (L2)."
    },
    {
      "id": 2,
      "question": "Quel est l'avantage d'utiliser des Tags de cache ?",
      "type": "single_choice",
      "options": [
        "Améliorer le SEO.",
        "Permettre d'invalider un groupe d'items liés (ex: tous les articles d'une catégorie) sans connaître leurs clés individuelles.",
        "Rendre le cache plus rapide.",
        "Trier les items."
      ],
      "correct_answers": [
        "Permettre d'invalider un groupe d'items liés (ex: tous les articles d'une catégorie) sans connaître leurs clés individuelles."
      ],
      "explanation": "C'est essentiel pour gérer l'invalidation dans les applications complexes."
    },
    {
      "id": 3,
      "question": "Peut-on chiffrer les données stockées dans le cache ?",
      "type": "single_choice",
      "options": [
        "Non.",
        "Oui, en utilisant un Marshaller chiffré (ex: `SodiumMarshaller`) pour décorer l'adapter.",
        "Oui, mais seulement avec Redis.",
        "Seulement en HTTPS."
      ],
      "correct_answers": [
        "Oui, en utilisant un Marshaller chiffré (ex: `SodiumMarshaller`) pour décorer l'adapter."
      ],
      "explanation": "Cela protège les données sensibles (GDPR) en cas de compromission du serveur de cache."
    },
    {
      "id": 4,
      "question": "Pour utiliser les tags, quelle condition l'adapter doit-il respecter ?",
      "type": "single_choice",
      "options": [
        "Il doit implémenter `TagAwareAdapterInterface` ou être enveloppé dans un `TagAwareAdapter`.",
        "Il doit être Redis.",
        "Il doit avoir une base de données relationnelle.",
        "Il n'y a pas de condition."
      ],
      "correct_answers": [
        "Il doit implémenter `TagAwareAdapterInterface` ou être enveloppé dans un `TagAwareAdapter`."
      ],
      "explanation": "Redis a un support natif (rapide), mais on peut ajouter le support des tags à n'importe quel adapter (Filesystem, etc.) via le wrapper générique."
    },
    {
      "id": 5,
      "question": "Que se passe-t-il lors d'une lecture avec un ChainAdapter (Array + Redis) ?",
      "type": "single_choice",
      "options": [
        "Il lit toujours Redis",
        "Il lit d'abord l'ArrayAdapter (L1), puis remplit L1 depuis Redis si hit en L2",
        "Il lit uniquement l'ArrayAdapter",
        "Il lit en parallèle les deux"
      ],
      "correct_answers": [
        "Il lit d'abord l'ArrayAdapter (L1), puis remplit L1 depuis Redis si hit en L2"
      ],
      "explanation": "Le chaînage sert à avoir un cache chaud en RAM process."
    },
    {
      "id": 6,
      "question": "Pourquoi chiffrer avec `SodiumMarshaller` ne chiffre-t-il pas les clés ?",
      "type": "single_choice",
      "options": [
        "Les clés restent en clair, seule la valeur est chiffrée; fuite de métadonnées possible",
        "Parce que c'est inutile",
        "Parce que les clés sont déjà hashées",
        "Parce que les clés sont stockées en base"
      ],
      "correct_answers": [
        "Les clés restent en clair, seule la valeur est chiffrée; fuite de métadonnées possible"
      ],
      "explanation": "Attention aux informations sensibles dans les noms de clés."
    },
    {
      "id": 7,
      "question": "Comment stocker les tags dans un pool séparé ?",
      "type": "single_choice",
      "options": [
        "En configurant `tags: autre_pool` dans la définition du pool tagué",
        "Impossible",
        "En mettant `provider: tags`",
        "En utilisant un autre marshaller"
      ],
      "correct_answers": [
        "En configurant `tags: autre_pool` dans la définition du pool tagué"
      ],
      "explanation": "Permet de séparer données et métadonnées de tags."
    },
    {
      "id": 8,
      "question": "Pourquoi la TTL d'un item taggé doit-elle être gérée avec prudence ?",
      "type": "single_choice",
      "options": [
        "Un item expiré reste référencé par ses tags jusqu'à cleanup",
        "Les tags expirent toujours avant l'item",
        "Les tags désactivent la TTL",
        "La TTL n'est pas supportée"
      ],
      "correct_answers": [
        "Un item expiré reste référencé par ses tags jusqu'à cleanup"
      ],
      "explanation": "Comprendre l'implémentation évite les fuites de références."
    },
    {
      "id": 9,
      "question": "Quel avantage offre un pool taggué pour l'invalidation fonctionnelle ?",
      "type": "single_choice",
      "options": [
        "Invalidation fine par domaines métier (ex: product_123) sans connaître toutes les clés",
        "Plus de performance CPU",
        "Zéro sérialisation",
        "Compatibilité PSR-4"
      ],
      "correct_answers": [
        "Invalidation fine par domaines métier (ex: product_123) sans connaître toutes les clés"
      ],
      "explanation": "Les tags permettent une invalidation ciblée."
    },
    {
      "id": 10,
      "question": "Quand préférer un cache chainé plutôt qu'un unique Redis ?",
      "type": "single_choice",
      "options": [
        "Quand on veut un L1 ultra rapide en RAM process pour réduire la latence sur les hits fréquents",
        "Jamais",
        "Uniquement en dev",
        "Pour éviter la sérialisation"
      ],
      "correct_answers": [
        "Quand on veut un L1 ultra rapide en RAM process pour réduire la latence sur les hits fréquents"
      ],
      "explanation": "ChainAdapter combine rapidité locale et cohérence du backend partagé."
    }
  ]
}