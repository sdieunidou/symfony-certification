{
  "source_file": "18-api/payload-validation.md",
  "title": "Validation des Payloads API",
  "questions": [
    {
      "id": 1,
      "question": "Quelle différence entre validation 400 et 422 dans une API ?",
      "type": "single_choice",
      "options": [
        "400 = JSON mal formé (parse error), 422 = JSON valide mais données non conformes aux règles métier",
        "422 = deprecated",
        "400 = server error",
        "Aucune"
      ],
      "correct_answers": [
        "400 = JSON mal formé (parse error), 422 = JSON valide mais données non conformes aux règles métier"
      ],
      "explanation": "400 pour syntaxe invalide, 422 pour violation métier/validation."
    },
    {
      "id": 2,
      "question": "Quelle contrainte déclenche la validation en cascade des sous-objets ?",
      "type": "single_choice",
      "options": [
        "`#[Assert\\Valid]`",
        "`#[Assert\\Cascade]`",
        "`#[Assert\\Nested]`",
        "`#[Assert\\All]`"
      ],
      "correct_answers": [
        "`#[Assert\\Valid]`"
      ],
      "explanation": "Valid force la descente dans l'objet imbriqué."
    },
    {
      "id": 3,
      "question": "Quel standard d'erreur JSON Symfony peut produire nativement ?",
      "type": "single_choice",
      "options": [
        "RFC 7807 Problem Details",
        "SOAP Fault",
        "WSDL",
        "RAML"
      ],
      "correct_answers": [
        "RFC 7807 Problem Details"
      ],
      "explanation": "Le format Problem Details structure type/title/status/detail."
    },
    {
      "id": 4,
      "question": "Pourquoi éviter le composant Form pour valider des payloads JSON simples ?",
      "type": "single_choice",
      "options": [
        "Form est orienté HTML et lourd ; Serializer/Validator ou MapRequestPayload sont plus directs",
        "Form ne fonctionne pas en API",
        "Form n'a pas de validation",
        "Form est payant"
      ],
      "correct_answers": [
        "Form est orienté HTML et lourd ; Serializer/Validator ou MapRequestPayload sont plus directs"
      ],
      "explanation": "On préfère un flux API-first simple sans le surcoût des Form."
    },
    {
      "id": 5,
      "question": "Quelles étapes couvre `MapRequestPayload` automatiquement ?",
      "type": "multiple_choice",
      "options": [
        "Désérialisation du body vers l'objet",
        "Validation via Validator",
        "Lève une exception 422 en cas de violations",
        "Conversion auto en entité Doctrine"
      ],
      "correct_answers": [
        "Désérialisation du body vers l'objet",
        "Validation via Validator",
        "Lève une exception 422 en cas de violations"
      ],
      "explanation": "Il gère mapping + validation + exception 422 ; la persistance reste à faire."
    },
    {
      "id": 6,
      "question": "Quels codes HTTP liés aux formats sont typiquement associés aux erreurs de validation ?",
      "type": "multiple_choice",
      "options": [
        "400 pour JSON mal formé",
        "415 pour Content-Type non supporté",
        "422 pour données invalides mais bien formées",
        "500 systématique"
      ],
      "correct_answers": [
        "400 pour JSON mal formé",
        "415 pour Content-Type non supporté",
        "422 pour données invalides mais bien formées"
      ],
      "explanation": "400/415/422 couvrent parse, media type, validation."
    },
    {
      "id": 7,
      "question": "À quoi sert `#[Assert\\Choice]` dans un DTO ?",
      "type": "single_choice",
      "options": [
        "Limiter les valeurs autorisées (enum-like)",
        "Forcer un type numérique",
        "Valider un email",
        "Gérer la cascade"
      ],
      "correct_answers": [
        "Limiter les valeurs autorisées (enum-like)"
      ],
      "explanation": "Choice restreint le set de valeurs acceptées."
    },
    {
      "id": 8,
      "question": "Pourquoi appliquer `#[Assert\\Type]` peut être utile même avec le typage PHP ?",
      "type": "single_choice",
      "options": [
        "Pour contrôler des types scalaires sur des valeurs mal typées venant du JSON (ex: string au lieu d'int)",
        "Pour accélérer le CPU",
        "Pour remplacer le Serializer",
        "Pour supprimer les warnings"
      ],
      "correct_answers": [
        "Pour contrôler des types scalaires sur des valeurs mal typées venant du JSON (ex: string au lieu d'int)"
      ],
      "explanation": "Type vérifie les valeurs après désérialisation."
    },
    {
      "id": 9,
      "question": "Comment construire une réponse 422 structurée manuellement ?",
      "type": "single_choice",
      "options": [
        "Boucler sur les `ConstraintViolation` et retourner un JSON `violations` avec status 422",
        "Retourner 200 avec un message",
        "Lever une FatalError",
        "Utiliser Twig"
      ],
      "correct_answers": [
        "Boucler sur les `ConstraintViolation` et retourner un JSON `violations` avec status 422"
      ],
      "explanation": "Pattern classique : lister field/message et répondre 422."
    },
    {
      "id": 10,
      "question": "Pourquoi valider tôt (fail fast) avant la logique métier ou la BDD ?",
      "type": "multiple_choice",
      "options": [
        "Pour éviter des effets de bord (écriture BDD) avec des données invalides",
        "Pour fournir un feedback rapide et clair au client",
        "Pour économiser des ressources serveur",
        "Pour forcer un timeout"
      ],
      "correct_answers": [
        "Pour éviter des effets de bord (écriture BDD) avec des données invalides",
        "Pour fournir un feedback rapide et clair au client",
        "Pour économiser des ressources serveur"
      ],
      "explanation": "Valider en amont protège la logique et réduit le coût serveur."
    }
  ]
}
