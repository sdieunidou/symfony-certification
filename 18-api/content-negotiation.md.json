{
  "source_file": "18-api/content-negotiation.md",
  "title": "Content Negotiation & Versioning",
  "questions": [
    {
      "id": 1,
      "question": "Quel en-tête HTTP le client utilise-t-il pour indiquer au serveur le format de réponse souhaité (ex: JSON ou XML) ?",
      "type": "single_choice",
      "options": [
        "`Content-Type`",
        "`Accept`",
        "`Authorization`",
        "`User-Agent`"
      ],
      "correct_answers": [
        "`Accept`"
      ],
      "explanation": "L'en-tête `Accept` sert à la négociation de contenu pour la réponse. `Content-Type` décrit le format du corps de la requête envoyée."
    },
    {
      "id": 2,
      "question": "Quelle est la méthode la plus simple et courante pour versionner une API ?",
      "type": "single_choice",
      "options": [
        "Le Versioning par Média Type (`Accept: application/vnd.v1+json`).",
        "Le Versioning par URI (ex: `/api/v1/users`).",
        "Le Versioning par paramètre de requête (`?v=1`).",
        "Ne pas versionner."
      ],
      "correct_answers": [
        "Le Versioning par URI (ex: `/api/v1/users`)."
      ],
      "explanation": "Bien que moins 'REST pur' que le Media Type, le versioning par URI est le plus répandu car explicite et facile à explorer."
    },
    {
      "id": 3,
      "question": "Dans Symfony, quelle méthode de l'objet `Request` permet de connaître le format préféré du client (basé sur le header Accept) ?",
      "type": "single_choice",
      "options": [
        "`$request->getFormat()`",
        "`$request->getPreferredFormat()`",
        "`$request->getContentType()`",
        "`$request->getAcceptableContentTypes()`"
      ],
      "correct_answers": [
        "`$request->getPreferredFormat()`"
      ],
      "explanation": "Cette méthode analyse la chaîne `Accept` (avec les poids `q=`) et retourne le meilleur format supporté (ex: 'json')."
    },
    {
      "id": 4,
      "question": "Quelle est la règle d'or concernant l'évolution d'une API publique ?",
      "type": "single_choice",
      "options": [
        "Toujours utiliser la dernière version de PHP.",
        "Ne jamais introduire de 'Breaking Changes' (rupture de compatibilité) sans changer de version majeure.",
        "Forcer les clients à se mettre à jour chaque semaine.",
        "Utiliser uniquement des méthodes POST."
      ],
      "correct_answers": [
        "Ne jamais introduire de 'Breaking Changes' (rupture de compatibilité) sans changer de version majeure."
      ],
      "explanation": "Casser un client existant est la pire chose à faire pour une API. La rétrocompatibilité (BC) est essentielle."
    }
  ]
}
