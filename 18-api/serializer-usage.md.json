{
  "source_file": "18-api/serializer-usage.md",
  "title": "Sérialisation en API",
  "questions": [
    {
      "id": 1,
      "question": "À quoi servent les groupes de sérialisation `#[Groups]` dans une API ?",
      "type": "multiple_choice",
      "options": [
        "Limiter l'exposition en lecture (ex: user:read)",
        "Limiter les champs acceptés en écriture (ex: user:write)",
        "Éviter la fuite de données sensibles",
        "Structurer les rôles de sécurité"
      ],
      "correct_answers": [
        "Limiter l'exposition en lecture (ex: user:read)",
        "Limiter les champs acceptés en écriture (ex: user:write)",
        "Éviter la fuite de données sensibles"
      ],
      "explanation": "Les groupes contrôlent ce qui sort ou entre ; la sécurité reste gérée par Security/Voters."
    },
    {
      "id": 2,
      "question": "Comment résoudre une référence circulaire (User->Posts->User) ?",
      "type": "multiple_choice",
      "options": [
        "Séparer les groupes pour casser le cycle",
        "Configurer `AbstractNormalizer::CIRCULAR_REFERENCE_HANDLER` pour retourner un identifiant",
        "Utiliser `#[MaxDepth]` avec `enable_max_depth`",
        "Activer les sessions"
      ],
      "correct_answers": [
        "Séparer les groupes pour casser le cycle",
        "Configurer `AbstractNormalizer::CIRCULAR_REFERENCE_HANDLER` pour retourner un identifiant",
        "Utiliser `#[MaxDepth]` avec `enable_max_depth`"
      ],
      "explanation": "Groupes, handler ou MaxDepth sont les stratégies classiques."
    },
    {
      "id": 3,
      "question": "Quelle différence de rôle entre Normalizer et Encoder ?",
      "type": "single_choice",
      "options": [
        "Normalizer: Objet->Array ; Encoder: Array->String (JSON/XML)",
        "Normalizer chiffre les données",
        "Encoder valide les données",
        "Ils sont identiques"
      ],
      "correct_answers": [
        "Normalizer: Objet->Array ; Encoder: Array->String (JSON/XML)"
      ],
      "explanation": "Le pipeline est Objet -> normalize -> encode."
    },
    {
      "id": 4,
      "question": "Comment renommer ou mapper une propriété imbriquée lors de la sérialisation ?",
      "type": "single_choice",
      "options": [
        "`#[SerializedName]` pour renommer, `#[SerializedPath]` pour mapper une structure imbriquée",
        "`#[Alias]`",
        "`#[Rename]`",
        "Impossible"
      ],
      "correct_answers": [
        "`#[SerializedName]` pour renommer, `#[SerializedPath]` pour mapper une structure imbriquée"
      ],
      "explanation": "SerializedName change la clé ; SerializedPath cible une clé imbriquée."
    },
    {
      "id": 5,
      "question": "Comment ignorer une propriété ponctuellement sans toucher aux groupes ?",
      "type": "single_choice",
      "options": [
        "Passer `AbstractNormalizer::IGNORED_ATTRIBUTES` dans le contexte",
        "Supprimer le getter",
        "Utiliser une exception",
        "Modifier Doctrine"
      ],
      "correct_answers": [
        "Passer `AbstractNormalizer::IGNORED_ATTRIBUTES` dans le contexte"
      ],
      "explanation": "ignored_attributes dans le contexte exclut certaines propriétés à la volée."
    },
    {
      "id": 6,
      "question": "Quel attribut exclut définitivement une propriété du Serializer ?",
      "type": "single_choice",
      "options": [
        "`#[Ignore]`",
        "`#[Hidden]`",
        "`#[Private]`",
        "`#[Skip]`"
      ],
      "correct_answers": [
        "`#[Ignore]`"
      ],
      "explanation": "Ignore interdit toute sérialisation/désérialisation de la propriété."
    },
    {
      "id": 7,
      "question": "Quels contextes courants peuvent être passés à `serialize()` ou `json()` ?",
      "type": "multiple_choice",
      "options": [
        "`groups`",
        "`datetime_format`",
        "`enable_max_depth`",
        "`hydration_mode`"
      ],
      "correct_answers": [
        "`groups`",
        "`datetime_format`",
        "`enable_max_depth`"
      ],
      "explanation": "Ces clés influent sur groupes, format des dates et profondeur."
    },
    {
      "id": 8,
      "question": "Pourquoi les DTOs peuvent-ils améliorer les performances de sérialisation sur de grosses collections ?",
      "type": "single_choice",
      "options": [
        "Moins de relations à hydrater, moins de réflexion, structure plate",
        "Parce qu'ils désactivent Doctrine",
        "Parce qu'ils compressent le JSON",
        "Parce qu'ils sont toujours cacheables"
      ],
      "correct_answers": [
        "Moins de relations à hydrater, moins de réflexion, structure plate"
      ],
      "explanation": "DTOs évitent l'hydratation profonde et la réflexion sur des graphes complexes."
    },
    {
      "id": 9,
      "question": "Comment contrôler la profondeur de sérialisation d'une relation ?",
      "type": "single_choice",
      "options": [
        "Avec `#[MaxDepth]` et `enable_max_depth` dans le contexte",
        "Avec `#[DepthLimit]`",
        "Avec `#[Groups]` uniquement",
        "Impossible"
      ],
      "correct_answers": [
        "Avec `#[MaxDepth]` et `enable_max_depth` dans le contexte"
      ],
      "explanation": "MaxDepth nécessite l'option de contexte pour être active."
    },
    {
      "id": 10,
      "question": "Quel choix est recommandé pour éviter de serialiser par mégarde des mots de passe ?",
      "type": "multiple_choice",
      "options": [
        "Ne pas mettre le groupe de lecture sur la propriété",
        "Utiliser `#[Ignore]` sur le password",
        "Utiliser des DTOs qui n'ont pas le password en sortie",
        "Forcer `groups: 'all'`"
      ],
      "correct_answers": [
        "Ne pas mettre le groupe de lecture sur la propriété",
        "Utiliser `#[Ignore]` sur le password",
        "Utiliser des DTOs qui n'ont pas le password en sortie"
      ],
      "explanation": "Groupes/Ignore/DTO protègent contre l'exposition de secrets."
    }
  ]
}
