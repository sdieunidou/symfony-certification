{
  "source_file": "09-injection-dependances/decoration.md",
  "title": "Décoration de Service",
  "questions": [
    {
      "id": 1,
      "question": "Quel est le but principal de la décoration de service ?",
      "type": "single_choice",
      "options": [
        "Remplacer une classe par héritage.",
        "Ajouter une fonctionnalité à un service existant de manière transparente, sans modifier sa classe.",
        "Définir des alias pour les services.",
        "Optimiser le conteneur."
      ],
      "correct_answers": [
        "Ajouter une fonctionnalité à un service existant de manière transparente, sans modifier sa classe."
      ],
      "explanation": "Le pattern Décorateur permet d'envelopper un service pour modifier ses entrées/sorties sans changer son code source."
    },
    {
      "id": 2,
      "question": "Quel attribut PHP permet d'injecter proprement le service décoré (inner) sans se soucier du nom de l'argument ?",
      "type": "single_choice",
      "options": [
        "#[InjectInner]",
        "#[AutowireDecorated]",
        "#[DecoratedService]",
        "#[ParentService]"
      ],
      "correct_answers": [
        "#[AutowireDecorated]"
      ],
      "explanation": "Cet attribut dit à Symfony : 'Injecte ici l'instance du service que je suis en train de décorer'."
    },
    {
      "id": 3,
      "question": "Que se passe-t-il avec les tags du service original lorsqu'il est décoré ?",
      "type": "single_choice",
      "options": [
        "Ils sont automatiquement transférés au décorateur.",
        "Ils sont perdus (sauf exceptions système) et ne s'appliquent pas au décorateur.",
        "Ils sont dupliqués.",
        "Cela déclenche une erreur."
      ],
      "correct_answers": [
        "Ils sont perdus (sauf exceptions système) et ne s'appliquent pas au décorateur."
      ],
      "explanation": "C'est un piège classique. Si vous décorez une Commande ou une Extension Twig, vous devez souvent retaguer votre décorateur."
    },
    {
      "id": 4,
      "question": "Quelle option permet de ne pas planter l'application si le service qu'on tente de décorer n'existe pas ?",
      "type": "single_choice",
      "options": [
        "nullable: true",
        "onInvalid: ignore",
        "optional: true",
        "soft_decoration: true"
      ],
      "correct_answers": [
        "onInvalid: ignore"
      ],
      "explanation": "Avec `ignore`, Symfony supprime simplement la définition du décorateur si le service cible est absent."
    },
    {
      "id": 5,
      "question": "En configuration YAML, quelle est la chaîne spéciale pour référencer le service décoré ?",
      "type": "single_choice",
      "options": [
        "@parent",
        "@original",
        "@.inner",
        "@decorated"
      ],
      "correct_answers": [
        "@.inner"
      ],
      "explanation": "C'est l'ID conventionnel utilisé par Symfony pour l'injection manuelle dans le décorateur."
    },
    {
      "id": 6,
      "question": "Quelle fonctionnalité YAML permet d'empiler plusieurs décorateurs sur un même service pour créer un pipeline (ex: Command Bus) ?",
      "type": "single_choice",
      "options": [
        "La clé `stack`.",
        "La clé `pipeline`.",
        "La clé `chain`.",
        "La clé `middleware`."
      ],
      "correct_answers": [
        "La clé `stack`."
      ],
      "explanation": "Cela permet de définir l'ordre d'exécution de manière lisible, sans jouer avec les priorités."
    },
    {
      "id": 7,
      "question": "Que devient l'ID du service original après décoration ?",
      "type": "single_choice",
      "options": [
        "Il est supprimé",
        "Il est renommé avec le suffixe `.inner` (ou `decoration_inner_name`), l'ID public pointe sur le décorateur",
        "Il est rendu public",
        "Il est dupliqué"
      ],
      "correct_answers": [
        "Il est renommé avec le suffixe `.inner` (ou `decoration_inner_name`), l'ID public pointe sur le décorateur"
      ],
      "explanation": "Le décoré reste accessible sous son inner ID pour être injecté."
    },
    {
      "id": 8,
      "question": "Pourquoi doit-on souvent retaguer un service décoré ?",
      "type": "single_choice",
      "options": [
        "Parce que les tags ne sont pas transférés automatiquement au décorateur",
        "Parce que les tags deviennent publics",
        "Parce que le décorateur ne peut pas avoir de tags",
        "Parce que les tags sont interdits sur les décorateurs"
      ],
      "correct_answers": [
        "Parce que les tags ne sont pas transférés automatiquement au décorateur"
      ],
      "explanation": "Sans retaguer, les fonctionnalités liées (console.command, twig.extension) seraient perdues."
    },
    {
      "id": 9,
      "question": "Quel paramètre `priority` détermine l'ordre d'exécution des décorateurs ?",
      "type": "single_choice",
      "options": [
        "Plus la priorité est élevée, plus le décorateur est extérieur (appelé en premier)",
        "Plus la priorité est basse, plus le décorateur est extérieur",
        "La priorité est ignorée",
        "La priorité est triée alphabétiquement"
      ],
      "correct_answers": [
        "Plus la priorité est élevée, plus le décorateur est extérieur (appelé en premier)"
      ],
      "explanation": "La pile se construit du plus haut vers le plus bas."
    },
    {
      "id": 10,
      "question": "Comment décorer conditionnellement un service optionnel d'un bundle tiers ?",
      "type": "single_choice",
      "options": [
        "Avec `onInvalid: ignore` ou `onInvalid: null`",
        "En mettant public: true",
        "En forçant autowire: false",
        "Impossible"
      ],
      "correct_answers": [
        "Avec `onInvalid: ignore` ou `onInvalid: null`"
      ],
      "explanation": "Permet de ne pas casser la compilation si le service cible n'existe pas."
    }
  ]
}