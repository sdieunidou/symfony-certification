{
  "source_file": "09-injection-dependances/factories.md",
  "title": "Factories (Usines)",
  "questions": [
    {
      "id": 1,
      "question": "Quelle est la syntaxe pour utiliser un service comme factory (méthode non statique) en YAML ?",
      "type": "single_choice",
      "options": [
        "factory: ['App\\MyFactory', 'create']",
        "factory: ['@App\\MyFactory', 'create']",
        "factory: 'App\\MyFactory::create'",
        "service_factory: '@App\\MyFactory'"
      ],
      "correct_answers": [
        "factory: ['@App\\MyFactory', 'create']"
      ],
      "explanation": "Le '@' indique qu'on référence un service existant, et non une classe statique."
    },
    {
      "id": 2,
      "question": "À quoi correspond l'option `arguments` sur une définition de service utilisant une factory ?",
      "type": "single_choice",
      "options": [
        "Aux arguments passés au constructeur de la classe du service.",
        "Aux arguments passés à la méthode de la factory.",
        "Aux arguments passés au constructeur de la factory.",
        "C'est interdit."
      ],
      "correct_answers": [
        "Aux arguments passés à la méthode de la factory."
      ],
      "explanation": "Le conteneur appelle `Factory::method(...arguments)`, c'est ensuite à la factory de passer ce qu'il faut au `new Service()`."
    },
    {
      "id": 3,
      "question": "Comment configurer une classe pour qu'elle utilise sa propre méthode statique `create` comme constructeur via un attribut ?",
      "type": "single_choice",
      "options": [
        "#[AsFactory('create')]",
        "#[Autoconfigure(constructor: 'create')]",
        "#[Construct('create')]",
        "#[Factory(method: 'create')]"
      ],
      "correct_answers": [
        "#[Autoconfigure(constructor: 'create')]"
      ],
      "explanation": "C'est l'option `constructor` de l'attribut `Autoconfigure` qui gère ce cas (Self-Factory)."
    },
    {
      "id": 4,
      "question": "Peut-on utiliser une expression pour définir une factory ?",
      "type": "single_choice",
      "options": [
        "Non, une factory doit être une classe ou un service.",
        "Oui, avec la syntaxe `factory: '@=...'`.",
        "Oui, mais seulement en XML.",
        "Non, pour des raisons de performance."
      ],
      "correct_answers": [
        "Oui, avec la syntaxe `factory: '@=...'`."
      ],
      "explanation": "Cela permet de retourner dynamiquement un service ou un autre selon une condition (ex: debug)."
    },
    {
      "id": 5,
      "question": "Si l'ID du service est un FQCN (nom de classe complet), est-il obligatoire de préciser la clé `class` en plus de la factory ?",
      "type": "single_choice",
      "options": [
        "Oui, toujours.",
        "Non, Symfony utilise l'ID comme classe par défaut, bien que la factory puisse retourner un objet d'un type différent (polymorphisme).",
        "Seulement si la factory est statique.",
        "Non, car la classe est devinée par la factory."
      ],
      "correct_answers": [
        "Non, Symfony utilise l'ID comme classe par défaut, bien que la factory puisse retourner un objet d'un type différent (polymorphisme)."
      ],
      "explanation": "C'est une convention pratique pour réduire la configuration YAML."
    },
    {
      "id": 6,
      "question": "Quelle est la différence entre une factory statique et une factory service ?",
      "type": "single_choice",
      "options": [
        "La factory service peut avoir ses propres dépendances injectées par le conteneur, la factory statique non",
        "Aucune",
        "La factory statique est plus lente",
        "La factory service ne peut pas retourner d'objet"
      ],
      "correct_answers": [
        "La factory service peut avoir ses propres dépendances injectées par le conteneur, la factory statique non"
      ],
      "explanation": "Une factory service est enregistrée comme service et autowirable."
    },
    {
      "id": 7,
      "question": "Que se passe-t-il si vous définissez `factory` sur un service et que sa classe a un constructeur ?",
      "type": "single_choice",
      "options": [
        "Le constructeur est ignoré, seule la méthode factory décide comment instancier",
        "Les deux sont appelés",
        "Erreur de compilation",
        "Le constructeur est appelé avant la factory"
      ],
      "correct_answers": [
        "Le constructeur est ignoré, seule la méthode factory décide comment instancier"
      ],
      "explanation": "La factory prend la main sur l'instanciation."
    },
    {
      "id": 8,
      "question": "Comment passer des arguments à la factory plutôt qu'au constructeur du service produit ?",
      "type": "single_choice",
      "options": [
        "En les déclarant sous `arguments` de la définition, ils seront passés à la méthode factory",
        "En utilisant `factory_arguments`",
        "En utilisant `calls`",
        "Impossible"
      ],
      "correct_answers": [
        "En les déclarant sous `arguments` de la définition, ils seront passés à la méthode factory"
      ],
      "explanation": "Les arguments s'appliquent à l'appel de la factory."
    },
    {
      "id": 9,
      "question": "Quelle syntaxe YAML permet de définir une factory invokable (méthode `__invoke`) ?",
      "type": "single_choice",
      "options": [
        "factory: '@App\\Factory\\MyFactory'",
        "factory: ['@App\\Factory\\MyFactory', '__invoke']",
        "factory: ['App\\Factory\\MyFactory', '__invoke']",
        "service: '@App\\Factory\\MyFactory'"
      ],
      "correct_answers": [
        "factory: '@App\\Factory\\MyFactory'"
      ],
      "explanation": "Si la factory est un service invokable, on peut référencer directement son ID."
    },
    {
      "id": 10,
      "question": "Quel piège avec une factory qui retourne conditionnellement `null` ?",
      "type": "single_choice",
      "options": [
        "Le conteneur créera un alias null et les consommateurs recevront null, potentiellement causant des `TypeError` si l'argument n'est pas nullable",
        "Aucun, Symfony gère toujours null",
        "Le conteneur ignore la définition",
        "La compilation échoue toujours"
      ],
      "correct_answers": [
        "Le conteneur créera un alias null et les consommateurs recevront null, potentiellement causant des `TypeError` si l'argument n'est pas nullable"
      ],
      "explanation": "Il faut marquer l'argument nullable ou gérer l'absence via un locator."
    }
  ]
}