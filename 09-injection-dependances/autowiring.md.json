{
  "source_file": "09-injection-dependances/autowiring.md",
  "title": "Autowiring",
  "questions": [
    {
      "id": 1,
      "question": "Comment l'Autowiring de Symfony détermine-t-il quel service injecter ?",
      "type": "single_choice",
      "options": [
        "En se basant sur le nom de la variable.",
        "En se basant sur le type (Type Hinting) de l'argument du constructeur.",
        "En cherchant une annotation.",
        "Il faut configurer chaque service manuellement."
      ],
      "correct_answers": [
        "En se basant sur le type (Type Hinting) de l'argument du constructeur."
      ],
      "explanation": "Symfony analyse `__construct(LoggerInterface $logger)` et trouve le service qui implémente `LoggerInterface`."
    },
    {
      "id": 2,
      "question": "Comment résoudre un conflit d'autowiring si plusieurs services implémentent la même interface ?",
      "type": "multiple_choice",
      "options": [
        "En utilisant l'attribut `#[Autowire(service: 'id_du_service')]`.",
        "En renommant la variable comme l'ID du service (ex: `$monologLoggerRequest`).",
        "En définissant un binding global (par nom d'argument) dans `services.yaml`.",
        "En utilisant `#[Target('id_du_service')]`."
      ],
      "correct_answers": [
        "En utilisant l'attribut `#[Autowire(service: 'id_du_service')]`.",
        "En définissant un binding global (par nom d'argument) dans `services.yaml`.",
        "En utilisant `#[Target('id_du_service')]`."
      ],
      "explanation": "Le nom de la variable n'est utilisé pour la résolution que si un binding explicite a été configuré dans `services.yaml`."
    },
    {
      "id": 3,
      "question": "L'autowiring a-t-il un impact sur la performance en production ?",
      "type": "single_choice",
      "options": [
        "Oui, il ralentit chaque requête car il utilise la réflexion.",
        "Non, car tout est résolu et compilé dans le cache lors du 'warmup' (build time).",
        "Oui, mais c'est négligeable.",
        "Seulement s'il y a des erreurs."
      ],
      "correct_answers": [
        "Non, car tout est résolu et compilé dans le cache lors du 'warmup' (build time)."
      ],
      "explanation": "Le conteneur compilé contient du code PHP optimisé avec les injections en dur."
    },
    {
      "id": 4,
      "question": "Comment injecter un paramètre scalaire (string, int) via l'autowiring ?",
      "type": "single_choice",
      "options": [
        "Ce n'est pas possible, il faut définir le service manuellement.",
        "En utilisant l'attribut `#[Autowire('%nom_du_parametre%')]`.",
        "En typant l'argument `string`.",
        "En utilisant `#[Inject]`."
      ],
      "correct_answers": [
        "En utilisant l'attribut `#[Autowire('%nom_du_parametre%')]`."
      ],
      "explanation": "C'est la méthode recommandée depuis Symfony 6.1."
    },
    {
      "id": 5,
      "question": "Quel attribut permet de transformer une méthode d'un service en un 'Callable' injecté automatiquement, adaptant ainsi une interface fonctionnelle ?",
      "type": "single_choice",
      "options": [
        "#[AutowireMethod]",
        "#[AutowireCallable]",
        "#[AsCallable]",
        "#[Callback]"
      ],
      "correct_answers": [
        "#[AutowireCallable]"
      ],
      "explanation": "Cela permet d'injecter une méthode spécifique d'un service comme si c'était un objet implémentant une interface fonctionnelle."
    },
    {
      "id": 6,
      "question": "Comment injecter une implémentation spécifique quand deux services implémentent la même interface et aucun alias par défaut n'est défini ?",
      "type": "multiple_choice",
      "options": [
        "Attribuer un alias de service vers l'implémentation par défaut",
        "Utiliser `#[Target('service_id')]` sur l'argument concerné",
        "Utiliser `#[Autowire(service: 'service_id')]` sur l'argument",
        "Renommer la variable"
      ],
      "correct_answers": [
        "Attribuer un alias de service vers l'implémentation par défaut",
        "Utiliser `#[Target('service_id')]` sur l'argument concerné",
        "Utiliser `#[Autowire(service: 'service_id')]` sur l'argument"
      ],
      "explanation": "Alias global ou ciblage local via attributs résolvent l'ambiguïté."
    },
    {
      "id": 7,
      "question": "Pourquoi l'autowiring ne résout-il pas les arguments scalaires sans aide ?",
      "type": "single_choice",
      "options": [
        "Parce que les scalaires ne sont pas typés en PHP",
        "Parce que le conteneur ne connaît pas la valeur attendue (pas d'ID/type pour matcher), il faut un bind ou `#[Autowire('%param%')]`",
        "Parce que c'est déprécié",
        "Parce qu'il faut les rendre publics"
      ],
      "correct_answers": [
        "Parce que le conteneur ne connaît pas la valeur attendue (pas d'ID/type pour matcher), il faut un bind ou `#[Autowire('%param%')]`"
      ],
      "explanation": "Les scalaires requièrent une configuration explicite."
    },
    {
      "id": 8,
      "question": "Quelle est la particularité de l'autowiring sur les méthodes de contrôleurs ?",
      "type": "single_choice",
      "options": [
        "Il est désactivé",
        "Il fonctionne via le `ServiceValueResolver`, même sans construction de service",
        "Il nécessite un attribut spécial",
        "Il ne marche qu'en dev"
      ],
      "correct_answers": [
        "Il fonctionne via le `ServiceValueResolver`, même sans construction de service"
      ],
      "explanation": "Les contrôleurs sont instanciés par le framework et résolus à la volée."
    },
    {
      "id": 9,
      "question": "Quel piège avec `#[Target]` si l'ID visé n'est pas autowirable ?",
      "type": "single_choice",
      "options": [
        "Une erreur d'autowiring est levée à la compilation",
        "Le service est ignoré silencieusement",
        "Un autre service est injecté",
        "Le conteneur bascule en public"
      ],
      "correct_answers": [
        "Une erreur d'autowiring est levée à la compilation"
      ],
      "explanation": "Target exige que l'ID référencé existe et soit résolvable."
    },
    {
      "id": 10,
      "question": "Quel impact de performance l'autowiring a-t-il sur une application Symfony 7 en prod ?",
      "type": "single_choice",
      "options": [
        "Important, car chaque requête utilise la réflexion",
        "Négligeable : tout est résolu lors de la compilation du conteneur et généré en code PHP statique",
        "Modéré uniquement sur les contrôleurs",
        "Il double le temps de boot"
      ],
      "correct_answers": [
        "Négligeable : tout est résolu lors de la compilation du conteneur et généré en code PHP statique"
      ],
      "explanation": "Le runtime utilise les classes dumpées, sans réflexion."
    }
  ]
}