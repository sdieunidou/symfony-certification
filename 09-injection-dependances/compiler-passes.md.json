{
  "source_file": "09-injection-dependances/compiler-passes.md",
  "title": "Passes de Compilateur (Compiler Passes)",
  "questions": [
    {
      "id": 1,
      "question": "À quel moment un CompilerPass est-il exécuté ?",
      "type": "single_choice",
      "options": [
        "À chaque requête HTTP.",
        "Uniquement lors de la compilation du conteneur (cache warmup).",
        "Au déploiement.",
        "Quand on appelle un service."
      ],
      "correct_answers": [
        "Uniquement lors de la compilation du conteneur (cache warmup)."
      ],
      "explanation": "C'est pour cela qu'on ne peut pas injecter de services dans un CompilerPass, seulement manipuler leurs définitions."
    },
    {
      "id": 2,
      "question": "Quel est l'usage principal d'un CompilerPass personnalisé ?",
      "type": "single_choice",
      "options": [
        "Créer des routes.",
        "Modifier dynamiquement les définitions de services (ex: trouver tous les services avec un tag et les injecter dans un Manager).",
        "Valider la configuration.",
        "Optimiser le code PHP."
      ],
      "correct_answers": [
        "Modifier dynamiquement les définitions de services (ex: trouver tous les services avec un tag et les injecter dans un Manager)."
      ],
      "explanation": "C'est le mécanisme standard pour implémenter le pattern plugin/extensions via les tags."
    },
    {
      "id": 3,
      "question": "Quelle méthode moderne remplace souvent l'écriture manuelle d'un CompilerPass pour gérer les collections de services ?",
      "type": "single_choice",
      "options": [
        "L'attribut `#[TaggedIterator('mon_tag')]`.",
        "L'autowiring.",
        "L'interface `ServiceSubscriberInterface`.",
        "La configuration YAML."
      ],
      "correct_answers": [
        "L'attribut `#[TaggedIterator('mon_tag')]`."
      ],
      "explanation": "Injecter un `iterable` tagué dans le constructeur permet de récupérer tous les services correspondants sans code de compilation complexe."
    },
    {
      "id": 4,
      "question": "Peut-on modifier un service une fois le conteneur compilé (Frozen) ?",
      "type": "single_choice",
      "options": [
        "Oui, via des setters.",
        "Non, le conteneur est gelé pour des raisons de performance et d'intégrité.",
        "Oui, en mode debug.",
        "Oui, en utilisant `set()`."
      ],
      "correct_answers": [
        "Non, le conteneur est gelé pour des raisons de performance et d'intégrité."
      ],
      "explanation": "Au runtime, le graphe de dépendances est fixe."
    },
    {
      "id": 5,
      "question": "Quel est le type de passe par défaut (ordre d'exécution) si rien n'est spécifié lors de l'enregistrement ?",
      "type": "single_choice",
      "options": [
        "`PassConfig::TYPE_AFTER_REMOVING`",
        "`PassConfig::TYPE_BEFORE_OPTIMIZATION`",
        "`PassConfig::TYPE_OPTIMIZE`",
        "`PassConfig::TYPE_BEFORE_REMOVING`"
      ],
      "correct_answers": [
        "`PassConfig::TYPE_BEFORE_OPTIMIZATION`"
      ],
      "explanation": "C'est le moment idéal pour modifier les définitions avant que Symfony n'optimise le conteneur (ex: suppression des services privés)."
    },
    {
      "id": 6,
      "question": "Pourquoi un CompilerPass ne peut-il pas consommer directement des services ?",
      "type": "single_choice",
      "options": [
        "Parce que le conteneur n'est pas encore compilé, seuls les objets Definition/Reference existent",
        "Parce que les services sont privés",
        "Parce que l'autowiring est désactivé",
        "Parce que le cache est vide"
      ],
      "correct_answers": [
        "Parce que le conteneur n'est pas encore compilé, seuls les objets Definition/Reference existent"
      ],
      "explanation": "On manipule des recettes, pas des instances."
    },
    {
      "id": 7,
      "question": "Quelle méthode utiliser pour récupérer tous les services tagués dans un CompilerPass ?",
      "type": "single_choice",
      "options": [
        "$container->getTaggedServices()",
        "$container->findTaggedServiceIds('tag')",
        "$container->debugTags('tag')",
        "$container->listTags('tag')"
      ],
      "correct_answers": [
        "$container->findTaggedServiceIds('tag')"
      ],
      "explanation": "Retourne un tableau id => attributs par occurrence de tag."
    },
    {
      "id": 8,
      "question": "Comment s'assurer que votre CompilerPass s'exécute après la suppression des services privés inutilisés ?",
      "type": "single_choice",
      "options": [
        "En l'enregistrant avec `PassConfig::TYPE_AFTER_REMOVING`",
        "En le mettant dans le Kernel en premier",
        "En activant le debug",
        "Impossible"
      ],
      "correct_answers": [
        "En l'enregistrant avec `PassConfig::TYPE_AFTER_REMOVING`"
      ],
      "explanation": "Ce type passe après le RemovingPass qui supprime les services orphelins."
    },
    {
      "id": 9,
      "question": "Pourquoi `TaggedIterator` évite souvent d'écrire un CompilerPass ?",
      "type": "single_choice",
      "options": [
        "Parce qu'il génère du code PHP",
        "Parce qu'il injecte directement une collection taguée sans manipulation manuelle des Definition",
        "Parce qu'il rend les services publics",
        "Parce qu'il supprime les tags"
      ],
      "correct_answers": [
        "Parce qu'il injecte directement une collection taguée sans manipulation manuelle des Definition"
      ],
      "explanation": "L'attribut/notation YAML encapsule le pattern plugin simple."
    },
    {
      "id": 10,
      "question": "Quel risque si l'on ajoute un `addMethodCall` dans un CompilerPass sur un service non partagé (`shared: false`) ?",
      "type": "single_choice",
      "options": [
        "Chaque instanciation appliquera l'appel, ce qui est attendu",
        "L'appel ne sera pas exécuté",
        "Le service devient public",
        "Le conteneur échoue à compiler"
      ],
      "correct_answers": [
        "Chaque instanciation appliquera l'appel, ce qui est attendu"
      ],
      "explanation": "Les method calls sont rejoués à chaque création d'instance non partagée."
    }
  ]
}