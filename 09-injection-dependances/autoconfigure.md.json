{
  "source_file": "09-injection-dependances/autoconfigure.md",
  "title": "Autoconfigure",
  "questions": [
    {
      "id": 1,
      "question": "Quel est le rôle principal de l'option `autoconfigure: true` dans Symfony ?",
      "type": "single_choice",
      "options": [
        "Elle injecte automatiquement les dépendances dans le constructeur.",
        "Elle ajoute automatiquement des tags aux services en fonction des interfaces qu'ils implémentent.",
        "Elle enregistre automatiquement toutes les classes du dossier `src/` comme services.",
        "Elle configure automatiquement les paramètres globaux de l'application."
      ],
      "correct_answers": [
        "Elle ajoute automatiquement des tags aux services en fonction des interfaces qu'ils implémentent."
      ],
      "explanation": "L'autoconfigure détecte les interfaces (ex: `Command`, `EventSubscriberInterface`) et applique les tags correspondants (ex: `console.command`) sans configuration manuelle."
    },
    {
      "id": 2,
      "question": "Quelle section de `services.yaml` permet de définir des règles d'autoconfiguration personnalisées pour une interface spécifique ?",
      "type": "single_choice",
      "options": [
        "_defaults",
        "_instanceof",
        "services",
        "parameters"
      ],
      "correct_answers": [
        "_instanceof"
      ],
      "explanation": "La section `_instanceof` permet de définir que tous les services implémentant une certaine interface recevront des tags ou des appels de méthode spécifiques."
    },
    {
      "id": 3,
      "question": "Quel attribut PHP permet d'ajouter un tag à un service automatiquement, rendant la configuration YAML optionnelle ?",
      "type": "single_choice",
      "options": [
        "#[Tag]",
        "#[AutoconfigureTag]",
        "#[Service]",
        "#[AsTaggedItem]"
      ],
      "correct_answers": [
        "#[AutoconfigureTag]"
      ],
      "explanation": "L'attribut `#[AutoconfigureTag('mon.tag')]` (disponible depuis Symfony 5.3) permet de définir le tag directement sur la classe PHP."
    },
    {
      "id": 4,
      "question": "L'utilisation de `autoconfigure` a-t-elle un impact négatif sur les performances de l'application en production ?",
      "type": "single_choice",
      "options": [
        "Oui, car Symfony doit analyser les classes à chaque requête.",
        "Non, car la résolution des tags se fait lors de la compilation du conteneur (cache warmup).",
        "Oui, mais uniquement si on utilise `_instanceof`.",
        "Cela dépend du nombre de services."
      ],
      "correct_answers": [
        "Non, car la résolution des tags se fait lors de la compilation du conteneur (cache warmup)."
      ],
      "explanation": "Comme pour l'autowiring, tout le travail d'introspection est fait lors de la construction du conteneur, générant un code PHP optimisé et statique pour la production."
    },
    {
      "id": 5,
      "question": "Si un service a `autoconfigure: true` mais qu'on lui définit explicitement des tags dans `services.yaml`, que se passe-t-il ?",
      "type": "single_choice",
      "options": [
        "Une erreur est levée lors de la compilation.",
        "Les tags explicites s'ajoutent aux tags autoconfigurés.",
        "Les tags explicites remplacent les tags autoconfigurés.",
        "L'autoconfigure est ignoré pour ce service."
      ],
      "correct_answers": [
        "Les tags explicites s'ajoutent aux tags autoconfigurés."
      ],
      "explanation": "Les tags sont cumulatifs. Le service aura à la fois les tags définis automatiquement par ses interfaces et ceux ajoutés manuellement."
    },
    {
      "id": 6,
      "question": "Comment empêcher qu'un service spécifique reçoive des tags automatiquement via autoconfigure ?",
      "type": "single_choice",
      "options": [
        "En définissant `autowire: false`.",
        "En définissant `autoconfigure: false` explicitement pour ce service.",
        "En retirant l'interface.",
        "Ce n'est pas possible."
      ],
      "correct_answers": [
        "En définissant `autoconfigure: false` explicitement pour ce service."
      ],
      "explanation": "Cela permet d'avoir un contrôle total sur la configuration du service, sans interférence automatique."
    },
    {
      "id": 7,
      "question": "Quelle différence entre `#[AutoconfigureTag]` et l'attribut `#[AsTaggedItem]` appliqué sur la même classe ?",
      "type": "single_choice",
      "options": [
        "`AutoconfigureTag` pose le tag, `AsTaggedItem` configure l'index/priorité pour l'injection",
        "`AsTaggedItem` remplace `AutoconfigureTag`",
        "Aucune, ce sont des synonymes",
        "`AsTaggedItem` crée un alias de service"
      ],
      "correct_answers": [
        "`AutoconfigureTag` pose le tag, `AsTaggedItem` configure l'index/priorité pour l'injection"
      ],
      "explanation": "Les deux sont souvent combinés pour enrichir le tag ajouté automatiquement."
    },
    {
      "id": 8,
      "question": "Dans la section `_instanceof`, que se passe-t-il si deux règles matchent la même classe ?",
      "type": "single_choice",
      "options": [
        "Les deux s'appliquent et leurs tags/appels se cumulent",
        "La dernière écrase la première",
        "Erreur de compilation",
        "Seule la première est prise"
      ],
      "correct_answers": [
        "Les deux s'appliquent et leurs tags/appels se cumulent"
      ],
      "explanation": "Le ResolveInstanceofConditionalsPass fusionne les configurations, priorité aux règles les plus spécifiques."
    },
    {
      "id": 9,
      "question": "Pourquoi l'autoconfiguration n'ajoute-t-elle pas un tag si le service a `autoconfigure: false` mais l'interface est autoconfigurée globalement ?",
      "type": "single_choice",
      "options": [
        "Parce que la définition locale prime toujours sur les règles automatiques",
        "Parce que l'interface n'est pas supportée",
        "Parce que le tag doit être public",
        "Parce que les services privés sont ignorés"
      ],
      "correct_answers": [
        "Parce que la définition locale prime toujours sur les règles automatiques"
      ],
      "explanation": "La désactivation locale coupe le moteur d'autoconfiguration pour ce service."
    },
    {
      "id": 10,
      "question": "Quel piège classique avec `autoconfigure` lors d'une migration d'un bundle custom ?",
      "type": "single_choice",
      "options": [
        "Oublier d'ajouter les tags custom dans `_instanceof`, donc le plugin manager ne reçoit rien",
        "Mettre autowire à false",
        "Mettre les services en public",
        "Activer le cache"
      ],
      "correct_answers": [
        "Oublier d'ajouter les tags custom dans `_instanceof`, donc le plugin manager ne reçoit rien"
      ],
      "explanation": "Sans règle d'autoconfiguration, les services implémentant vos interfaces maison ne seront jamais tagués."
    }
  ]
}