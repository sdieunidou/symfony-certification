{
  "source_file": "09-injection-dependances/services-natifs.md",
  "title": "Services Natifs (Built-in Services)",
  "questions": [
    {
      "id": 1,
      "question": "Quelle interface faut-il utiliser pour injecter le Logger ?",
      "type": "single_choice",
      "options": [
        "`Monolog\\Logger`",
        "`Psr\\Log\\LoggerInterface`",
        "`Symfony\\Component\\HttpKernel\\Log\\LoggerInterface`",
        "`App\\Service\\Logger`"
      ],
      "correct_answers": [
        "`Psr\\Log\\LoggerInterface`"
      ],
      "explanation": "Symfony privilégie les interfaces PSR pour le découplage."
    },
    {
      "id": 2,
      "question": "Quel service permet d'accéder à la requête courante et à la session ?",
      "type": "single_choice",
      "options": [
        "`Symfony\\Component\\HttpFoundation\\Request`",
        "`Symfony\\Component\\HttpFoundation\\Session\\Session`",
        "`Symfony\\Component\\HttpFoundation\\RequestStack`",
        "`request_stack` (string)"
      ],
      "correct_answers": [
        "`Symfony\\Component\\HttpFoundation\\RequestStack`"
      ],
      "explanation": "`Request` n'est pas un service. Il faut passer par le `RequestStack` pour récupérer la `Request` ou la `Session`."
    },
    {
      "id": 3,
      "question": "Quelle interface permet d'injecter l'EntityManager de Doctrine ?",
      "type": "single_choice",
      "options": [
        "`Doctrine\\ORM\\EntityManager`",
        "`Doctrine\\ORM\\EntityManagerInterface`",
        "`Doctrine\\Persistence\\ObjectManager`",
        "`App\\Repository\\Manager`"
      ],
      "correct_answers": [
        "`Doctrine\\ORM\\EntityManagerInterface`"
      ],
      "explanation": "L'interface est préférée à la classe concrète pour faciliter les mocks et le découplage."
    },
    {
      "id": 4,
      "question": "Quel service (Helper) a été introduit dans Symfony 6.2 pour simplifier l'accès à l'utilisateur connecté et aux permissions ?",
      "type": "single_choice",
      "options": [
        "`SecurityContext`",
        "`Symfony\\Bundle\\SecurityBundle\\Security`",
        "`UserProvider`",
        "`AccessControl`"
      ],
      "correct_answers": [
        "`Symfony\\Bundle\\SecurityBundle\\Security`"
      ],
      "explanation": "La classe `Security` remplace l'injection combinée de `UserStorage` et `AuthorizationChecker` pour les cas courants."
    },
    {
      "id": 5,
      "question": "Quelle interface faut-il utiliser pour injecter le service de validation ?",
      "type": "single_choice",
      "options": [
        "`Symfony\\Component\\Validator\\Validator`",
        "`Symfony\\Component\\Validator\\Validator\\ValidatorInterface`",
        "`Symfony\\Component\\Validation\\ValidatorInterface`",
        "`ValidatorInterface`"
      ],
      "correct_answers": [
        "`Symfony\\Component\\Validator\\Validator\\ValidatorInterface`"
      ],
      "explanation": "C'est l'interface principale du composant Validator."
    },
    {
      "id": 6,
      "question": "Quel service helper introduit en Symfony 6.2 simplifie l'accès à l'utilisateur et aux permissions ?",
      "type": "single_choice",
      "options": [
        "`Symfony\\Bundle\\SecurityBundle\\Security`",
        "`SecurityContext`",
        "`UserChecker`",
        "`AccessDecisionManager`"
      ],
      "correct_answers": [
        "`Symfony\\Bundle\\SecurityBundle\\Security`"
      ],
      "explanation": "Expose getUser/isGranted de façon unifiée."
    },
    {
      "id": 7,
      "question": "Pourquoi préférer typer sur `TranslatorInterface` plutôt que sur le service `translator` ?",
      "type": "single_choice",
      "options": [
        "Pour découpler et permettre le remplacement/mock",
        "Parce que le service est public",
        "Parce que le service n'existe pas",
        "Parce que l'autowiring ne marche pas"
      ],
      "correct_answers": [
        "Pour découpler et permettre le remplacement/mock"
      ],
      "explanation": "Toujours typer sur l'interface contractuelle."
    },
    {
      "id": 8,
      "question": "Quel service utiliser pour accéder au chemin du projet ou aux paramètres système ?",
      "type": "single_choice",
      "options": [
        "`ParameterBagInterface`",
        "`RequestStack`",
        "`KernelInterface`",
        "`ConfigInterface`"
      ],
      "correct_answers": [
        "`ParameterBagInterface`"
      ],
      "explanation": "Expose les paramètres compilés (kernel.project_dir, etc.)."
    },
    {
      "id": 9,
      "question": "Comment récupérer la requête courante dans un service ?",
      "type": "single_choice",
      "options": [
        "Injecter `RequestStack` et appeler `getCurrentRequest()`",
        "Injecter `Request` directement",
        "Lire une variable globale",
        "Via un tag"
      ],
      "correct_answers": [
        "Injecter `RequestStack` et appeler `getCurrentRequest()`"
      ],
      "explanation": "Request n'est pas un service; RequestStack centralise les requêtes empilées."
    },
    {
      "id": 10,
      "question": "Quel type injecter pour le mailer natif de Symfony ?",
      "type": "single_choice",
      "options": [
        "`Symfony\\Component\\Mailer\\MailerInterface`",
        "`Symfony\\Component\\Mailer\\Mailer`",
        "`Swift_Mailer`",
        "`App\\Mailer`"
      ],
      "correct_answers": [
        "`Symfony\\Component\\Mailer\\MailerInterface`"
      ],
      "explanation": "Toujours préférer l'interface pour le découplage."
    }
  ]
}