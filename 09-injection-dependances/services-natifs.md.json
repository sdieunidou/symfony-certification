{
  "source_file": "09-injection-dependances/services-natifs.md",
  "title": "Services Natifs (Built-in Services)",
  "questions": [
    {
      "id": 1,
      "question": "Quelle interface faut-il utiliser pour injecter le Logger ?",
      "type": "single_choice",
      "options": [
        "`Monolog\\Logger`",
        "`Psr\\Log\\LoggerInterface`",
        "`Symfony\\Component\\HttpKernel\\Log\\LoggerInterface`",
        "`App\\Service\\Logger`"
      ],
      "correct_answers": [
        "`Psr\\Log\\LoggerInterface`"
      ],
      "explanation": "Symfony privilégie les interfaces PSR pour le découplage."
    },
    {
      "id": 2,
      "question": "Quel service permet d'accéder à la requête courante et à la session ?",
      "type": "single_choice",
      "options": [
        "`Symfony\\Component\\HttpFoundation\\Request`",
        "`Symfony\\Component\\HttpFoundation\\Session\\Session`",
        "`Symfony\\Component\\HttpFoundation\\RequestStack`",
        "`request_stack` (string)"
      ],
      "correct_answers": [
        "`Symfony\\Component\\HttpFoundation\\RequestStack`"
      ],
      "explanation": "`Request` n'est pas un service. Il faut passer par le `RequestStack` pour récupérer la `Request` ou la `Session`."
    },
    {
      "id": 3,
      "question": "Quelle interface permet d'injecter l'EntityManager de Doctrine ?",
      "type": "single_choice",
      "options": [
        "`Doctrine\\ORM\\EntityManager`",
        "`Doctrine\\ORM\\EntityManagerInterface`",
        "`Doctrine\\Persistence\\ObjectManager`",
        "`App\\Repository\\Manager`"
      ],
      "correct_answers": [
        "`Doctrine\\ORM\\EntityManagerInterface`"
      ],
      "explanation": "L'interface est préférée à la classe concrète pour faciliter les mocks et le découplage."
    },
    {
      "id": 4,
      "question": "Quel service (Helper) a été introduit dans Symfony 6.2 pour simplifier l'accès à l'utilisateur connecté et aux permissions ?",
      "type": "single_choice",
      "options": [
        "`SecurityContext`",
        "`Symfony\\Bundle\\SecurityBundle\\Security`",
        "`UserProvider`",
        "`AccessControl`"
      ],
      "correct_answers": [
        "`Symfony\\Bundle\\SecurityBundle\\Security`"
      ],
      "explanation": "La classe `Security` remplace l'injection combinée de `UserStorage` et `AuthorizationChecker` pour les cas courants."
    },
    {
      "id": 5,
      "question": "Quelle interface faut-il utiliser pour injecter le service de validation ?",
      "type": "single_choice",
      "options": [
        "`Symfony\\Component\\Validator\\Validator`",
        "`Symfony\\Component\\Validator\\Validator\\ValidatorInterface`",
        "`Symfony\\Component\\Validation\\ValidatorInterface`",
        "`ValidatorInterface`"
      ],
      "correct_answers": [
        "`Symfony\\Component\\Validator\\Validator\\ValidatorInterface`"
      ],
      "explanation": "C'est l'interface principale du composant Validator."
    }
  ]
}