{
  "source_file": "09-injection-dependances/di_internals.md",
  "title": "Injection de Dépendances : Fonctionnement Interne",
  "questions": [
    {
      "id": 1,
      "question": "À quel moment les **Compiler Passes** sont-elles exécutées ?",
      "type": "single_choice",
      "options": [
        "À chaque requête HTTP.",
        "Uniquement lors de la phase de compilation du container (cache warmup ou premier chargement).",
        "Lors de l'instanciation d'un service.",
        "Au moment du `composer install`."
      ],
      "correct_answers": [
        "Uniquement lors de la phase de compilation du container (cache warmup ou premier chargement)."
      ],
      "explanation": "C'est une étape lourde qui prépare la structure optimisée du container. Elle ne se produit pas au runtime en prod."
    },
    {
      "id": 2,
      "question": "Qu'est-ce qu'une `Definition` dans le contexte du container ?",
      "type": "single_choice",
      "options": [
        "L'instance finale du service.",
        "La configuration (recette) expliquant comment créer le service (classe, arguments, tags).",
        "Une interface PHP.",
        "Un fichier YAML."
      ],
      "correct_answers": [
        "La configuration (recette) expliquant comment créer le service (classe, arguments, tags)."
      ],
      "explanation": "Le container manipule des définitions lors de la compilation, et crée des instances (objets) lors de l'exécution."
    },
    {
      "id": 3,
      "question": "Pourquoi le container est-il dit 'Frozen' (gelé) au runtime ?",
      "type": "single_choice",
      "options": [
        "Car il est stocké dans Redis.",
        "Pour des raisons de performance, on ne peut plus modifier la structure (ajouter des services/definitions) une fois compilé.",
        "Car il ne contient que des constantes.",
        "C'est faux, on peut toujours ajouter des services."
      ],
      "correct_answers": [
        "Pour des raisons de performance, on ne peut plus modifier la structure (ajouter des services/definitions) une fois compilé."
      ],
      "explanation": "La classe PHP générée est statique. On ne peut pas ajouter dynamiquement des méthodes à une classe compilée."
    },
    {
      "id": 4,
      "question": "Comment résoudre une référence circulaire (A a besoin de B qui a besoin de A) ?",
      "type": "single_choice",
      "options": [
        "C'est impossible dans Symfony.",
        "En utilisant l'injection par Setter (au lieu du constructeur) ou un `ServiceLocator` (Lazy Loading).",
        "En mettant les services en `public: true`.",
        "En désactivant l'autowiring."
      ],
      "correct_answers": [
        "En utilisant l'injection par Setter (au lieu du constructeur) ou un `ServiceLocator` (Lazy Loading)."
      ],
      "explanation": "Cela permet de retarder l'instanciation de l'une des dépendances."
    },
    {
      "id": 5,
      "question": "À quoi sert la classe `Reference` lorsqu'on manipule des définitions de services (ex: dans un Compiler Pass ou YAML) ?",
      "type": "single_choice",
      "options": [
        "À créer une référence circulaire.",
        "À représenter un lien vers un autre service (l'équivalent du `@` en YAML).",
        "À documenter le service.",
        "À cloner le service."
      ],
      "correct_answers": [
        "À représenter un lien vers un autre service (l'équivalent du `@` en YAML)."
      ],
      "explanation": "Lors de la compilation, cette référence sera remplacée par l'appel réel au service cible."
    },
    {
      "id": 6,
      "question": "Pourquoi le container compilé est-il dumpé en PHP dans `var/cache/*` ?",
      "type": "single_choice",
      "options": [
        "Pour éviter Composer",
        "Pour que le runtime utilise du code statique sans réflexion ni YAML/JSON",
        "Pour la sérialisation des entités",
        "Pour rendre le conteneur public"
      ],
      "correct_answers": [
        "Pour que le runtime utilise du code statique sans réflexion ni YAML/JSON"
      ],
      "explanation": "Le dump génère des méthodes get* optimisées pour la prod."
    },
    {
      "id": 7,
      "question": "Quel est le risque principal d'une référence circulaire non résolue ?",
      "type": "single_choice",
      "options": [
        "Une `ServiceCircularReferenceException` à la compilation",
        "Une fuite mémoire en prod",
        "Une lenteur sur les logs",
        "Rien, c'est géré automatiquement"
      ],
      "correct_answers": [
        "Une `ServiceCircularReferenceException` à la compilation"
      ],
      "explanation": "Il faut setter injection ou locator pour la casser."
    },
    {
      "id": 8,
      "question": "Quand le Lazy Loading est-il déclenché pour un service marqué `lazy: true` ?",
      "type": "single_choice",
      "options": [
        "Lors de la compilation",
        "À la première invocation d'une méthode sur le proxy injecté",
        "Au boot du kernel",
        "Jamais"
      ],
      "correct_answers": [
        "À la première invocation d'une méthode sur le proxy injecté"
      ],
      "explanation": "Le proxy charge la vraie instance uniquement à l'appel d'une méthode."
    },
    {
      "id": 9,
      "question": "Quelle classe représente la \"recette\" d'un service manipulée pendant la compilation ?",
      "type": "single_choice",
      "options": [
        "`Definition`",
        "`Service`",
        "`Instance`",
        "`ClassMetadata`"
      ],
      "correct_answers": [
        "`Definition`"
      ],
      "explanation": "La Definition contient classe, arguments, calls, tags, visibilité."
    },
    {
      "id": 10,
      "question": "Pourquoi le conteneur est-il immuable (gelé) au runtime ?",
      "type": "single_choice",
      "options": [
        "Pour empêcher les injections SQL",
        "Pour garantir performance et cohérence du graphe de dépendances",
        "Parce que les services sont publics",
        "Pour activer le debug"
      ],
      "correct_answers": [
        "Pour garantir performance et cohérence du graphe de dépendances"
      ],
      "explanation": "Aucune modification de structure n'est autorisée après compilation."
    }
  ]
}