{
  "source_file": "09-injection-dependances/tags.md",
  "title": "Service Tags",
  "questions": [
    {
      "id": 1,
      "question": "Quelle est la méthode recommandée pour injecter une collection de services tagués dans Symfony (sans Compiler Pass) ?",
      "type": "single_choice",
      "options": [
        "Utiliser l'attribut `#[TaggedIterator('mon.tag')]` dans le constructeur.",
        "Utiliser `!tagged_services` dans le YAML.",
        "Faire un `$container->get('mon.tag')`.",
        "Ce n'est pas possible sans Compiler Pass."
      ],
      "correct_answers": [
        "Utiliser l'attribut `#[TaggedIterator('mon.tag')]` dans le constructeur."
      ],
      "explanation": "C'est l'approche standard moderne qui remplace la nécessité d'écrire des Compiler Passes pour les cas simples."
    },
    {
      "id": 2,
      "question": "À quoi sert l'attribut `#[AsTaggedItem]` ?",
      "type": "single_choice",
      "options": [
        "Il remplace totalement `#[AutoconfigureTag]`.",
        "Il sert à configurer les métadonnées du tag (comme l'index et la priorité) pour l'injection.",
        "Il sert à exclure le service de l'injection.",
        "Il sert à créer un nouveau tag."
      ],
      "correct_answers": [
        "Il sert à configurer les métadonnées du tag (comme l'index et la priorité) pour l'injection."
      ],
      "explanation": "`AsTaggedItem` permet de définir `index` et `priority` sur la classe PHP, influençant comment elle sera positionnée dans l'itérateur."
    },
    {
      "id": 3,
      "question": "Comment utiliser une méthode statique du service pour définir sa priorité dans un `TaggedIterator` ?",
      "type": "single_choice",
      "options": [
        "Automatiquement si la méthode s'appelle `getPriority`.",
        "En utilisant l'option `defaultPriorityMethod` dans `#[TaggedIterator]`.",
        "En utilisant l'attribut `#[Priority]` sur la méthode.",
        "Ce n'est pas possible."
      ],
      "correct_answers": [
        "En utilisant l'option `defaultPriorityMethod` dans `#[TaggedIterator]`."
      ],
      "explanation": "On spécifie le nom de la méthode statique à appeler (ex: `defaultPriorityMethod: 'getPriority'`)."
    },
    {
      "id": 4,
      "question": "Dans une Compiler Pass, quel est le format retourné par `$container->findTaggedServiceIds('tag_name')` ?",
      "type": "single_choice",
      "options": [
        "Un tableau simple d'IDs de services : `['service_id_1', 'service_id_2']`.",
        "Un tableau associatif où la clé est l'ID du service et la valeur est un tableau de tags (attributs) : `['service_id' => [['name' => 'tag', 'priority' => 10]]]`. ",
        "Un tableau d'objets `ServiceDefinition`.",
        "Un itérateur."
      ],
      "correct_answers": [
        "Un tableau associatif où la clé est l'ID du service et la valeur est un tableau de tags (attributs) : `['service_id' => [['name' => 'tag', 'priority' => 10]]]`. "
      ],
      "explanation": "Comme un service peut avoir le même tag plusieurs fois, la valeur est un tableau de tableaux d'attributs."
    },
    {
      "id": 5,
      "question": "Si j'utilise `#[TaggedIterator('app.handler', indexAttribute: 'key')]`, que se passe-t-il si un service n'a pas l'attribut 'key' dans son tag ?",
      "type": "single_choice",
      "options": [
        "Symfony utilise l'ID du service comme clé par défaut (fallback).",
        "Une exception est levée à la compilation.",
        "Le service est ignoré.",
        "La clé sera `null`."
      ],
      "correct_answers": [
        "Symfony utilise l'ID du service comme clé par défaut (fallback)."
      ],
      "explanation": "Symfony tente de résoudre l'index (via l'attribut ou la méthode statique), et retombe sur l'ID du service si rien n'est trouvé."
    },
    {
      "id": 6,
      "question": "Quelle est la différence entre `#[AutoconfigureTag]` et `#[AsTaggedItem]` ?",
      "type": "single_choice",
      "options": [
        "`#[AutoconfigureTag]` applique le tag à la classe (définition), tandis que `#[AsTaggedItem]` configure les propriétés de ce tag (index, priorité) pour l'injection.",
        "C'est la même chose.",
        "`#[AutoconfigureTag]` est obsolète.",
        "`#[AsTaggedItem]` ne fonctionne qu'avec les Service Locators."
      ],
      "correct_answers": [
        "`#[AutoconfigureTag]` applique le tag à la classe (définition), tandis que `#[AsTaggedItem]` configure les propriétés de ce tag (index, priorité) pour l'injection."
      ],
      "explanation": "On utilise souvent les deux ensemble si l'interface n'est pas autoconfigurée par défaut."
    },
    {
      "id": 7,
      "question": "Que se passe-t-il si deux services ont le même index dans un `TaggedIterator` indexé ?",
      "type": "single_choice",
      "options": [
        "Le dernier écrase le précédent",
        "Une exception est levée",
        "Les deux sont présents avec des clés différentes",
        "Ils sont fusionnés"
      ],
      "correct_answers": [
        "Le dernier écrase le précédent"
      ],
      "explanation": "Attention aux collisions d'index lors de l'injection."
    },
    {
      "id": 8,
      "question": "Comment exclure un service spécifique d'un `#[TaggedIterator]` ?",
      "type": "single_choice",
      "options": [
        "Avec l'option `exclude: [ServiceClass::class]` sur l'attribut",
        "En le rendant privé",
        "En supprimant le tag",
        "Impossible"
      ],
      "correct_answers": [
        "Avec l'option `exclude: [ServiceClass::class]` sur l'attribut"
      ],
      "explanation": "L'attribut accepte une liste de classes/IDs à exclure."
    },
    {
      "id": 9,
      "question": "Quel attribut permet d'utiliser une méthode statique d'un service tagué pour définir sa clé d'index ?",
      "type": "single_choice",
      "options": [
        "`defaultIndexMethod` dans `#[TaggedIterator]`",
        "`indexMethod` dans `#[AutoconfigureTag]`",
        "`AsTaggedItem` uniquement",
        "Ce n'est pas possible"
      ],
      "correct_answers": [
        "`defaultIndexMethod` dans `#[TaggedIterator]`"
      ],
      "explanation": "Permet de dériver la clé à partir d'une méthode statique."
    },
    {
      "id": 10,
      "question": "Pourquoi `TaggedIterator` est-il 'lazy' ?",
      "type": "single_choice",
      "options": [
        "Les services tagués ne sont instanciés qu'au moment où l'on itère dessus",
        "Parce qu'il stocke les services en cache",
        "Parce qu'il utilise des proxys",
        "Parce qu'il est public"
      ],
      "correct_answers": [
        "Les services tagués ne sont instanciés qu'au moment où l'on itère dessus"
      ],
      "explanation": "RewindableGenerator crée les instances à la demande lors de l'itération."
    }
  ]
}