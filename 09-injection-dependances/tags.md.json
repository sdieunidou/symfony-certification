{
  "source_file": "09-injection-dependances/tags.md",
  "title": "Service Tags",
  "questions": [
    {
      "id": 1,
      "question": "Quelle est la méthode recommandée pour injecter une collection de services tagués dans Symfony (sans Compiler Pass) ?",
      "type": "single_choice",
      "options": [
        "Utiliser l'attribut `#[TaggedIterator('mon.tag')]` dans le constructeur.",
        "Utiliser `!tagged_services` dans le YAML.",
        "Faire un `$container->get('mon.tag')`.",
        "Ce n'est pas possible sans Compiler Pass."
      ],
      "correct_answers": [
        "Utiliser l'attribut `#[TaggedIterator('mon.tag')]` dans le constructeur."
      ],
      "explanation": "C'est l'approche standard moderne qui remplace la nécessité d'écrire des Compiler Passes pour les cas simples."
    },
    {
      "id": 2,
      "question": "À quoi sert l'attribut `#[AsTaggedItem]` ?",
      "type": "single_choice",
      "options": [
        "Il remplace totalement `#[AutoconfigureTag]`.",
        "Il sert à configurer les métadonnées du tag (comme l'index et la priorité) pour l'injection.",
        "Il sert à exclure le service de l'injection.",
        "Il sert à créer un nouveau tag."
      ],
      "correct_answers": [
        "Il sert à configurer les métadonnées du tag (comme l'index et la priorité) pour l'injection."
      ],
      "explanation": "`AsTaggedItem` permet de définir `index` et `priority` sur la classe PHP, influençant comment elle sera positionnée dans l'itérateur."
    },
    {
      "id": 3,
      "question": "Comment utiliser une méthode statique du service pour définir sa priorité dans un `TaggedIterator` ?",
      "type": "single_choice",
      "options": [
        "Automatiquement si la méthode s'appelle `getPriority`.",
        "En utilisant l'option `defaultPriorityMethod` dans `#[TaggedIterator]`.",
        "En utilisant l'attribut `#[Priority]` sur la méthode.",
        "Ce n'est pas possible."
      ],
      "correct_answers": [
        "En utilisant l'option `defaultPriorityMethod` dans `#[TaggedIterator]`."
      ],
      "explanation": "On spécifie le nom de la méthode statique à appeler (ex: `defaultPriorityMethod: 'getPriority'`)."
    },
    {
      "id": 4,
      "question": "Dans une Compiler Pass, quel est le format retourné par `$container->findTaggedServiceIds('tag_name')` ?",
      "type": "single_choice",
      "options": [
        "Un tableau simple d'IDs de services : `['service_id_1', 'service_id_2']`.",
        "Un tableau associatif où la clé est l'ID du service et la valeur est un tableau de tags (attributs) : `['service_id' => [['name' => 'tag', 'priority' => 10]]]`. ",
        "Un tableau d'objets `ServiceDefinition`.",
        "Un itérateur."
      ],
      "correct_answers": [
        "Un tableau associatif où la clé est l'ID du service et la valeur est un tableau de tags (attributs) : `['service_id' => [['name' => 'tag', 'priority' => 10]]]`. "
      ],
      "explanation": "Comme un service peut avoir le même tag plusieurs fois, la valeur est un tableau de tableaux d'attributs."
    },
    {
      "id": 5,
      "question": "Si j'utilise `#[TaggedIterator('app.handler', indexAttribute: 'key')]`, que se passe-t-il si un service n'a pas l'attribut 'key' dans son tag ?",
      "type": "single_choice",
      "options": [
        "Symfony utilise l'ID du service comme clé par défaut (fallback).",
        "Une exception est levée à la compilation.",
        "Le service est ignoré.",
        "La clé sera `null`."
      ],
      "correct_answers": [
        "Symfony utilise l'ID du service comme clé par défaut (fallback)."
      ],
      "explanation": "Symfony tente de résoudre l'index (via l'attribut ou la méthode statique), et retombe sur l'ID du service si rien n'est trouvé."
    }
  ]
}
