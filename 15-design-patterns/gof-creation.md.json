{
  "source_file": "15-design-patterns/gof-creation.md",
  "title": "Design Patterns GoF - Création",
  "questions": [
    {
      "id": 1,
      "question": "Comment Symfony implémente proprement un singleton ?",
      "type": "single_choice",
      "options": [
        "Par le conteneur de services (services partagés par défaut)",
        "Par une classe statique avec instance globale",
        "Par la session PHP",
        "Par un fichier cache"
      ],
      "correct_answers": [
        "Par le conteneur de services (services partagés par défaut)"
      ],
      "explanation": "Le conteneur partage l'instance ; pas besoin de singleton manuel."
    },
    {
      "id": 2,
      "question": "Quand configurer `shared: false` sur un service ?",
      "type": "single_choice",
      "options": [
        "Quand on veut un prototype (nouvelle instance à chaque fois)",
        "Pour le rendre singleton",
        "Pour le rendre public",
        "Pour activer le cache HTTP"
      ],
      "correct_answers": [
        "Quand on veut un prototype (nouvelle instance à chaque fois)"
      ],
      "explanation": "shared:false désactive le comportement singleton du conteneur."
    },
    {
      "id": 3,
      "question": "Quel pattern illustre `createForm()` dans un contrôleur ?",
      "type": "single_choice",
      "options": [
        "Factory Method",
        "Prototype",
        "Singleton",
        "Facade"
      ],
      "correct_answers": [
        "Factory Method"
      ],
      "explanation": "Le contrôleur sert de fabrique simplifiant la création du Form."
    },
    {
      "id": 4,
      "question": "Quel pattern est incarné par le FormBuilder ?",
      "type": "single_choice",
      "options": [
        "Builder (avec Director = FormFactory)",
        "Adapter",
        "Proxy",
        "Observer"
      ],
      "correct_answers": [
        "Builder (avec Director = FormFactory)"
      ],
      "explanation": "Construction étape par étape, orchestrée par le FormFactory (Director)."
    },
    {
      "id": 5,
      "question": "Différence clé entre Abstract Factory et Factory Method ?",
      "type": "single_choice",
      "options": [
        "Abstract Factory fabrique des familles de produits liés; Factory Method crée un produit précis",
        "Factory Method fabrique des familles; Abstract Factory un seul produit",
        "Aucune différence",
        "Factory Method impose l'héritage, Abstract Factory non"
      ],
      "correct_answers": [
        "Abstract Factory fabrique des familles de produits liés; Factory Method crée un produit précis"
      ],
      "explanation": "Abstract Factory coordonne plusieurs créations cohérentes; Factory Method un produit."
    },
    {
      "id": 6,
      "question": "Exemple d'Abstract Factory dans des notifications ?",
      "type": "single_choice",
      "options": [
        "Créer EmailMessage + SmtpTransport ou SmsMessage + ApiTransport",
        "Cloner une entité",
        "Décorer un service",
        "Choisir un logger"
      ],
      "correct_answers": [
        "Créer EmailMessage + SmtpTransport ou SmsMessage + ApiTransport"
      ],
      "explanation": "La fabrique fournit des produits apparentés (message+transport) par canal."
    },
    {
      "id": 7,
      "question": "Prototype : cas d'usage typique ?",
      "type": "single_choice",
      "options": [
        "Dupliquer un projet/template avec ses relations via `__clone`",
        "Forcer le singleton",
        "Créer un proxy",
        "Changer de transport mail"
      ],
      "correct_answers": [
        "Dupliquer un projet/template avec ses relations via `__clone`"
      ],
      "explanation": "Le clonage deep copy sert à copier un graph d'objets existant."
    },
    {
      "id": 8,
      "question": "Quel anti-pattern Singleton faut-il éviter ?",
      "type": "single_choice",
      "options": [
        "Classe avec instance statique globale et constructeur privé",
        "Service partagé du conteneur",
        "Factory Method",
        "Builder"
      ],
      "correct_answers": [
        "Classe avec instance statique globale et constructeur privé"
      ],
      "explanation": "Le singleton manuel complique tests et couplage, préférer le conteneur."
    },
    {
      "id": 9,
      "question": "Comment le conteneur joue-t-il le rôle de Prototype si besoin ?",
      "type": "single_choice",
      "options": [
        "En configurant `shared: false` pour créer une nouvelle instance à chaque demande",
        "En ajoutant un tag",
        "En rendant le service public",
        "En utilisant autoconfigure"
      ],
      "correct_answers": [
        "En configurant `shared: false` pour créer une nouvelle instance à chaque demande"
      ],
      "explanation": "shared:false bascule le service en mode prototype."
    },
    {
      "id": 10,
      "question": "Quel pattern de création facilite le découplage d'une lib tierce en fabriquant ses objets via une interface ?",
      "type": "single_choice",
      "options": [
        "Abstract Factory",
        "Singleton",
        "Observer",
        "Iterator"
      ],
      "correct_answers": [
        "Abstract Factory"
      ],
      "explanation": "On isole la création d'objets externes derrière une fabrique d'abstractions."
    }
  ]
}
