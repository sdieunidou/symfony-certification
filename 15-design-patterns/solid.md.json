{
  "source_file": "15-design-patterns/solid.md",
  "title": "Principes SOLID",
  "questions": [
    {
      "id": 1,
      "question": "Dans l'exemple du principe de Responsabilité Unique (SRP), pourquoi la classe `UserService` initiale est-elle problématique ?",
      "type": "single_choice",
      "options": [
        "Parce qu'elle utilise l'injection de dépendance.",
        "Parce qu'elle gère à la fois la validation, la persistance et l'envoi d'emails.",
        "Parce qu'elle est déclarée `final`.",
        "Parce qu'elle n'implémente pas d'interface."
      ],
      "correct_answers": [
        "Parce qu'elle gère à la fois la validation, la persistance et l'envoi d'emails."
      ],
      "explanation": "Le SRP stipule qu'une classe ne doit avoir qu'une seule raison de changer. Cumuler validation, persistance et notification viole ce principe."
    },
    {
      "id": 2,
      "question": "Selon le principe Ouvert/Fermé (OCP), comment devrions-nous gérer l'ajout d'un nouveau moyen de paiement (ex: Bitcoin) ?",
      "type": "single_choice",
      "options": [
        "En ajoutant une condition `elseif ($method === 'bitcoin')` dans la classe `PaymentService`.",
        "En créant une nouvelle classe `BitcoinPayment` implémentant une interface commune, sans modifier `PaymentService`.",
        "En modifiant directement la classe `Order`.",
        "En créant un nouveau contrôleur dédié."
      ],
      "correct_answers": [
        "En créant une nouvelle classe `BitcoinPayment` implémentant une interface commune, sans modifier `PaymentService`."
      ],
      "explanation": "OCP vise à permettre l'extension (nouvelle classe) sans modification du code existant (`PaymentService`)."
    },
    {
      "id": 3,
      "question": "Quel problème illustre l'exemple de la classe `ArticleEnVedette` qui modifie le retour de `getTitle()` ?",
      "type": "single_choice",
      "options": [
        "Une violation du principe de Substitution de Liskov (LSP).",
        "Une violation du principe de Responsabilité Unique (SRP).",
        "Une erreur de syntaxe PHP.",
        "Une mauvaise utilisation de Doctrine."
      ],
      "correct_answers": [
        "Une violation du principe de Substitution de Liskov (LSP)."
      ],
      "explanation": "La sous-classe change le comportement attendu (le contrat) de la méthode parent. Elle ne peut plus se substituer au parent de manière transparente."
    },
    {
      "id": 4,
      "question": "Comment le principe de Ségrégation des Interfaces (ISP) suggère-t-il de gérer une interface `DataExportInterface` contenant des méthodes pour CSV, JSON et XML ?",
      "type": "single_choice",
      "options": [
        "Garder une seule interface pour centraliser le code.",
        "Implémenter toutes les méthodes dans toutes les classes, même vides.",
        "Découper l'interface en `CsvExportable`, `JsonExportable`, etc.",
        "Utiliser une classe abstraite au lieu d'une interface."
      ],
      "correct_answers": [
        "Découper l'interface en `CsvExportable`, `JsonExportable`, etc."
      ],
      "explanation": "ISP recommande plusieurs petites interfaces spécifiques plutôt qu'une interface globale qui force l'implémentation de méthodes inutiles."
    },
    {
      "id": 5,
      "question": "Dans l'exemple du principe d'Inversion des Dépendances (DIP), quelle est la bonne pratique pour le `NotificationManager` ?",
      "type": "single_choice",
      "options": [
        "Faire `new EmailService()` directement dans la méthode.",
        "Injecter une collection de services implémentant `NotificationServiceInterface`.",
        "Utiliser des méthodes statiques pour envoyer les emails.",
        "Étendre la classe `EmailService`."
      ],
      "correct_answers": [
        "Injecter une collection de services implémentant `NotificationServiceInterface`."
      ],
      "explanation": "DIP préconise de dépendre d'abstractions (interfaces) injectées plutôt que d'instancier des classes concrètes (via `new`)."
    }
  ]
}