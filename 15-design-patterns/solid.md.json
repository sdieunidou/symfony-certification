{
  "source_file": "15-design-patterns/solid.md",
  "title": "Principes SOLID",
  "questions": [
    {
      "id": 1,
      "question": "Pourquoi l'exemple initial de UserService viole SRP ?",
      "type": "single_choice",
      "options": [
        "Il mélange validation, persistance et email dans la même classe",
        "Il est final",
        "Il utilise des interfaces",
        "Il a un constructeur"
      ],
      "correct_answers": [
        "Il mélange validation, persistance et email dans la même classe"
      ],
      "explanation": "Plusieurs raisons de changer => violation SRP."
    },
    {
      "id": 2,
      "question": "Selon le principe Ouvert/Fermé (OCP), comment devrions-nous gérer l'ajout d'un nouveau moyen de paiement (ex: Bitcoin) ?",
      "type": "single_choice",
      "options": [
        "En ajoutant une condition `elseif ($method === 'bitcoin')` dans la classe `PaymentService`.",
        "En créant une nouvelle classe `BitcoinPayment` implémentant une interface commune, sans modifier `PaymentService`.",
        "En modifiant directement la classe `Order`.",
        "En créant un nouveau contrôleur dédié."
      ],
      "correct_answers": [
        "En créant une nouvelle classe `BitcoinPayment` implémentant une interface commune, sans modifier `PaymentService`."
      ],
      "explanation": "OCP vise à permettre l'extension (nouvelle classe) sans modification du code existant (`PaymentService`)."
    },
    {
      "id": 3,
      "question": "Quel problème illustre l'exemple de la classe `ArticleEnVedette` qui modifie le retour de `getTitle()` ?",
      "type": "single_choice",
      "options": [
        "Une violation du principe de Substitution de Liskov (LSP).",
        "Une violation du principe de Responsabilité Unique (SRP).",
        "Une erreur de syntaxe PHP.",
        "Une mauvaise utilisation de Doctrine."
      ],
      "correct_answers": [
        "Une violation du principe de Substitution de Liskov (LSP)."
      ],
      "explanation": "La sous-classe change le comportement attendu (le contrat) de la méthode parent. Elle ne peut plus se substituer au parent de manière transparente."
    },
    {
      "id": 4,
      "question": "Comment le principe de Ségrégation des Interfaces (ISP) suggère-t-il de gérer une interface `DataExportInterface` contenant des méthodes pour CSV, JSON et XML ?",
      "type": "single_choice",
      "options": [
        "Garder une seule interface pour centraliser le code.",
        "Implémenter toutes les méthodes dans toutes les classes, même vides.",
        "Découper l'interface en `CsvExportable`, `JsonExportable`, etc.",
        "Utiliser une classe abstraite au lieu d'une interface."
      ],
      "correct_answers": [
        "Découper l'interface en `CsvExportable`, `JsonExportable`, etc."
      ],
      "explanation": "ISP recommande plusieurs petites interfaces spécifiques plutôt qu'une interface globale qui force l'implémentation de méthodes inutiles."
    },
    {
      "id": 5,
      "question": "Dans l'exemple du principe d'Inversion des Dépendances (DIP), quelle est la bonne pratique pour le `NotificationManager` ?",
      "type": "single_choice",
      "options": [
        "Faire `new EmailService()` directement dans la méthode.",
        "Injecter une collection de services implémentant `NotificationServiceInterface`.",
        "Utiliser des méthodes statiques pour envoyer les emails.",
        "Étendre la classe `EmailService`."
      ],
      "correct_answers": [
        "Injecter une collection de services implémentant `NotificationServiceInterface`."
      ],
      "explanation": "DIP préconise de dépendre d'abstractions (interfaces) injectées plutôt que d'instancier des classes concrètes (via `new`)."
    },
    {
      "id": 6,
      "question": "Comment appliquer SRP à un contrôleur Symfony ?",
      "type": "single_choice",
      "options": [
        "Le limiter à l'orchestration (requête->DTO->use case->réponse) sans logique métier",
        "Mettre toute la logique métier dedans",
        "Gérer directement l'EntityManager",
        "Faire du render uniquement"
      ],
      "correct_answers": [
        "Le limiter à l'orchestration (requête->DTO->use case->réponse) sans logique métier"
      ],
      "explanation": "Un contrôleur doit rester mince et déléguer aux services métiers."
    },
    {
      "id": 7,
      "question": "Quel code est un signal de violation OCP ?",
      "type": "single_choice",
      "options": [
        "Un switch/if sur type pour choisir une implémentation",
        "Injection sur interface",
        "Décoration d'un service",
        "Utilisation de traits"
      ],
      "correct_answers": [
        "Un switch/if sur type pour choisir une implémentation"
      ],
      "explanation": "Les conditions ajoutées à chaque nouveau cas révèlent un manque de polymorphisme."
    },
    {
      "id": 8,
      "question": "Symptôme de violation LSP dans une sous-classe ?",
      "type": "single_choice",
      "options": [
        "Elle restreint les préconditions ou lève de nouvelles exceptions par rapport au parent",
        "Elle ajoute une méthode utilitaire",
        "Elle est finale",
        "Elle utilise une interface"
      ],
      "correct_answers": [
        "Elle restreint les préconditions ou lève de nouvelles exceptions par rapport au parent"
      ],
      "explanation": "Modifier le contrat/les exceptions casse la substituabilité."
    },
    {
      "id": 9,
      "question": "Exemple d'ISP dans Symfony Routing ?",
      "type": "single_choice",
      "options": [
        "Séparer UrlGeneratorInterface et UrlMatcherInterface",
        "Mettre toutes les méthodes dans RouterInterface",
        "Utiliser un singleton",
        "Passer par le container"
      ],
      "correct_answers": [
        "Séparer UrlGeneratorInterface et UrlMatcherInterface"
      ],
      "explanation": "Deux interfaces fines au lieu d'une obèse."
    },
    {
      "id": 10,
      "question": "Bonnes pratiques DIP en Symfony ?",
      "type": "multiple_choice",
      "options": [
        "Typer sur des interfaces (EntityManagerInterface, CacheInterface...)",
        "Injection par constructeur",
        "Éviter les `new` de classes concrètes dans le métier",
        "Utiliser ContainerInterface comme service locator"
      ],
      "correct_answers": [
        "Typer sur des interfaces (EntityManagerInterface, CacheInterface...)",
        "Injection par constructeur",
        "Éviter les `new` de classes concrètes dans le métier"
      ],
      "explanation": "DIP privilégie abstractions et injection; éviter le Service Locator."
    }
  ]
}