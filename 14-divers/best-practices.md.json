{
  "source_file": "14-divers/best-practices.md",
  "title": "Bonnes Pratiques Officielles (Best Practices)",
  "questions": [
    {
      "id": 1,
      "question": "Selon les Best Practices Symfony, comment doit-on organiser la logique métier de l'application ?",
      "type": "single_choice",
      "options": [
        "En créant un Bundle pour chaque fonctionnalité (UserBundle, ProductBundle).",
        "En utilisant un seul AppBundle.",
        "En n'utilisant pas de Bundles, mais en organisant le code dans `src/` avec les namespaces PHP standards.",
        "En mettant tout dans les contrôleurs."
      ],
      "correct_answers": [
        "En n'utilisant pas de Bundles, mais en organisant le code dans `src/` avec les namespaces PHP standards."
      ],
      "explanation": "Les Bundles sont réservés au partage de code entre projets (librairies). Le code applicatif doit résider simplement dans `src/`."
    },
    {
      "id": 2,
      "question": "Où doit-on définir les paramètres sensibles comme les clés d'API en production ?",
      "type": "single_choice",
      "options": [
        "Dans `config/services.yaml`.",
        "Dans des constantes de classe.",
        "Dans le gestionnaire de secrets de Symfony (`bin/console secrets:set`) ou des variables d'environnement réelles.",
        "Dans un fichier `.env` commité sur git."
      ],
      "correct_answers": [
        "Dans le gestionnaire de secrets de Symfony (`bin/console secrets:set`) ou des variables d'environnement réelles."
      ],
      "explanation": "Les secrets ne doivent jamais être commités. Le Vault Symfony permet de les chiffrer et de les commiter en toute sécurité, ou alors d'utiliser des variables d'env serveur."
    },
    {
      "id": 3,
      "question": "Quelle est la bonne pratique concernant la définition des formulaires ?",
      "type": "single_choice",
      "options": [
        "Créer le formulaire directement dans le contrôleur (`createFormBuilder`).",
        "Définir chaque formulaire dans une classe PHP dédiée dans `src/Form`.",
        "Définir le formulaire en YAML.",
        "Générer le HTML manuellement."
      ],
      "correct_answers": [
        "Définir chaque formulaire dans une classe PHP dédiée dans `src/Form`."
      ],
      "explanation": "Cela permet la réutilisation, facilite les tests et sépare la logique de présentation de la logique du contrôleur."
    },
    {
      "id": 4,
      "question": "Pourquoi les URLs doivent-elles être écrites 'en dur' (ex: `/login`) dans les tests fonctionnels plutôt que générées via le routeur ?",
      "type": "single_choice",
      "options": [
        "Parce que le routeur n'est pas disponible en test.",
        "Parce que c'est plus rapide.",
        "Parce que si l'URL change, le test doit échouer pour alerter que les liens externes (bookmarks, emails) seront cassés.",
        "C'est une erreur, il faut toujours utiliser le routeur."
      ],
      "correct_answers": [
        "Parce que si l'URL change, le test doit échouer pour alerter que les liens externes (bookmarks, emails) seront cassés."
      ],
      "explanation": "L'URL publique fait partie du contrat de l'application. Un changement d'URL est un changement majeur qui doit être détecté."
    },
    {
      "id": 5,
      "question": "Quel format de fichier est recommandé pour les traductions (i18n) ?",
      "type": "single_choice",
      "options": [
        "YAML (`.yaml`)",
        "PHP (`.php`)",
        "XLIFF (`.xlf`)",
        "JSON (`.json`)"
      ],
      "correct_answers": [
        "XLIFF (`.xlf`)"
      ],
      "explanation": "XLIFF est le standard industriel supporté par tous les outils de traduction professionnels."
    },
    {
      "id": 6,
      "question": "Où est-il recommandé d'ajouter les boutons de soumission (`SubmitType`) d'un formulaire ?",
      "type": "single_choice",
      "options": [
        "Dans la classe PHP du formulaire (`buildForm`).",
        "Directement dans le template Twig.",
        "Dans le contrôleur.",
        "Dans un fichier de configuration."
      ],
      "correct_answers": [
        "Directement dans le template Twig."
      ],
      "explanation": "Le style et le libellé du bouton dépendent souvent du contexte d'affichage (ex: 'Créer' vs 'Modifier'), il est donc plus flexible de le gérer dans la vue."
    },
    {
      "id": 7,
      "question": "Pourquoi utiliser `AbstractController` est acceptable malgré le couplage au framework ?",
      "type": "single_choice",
      "options": [
        "Parce que la couche contrôleur est déjà dédiée au protocole HTTP et peut dépendre du framework",
        "Parce que cela rend tout le code testable sans kernel",
        "Parce que cela rend les entités plus rapides",
        "Parce que les services ne fonctionnent pas sans"
      ],
      "correct_answers": [
        "Parce que la couche contrôleur est déjà dédiée au protocole HTTP et peut dépendre du framework"
      ],
      "explanation": "Le couplage au framework est limité à la couche Web; le métier reste isolé."
    },
    {
      "id": 8,
      "question": "Quel format privilégier pour la configuration des services applicatifs ?",
      "type": "single_choice",
      "options": [
        "YAML concis pour la majorité, PHP pour les cas complexes",
        "XML obligatoire",
        "Annotations doctrine",
        "Tout en .env"
      ],
      "correct_answers": [
        "YAML concis pour la majorité, PHP pour les cas complexes"
      ],
      "explanation": "Le guide recommande YAML par défaut et PHP quand nécessaire."
    },
    {
      "id": 9,
      "question": "Pourquoi préférer les attributs PHP pour le routing, cache et sécurité ?",
      "type": "single_choice",
      "options": [
        "Ils regroupent la config au plus près du code et évitent les XML/YAML séparés",
        "Ils accélèrent PHP",
        "Ils sont obligatoires en prod",
        "Ils remplacent les tests"
      ],
      "correct_answers": [
        "Ils regroupent la config au plus près du code et évitent les XML/YAML séparés"
      ],
      "explanation": "Les attributs rendent la configuration explicite et locale."
    },
    {
      "id": 10,
      "question": "Pourquoi `AssetMapper` est conseillé comme choix par défaut ?",
      "type": "single_choice",
      "options": [
        "Il évite la toolchain Node/Webpack pour la plupart des besoins modernes",
        "Il compile plus vite que tout",
        "Il est requis en prod",
        "Il ne supporte pas HTTP/2"
      ],
      "correct_answers": [
        "Il évite la toolchain Node/Webpack pour la plupart des besoins modernes"
      ],
      "explanation": "Philosophie no-build : JS/CSS modernes sans complexité front quand c'est suffisant."
    }
  ]
}