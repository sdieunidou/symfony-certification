{
  "source_file": "14-divers/lazy-objects.md",
  "title": "Lazy Objects (Ghost & Proxy)",
  "questions": [
    {
      "id": 1,
      "question": "Quel composant Symfony fournit les traits `LazyGhostTrait` et `LazyProxyTrait` ?",
      "type": "single_choice",
      "options": [
        "symfony/dependency-injection",
        "symfony/proxy-manager-bridge",
        "symfony/var-exporter",
        "symfony/cache"
      ],
      "correct_answers": [
        "symfony/var-exporter"
      ],
      "explanation": "Bien que l'injection de dépendances les utilise, c'est le composant VarExporter qui implémente la magie interne (depuis Symfony 6.2)."
    },
    {
      "id": 2,
      "question": "Quelle est la différence fondamentale entre un Lazy Ghost et un Virtual Proxy ?",
      "type": "single_choice",
      "options": [
        "Le Ghost s'initialise lui-même (in-place), tandis que le Proxy délègue à une instance distincte.",
        "Le Ghost ne fonctionne qu'avec des propriétés publiques.",
        "Le Proxy est plus rapide que le Ghost.",
        "Il n'y a aucune différence, ce sont deux noms pour la même chose."
      ],
      "correct_answers": [
        "Le Ghost s'initialise lui-même (in-place), tandis que le Proxy délègue à une instance distincte."
      ],
      "explanation": "Le Ghost est l'objet réel vide qui se remplit. Le Virtual Proxy est une coquille qui contient l'objet réel."
    },
    {
      "id": 3,
      "question": "Depuis Symfony 6.3, quelle stratégie est utilisée par défaut pour les services `lazy: true` ?",
      "type": "single_choice",
      "options": [
        "Virtual Proxy",
        "Ghost Object",
        "Runtime Exception",
        "Null Object"
      ],
      "correct_answers": [
        "Ghost Object"
      ],
      "explanation": "Symfony privilégie désormais les Ghost Objects pour leurs meilleures performances et une empreinte mémoire réduite."
    },
    {
      "id": 4,
      "question": "Peut-on créer un Lazy Ghost ou un Virtual Proxy pour une classe déclarée `final` ?",
      "type": "single_choice",
      "options": [
        "Oui, sans restriction.",
        "Non, car le mécanisme repose sur l'héritage pour surcharger les propriétés ou méthodes (sauf si on proxyfie une interface).",
        "Oui, mais seulement avec des attributs PHP 8.",
        "Seulement si la classe n'a pas de constructeur."
      ],
      "correct_answers": [
        "Non, car le mécanisme repose sur l'héritage pour surcharger les propriétés ou méthodes (sauf si on proxyfie une interface)."
      ],
      "explanation": "Si la classe est finale, on ne peut pas l'étendre pour y injecter la logique de lazy loading. L'alternative est d'utiliser une interface."
    },
    {
      "id": 5,
      "question": "Quel effet sur l'identité d'objet distingue Ghost et Virtual Proxy ?",
      "type": "single_choice",
      "options": [
        "Ghost : `$obj === $proxy` reste vrai; Proxy : référence différente",
        "Les deux sont toujours identiques",
        "Seul Proxy garde l'identité",
        "Aucun n'est comparable"
      ],
      "correct_answers": [
        "Ghost : `$obj === $proxy` reste vrai; Proxy : référence différente"
      ],
      "explanation": "Ghost modifie l'objet in-place; Proxy délègue à un autre objet."
    },
    {
      "id": 6,
      "question": "Comment activer un service lazy dans `services.yaml` ?",
      "type": "single_choice",
      "options": [
        "Ajouter `lazy: true` sur la définition du service",
        "Mettre `public: true`",
        "Utiliser autowire",
        "Déclarer en XML"
      ],
      "correct_answers": [
        "Ajouter `lazy: true` sur la définition du service"
      ],
      "explanation": "Le conteneur générera un proxy/ghost pour différer l'initialisation."
    },
    {
      "id": 7,
      "question": "Depuis Symfony 6.3, quel type de lazy est utilisé par défaut pour un service `lazy: true` ?",
      "type": "single_choice",
      "options": [
        "Ghost Object",
        "Virtual Proxy",
        "Null Object",
        "Aucun, il instancie directement"
      ],
      "correct_answers": [
        "Ghost Object"
      ],
      "explanation": "Le conteneur privilégie les Ghosts pour performance et empreinte mémoire."
    },
    {
      "id": 8,
      "question": "Quel est le principal inconvénient du Virtual Proxy par rapport au Ghost ?",
      "type": "single_choice",
      "options": [
        "Deux objets en mémoire et identité différente",
        "Impossible de surcharger les méthodes",
        "Pas compatible PSR-4",
        "Nécessite Twig"
      ],
      "correct_answers": [
        "Deux objets en mémoire et identité différente"
      ],
      "explanation": "Le proxy est un wrapper qui contient le sujet réel, augmentant la surcharge."
    },
    {
      "id": 9,
      "question": "Quel point de vigilance sur les propriétés privées/readonly avec LazyGhostTrait ?",
      "type": "single_choice",
      "options": [
        "Le trait gère leur initialisation sans réflexion lourde",
        "Elles sont interdites",
        "Elles sont toujours null",
        "Il faut les rendre publiques"
      ],
      "correct_answers": [
        "Le trait gère leur initialisation sans réflexion lourde"
      ],
      "explanation": "LazyGhostTrait hydrate correctement private/readonly en interne."
    },
    {
      "id": 10,
      "question": "Quel est un cas d'usage typique du lazy dans le conteneur ?",
      "type": "single_choice",
      "options": [
        "Services lourds rarement utilisés (client API, connecteur lourd)",
        "Toutes les entités Doctrine",
        "Les Value Objects",
        "Les DTO"
      ],
      "correct_answers": [
        "Services lourds rarement utilisés (client API, connecteur lourd)"
      ],
      "explanation": "Lazy évite le coût d'initialisation tant que le service n'est pas appelé."
    }
  ]
}