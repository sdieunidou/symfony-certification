{
  "source_file": "14-divers/logging.md",
  "title": "Logging (Journalisation)",
  "questions": [
    {
      "id": 1,
      "question": "Quelle interface standard de logging Symfony utilise-t-il ?",
      "type": "single_choice",
      "options": [
        "`Psr\\Log\\LoggerInterface`",
        "`Symfony\\Component\\Logging\\Logger`",
        "`Monolog\\Logger`",
        "`Psr\\Http\\Message\\LoggerInterface`"
      ],
      "correct_answers": [
        "`Psr\\Log\\LoggerInterface`"
      ],
      "explanation": "Symfony suit PSR-3 et autowire LoggerInterface."
    },
    {
      "id": 2,
      "question": "Pourquoi est-il recommandé d'utiliser le contexte (`$logger->info('User {id}', ['id' => 1])`) plutôt que la concaténation ?",
      "type": "single_choice",
      "options": [
        "Pour économiser de la mémoire.",
        "Pour permettre aux outils d'analyse de logs (Kibana, Sentry) d'indexer les valeurs structurées.",
        "C'est juste une question de style.",
        "La concaténation est interdite par PSR-3."
      ],
      "correct_answers": [
        "Pour permettre aux outils d'analyse de logs (Kibana, Sentry) d'indexer les valeurs structurées."
      ],
      "explanation": "Le contexte préserve la structure des données. La concaténation transforme tout en une simple chaîne de caractères difficile à parser."
    },
    {
      "id": 3,
      "question": "Comment injecter un logger spécifique à un canal (ex: 'doctrine') dans votre service ?",
      "type": "multiple_choice",
      "options": [
        "En utilisant l'attribut `#[Target('doctrine')]` sur l'argument `LoggerInterface`.",
        "En nommant l'argument `$doctrineLogger` (Convention de nommage de l'autowiring).",
        "En instanciant `new Logger('doctrine')`.",
        "En configurant `bind` dans services.yaml."
      ],
      "correct_answers": [
        "En utilisant l'attribut `#[Target('doctrine')]` sur l'argument `LoggerInterface`.",
        "En nommant l'argument `$doctrineLogger` (Convention de nommage de l'autowiring)."
      ],
      "explanation": "Les deux méthodes fonctionnent. L'attribut `#[Target]` est la méthode explicite moderne, mais le nommage de variable fonctionne aussi."
    },
    {
      "id": 4,
      "question": "Quel niveau de log (PSR-3) correspond à 'Une erreur d'exécution qui ne nécessite pas d'action immédiate' ?",
      "type": "single_choice",
      "options": [
        "`warning`",
        "`error`",
        "`critical`",
        "`notice`"
      ],
      "correct_answers": [
        "`error`"
      ],
      "explanation": "`error` signale un échec, mais le système continue de tourner. `critical` ou `alert` nécessiteraient une intervention."
    },
    {
      "id": 5,
      "question": "À quoi servent les 'Processors' dans Monolog ?",
      "type": "single_choice",
      "options": [
        "À écrire les logs sur le disque.",
        "À ajouter automatiquement des informations supplémentaires (contexte) à tous les logs (ex: IP du client, ID de session).",
        "À filtrer les logs par niveau.",
        "À envoyer des emails."
      ],
      "correct_answers": [
        "À ajouter automatiquement des informations supplémentaires (contexte) à tous les logs (ex: IP du client, ID de session)."
      ],
      "explanation": "Un processor est un callback qui reçoit l'enregistrement de log et l'enrichit avant qu'il ne soit passé aux handlers."
    },
    {
      "id": 6,
      "question": "Quel handler prod capture tous les logs précédant une erreur ?",
      "type": "single_choice",
      "options": [
        "`fingers_crossed`",
        "`stream`",
        "`console`",
        "`rotating_file`"
      ],
      "correct_answers": [
        "`fingers_crossed`"
      ],
      "explanation": "Il bufferise et flush tout si un niveau déclencheur est atteint."
    },
    {
      "id": 7,
      "question": "Comment définir un canal personnalisé ?",
      "type": "single_choice",
      "options": [
        "Ajouter le nom dans `monolog.channels` (monolog.yaml)",
        "Créer un Logger à la main",
        "Déclarer un service",
        "Impossible"
      ],
      "correct_answers": [
        "Ajouter le nom dans `monolog.channels` (monolog.yaml)"
      ],
      "explanation": "On liste les canaux custom dans monolog.yaml."
    },
    {
      "id": 8,
      "question": "Comment exclure un canal d'un handler ?",
      "type": "single_choice",
      "options": [
        "Utiliser `channels: ['!event']` dans le handler",
        "Supprimer le canal",
        "Changer le niveau",
        "Impossible"
      ],
      "correct_answers": [
        "Utiliser `channels: ['!event']` dans le handler"
      ],
      "explanation": "Le `!` exclut des canaux d'un handler."
    },
    {
      "id": 9,
      "question": "Quel handler crée un fichier par jour et supprime les anciens ?",
      "type": "single_choice",
      "options": [
        "`rotating_file`",
        "`fingers_crossed`",
        "`group`",
        "`browser_console`"
      ],
      "correct_answers": [
        "`rotating_file`"
      ],
      "explanation": "rotating_file gère la rotation et la rétention."
    },
    {
      "id": 10,
      "question": "Comment enrichir tous les logs avec une donnée globale (ex: userId) ?",
      "type": "single_choice",
      "options": [
        "Créer un processor taggé `monolog.processor` qui ajoute `userId`",
        "Concaténer dans chaque message",
        "Modifier Monolog core",
        "Utiliser printf"
      ],
      "correct_answers": [
        "Créer un processor taggé `monolog.processor` qui ajoute `userId`"
      ],
      "explanation": "Un processor centralise l'enrichissement de chaque record."
    }
  ]
}