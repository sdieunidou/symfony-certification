{
  "source_file": "14-divers/errors.md",
  "title": "Gestion des Erreurs (ErrorHandler)",
  "questions": [
    {
      "id": 1,
      "question": "Où placer les templates Twig d'erreur personnalisés ?",
      "type": "single_choice",
      "options": [
        "`templates/bundles/TwigBundle/Exception/`",
        "`templates/errors/`",
        "`templates/exception/`",
        "`src/Exception/Templates/`"
      ],
      "correct_answers": [
        "`templates/bundles/TwigBundle/Exception/`"
      ],
      "explanation": "Convention de surcharge des pages d'erreur."
    },
    {
      "id": 2,
      "question": "Comment prévisualiser une page d'erreur (ex: 404) en environnement de développement sans provoquer une vraie erreur ?",
      "type": "single_choice",
      "options": [
        "En modifiant le code pour lancer une exception.",
        "En accédant aux routes spéciales `/_error/{code}` (ex: `/_error/404`).",
        "En passant `APP_ENV=prod` dans le `.env`.",
        "C'est impossible."
      ],
      "correct_answers": [
        "En accédant aux routes spéciales `/_error/{code}` (ex: `/_error/404`)."
      ],
      "explanation": "Symfony expose ces routes (via le routing de dev) pour permettre le design des pages d'erreur sans quitter le mode debug."
    },
    {
      "id": 3,
      "question": "Quelle nouveauté de Symfony 7.3 permet de gérer les erreurs fatales qui surviennent AVANT le démarrage du Kernel ou pendant le rendu Twig ?",
      "type": "single_choice",
      "options": [
        "Le mode `Rescue`.",
        "Les Pages d'Erreur Statiques (générées via `error:dump`).",
        "Le `FatalErrorHandler`.",
        "Le fallback HTML."
      ],
      "correct_answers": [
        "Les Pages d'Erreur Statiques (générées via `error:dump`)."
      ],
      "explanation": "La commande `error:dump` génère des fichiers HTML statiques que le serveur web peut servir directement si PHP plante complètement."
    },
    {
      "id": 4,
      "question": "Quel handler Monolog est couramment utilisé en production pour n'écrire les logs qu'en cas d'erreur critique (gardant le contexte de debug en mémoire) ?",
      "type": "single_choice",
      "options": [
        "`stream`",
        "`fingers_crossed`",
        "`buffer`",
        "`filter`"
      ],
      "correct_answers": [
        "`fingers_crossed`"
      ],
      "explanation": "Ce handler garde les logs dans un buffer et ne les écrit sur le disque que si un certain niveau (ex: ERROR) est atteint. Cela permet d'avoir les logs 'debug' qui ont précédé l'erreur sans polluer le disque le reste du temps."
    },
    {
      "id": 5,
      "question": "Quelles variables sont disponibles dans les templates d'erreur Twig (ex: `error404.html.twig`) ?",
      "type": "single_choice",
      "options": [
        "`request`, `response`, `user`",
        "`status_code`, `status_text`, `exception`",
        "`error_code`, `message`, `stack_trace`",
        "`code`, `msg`, `e`"
      ],
      "correct_answers": [
        "`status_code`, `status_text`, `exception`"
      ],
      "explanation": "Ces variables permettent d'afficher le code HTTP, le message standard et d'accéder à l'objet exception."
    },
    {
      "id": 6,
      "question": "Quel événement pouvez-vous écouter pour personnaliser le handling d'une exception avant rendu ?",
      "type": "single_choice",
      "options": [
        "`kernel.exception` (ExceptionEvent)",
        "`kernel.request`",
        "`kernel.response`",
        "`kernel.terminate`"
      ],
      "correct_answers": [
        "`kernel.exception` (ExceptionEvent)"
      ],
      "explanation": "ExceptionEvent permet de loguer, modifier la réponse ou rediriger."
    },
    {
      "id": 7,
      "question": "Comment tester une page d'erreur Twig sans déclencher d'exception en prod ?",
      "type": "single_choice",
      "options": [
        "Utiliser `error:dump` pour générer et consulter les pages statiques",
        "Lancer une 404 réelle",
        "Activer debug",
        "Impossible"
      ],
      "correct_answers": [
        "Utiliser `error:dump` pour générer et consulter les pages statiques"
      ],
      "explanation": "error:dump génère les pages HTML à servir par le serveur web."
    },
    {
      "id": 8,
      "question": "Quelle variable dans le template ne doit pas être exposée telle quelle en prod (risque de fuite) ?",
      "type": "single_choice",
      "options": [
        "`exception` (message/trace)",
        "`status_code`",
        "`status_text`",
        "`app.request`"
      ],
      "correct_answers": [
        "`exception` (message/trace)"
      ],
      "explanation": "Le message/trace peut révéler des secrets; en prod il faut filtrer."
    },
    {
      "id": 9,
      "question": "Que se passe-t-il si une erreur survient lors du rendu de `error500.html.twig` ?",
      "type": "single_choice",
      "options": [
        "Symfony affiche une page de secours minimaliste hardcodée",
        "Page blanche",
        "Redirect /",
        "Kernel stoppe sans réponse"
      ],
      "correct_answers": [
        "Symfony affiche une page de secours minimaliste hardcodée"
      ],
      "explanation": "Fallback de secours pour éviter le blank screen."
    },
    {
      "id": 10,
      "question": "Comment gérer la réponse JSON pour les erreurs si le client en demande ?",
      "type": "single_choice",
      "options": [
        "ErrorHandler renvoie du JSON si Accept le demande et Serializer est dispo",
        "Toujours HTML",
        "Toujours 204",
        "Il faut écrire son propre listener"
      ],
      "correct_answers": [
        "ErrorHandler renvoie du JSON si Accept le demande et Serializer est dispo"
      ],
      "explanation": "Le handler adapte le format selon Accept et dispo du serializer."
    }
  ]
}